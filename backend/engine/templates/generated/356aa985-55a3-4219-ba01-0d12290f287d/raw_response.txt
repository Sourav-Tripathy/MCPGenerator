{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams, OrderResponse, ErrorResponse\nfrom client import KiteConnectClient, KiteApiException\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectOrders\",\n    description=\"Provides tools to interact with the Kite Connect Orders API, allowing users to place, modify, cancel, and retrieve stock market orders and trades via Zerodha's Kite platform.\"\n)\n\n# Initialize Kite Connect API Client\ntry:\n    kite_client = KiteConnectClient()\nexcept ValueError as e:\n    logger.error(f\"Failed to initialize KiteConnectClient: {e}\")\n    # Exit or handle appropriately if client initialization fails\n    exit(1)\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\n\n    Args:\n        params: Parameters for placing the order.\n\n    Returns:\n        A dictionary containing the 'order_id' of the successfully placed order or an error dictionary.\n    \"\"\"\n    logger.info(f\"Received place_order request with variety: {params.variety}, symbol: {params.tradingsymbol}\")\n    try:\n        result = await kite_client.place_order(params)\n        logger.info(f\"Successfully placed order: {result.get('order_id')}\")\n        # Ensure the response matches the OrderResponse model if needed, or return raw dict\n        # For simplicity, returning the dict directly as Kite API might have variations\n        return result # Potentially wrap in OrderResponse(**result).dict()\n    except KiteApiException as e:\n        logger.error(f\"Kite API error during place_order: {e}\")\n        return ErrorResponse(error=str(e), type=e.__class__.__name__).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error during place_order: {e}\")\n        return ErrorResponse(error=\"An unexpected server error occurred.\", type=\"ServerError\").dict()\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modify attributes of a pending regular or CO order.\n\n    Args:\n        params: Parameters for modifying the order.\n\n    Returns:\n        A dictionary containing the 'order_id' of the successfully modified order or an error dictionary.\n    \"\"\"\n    logger.info(f\"Received modify_order request for order_id: {params.order_id}, variety: {params.variety}\")\n    try:\n        result = await kite_client.modify_order(params)\n        logger.info(f\"Successfully modified order: {result.get('order_id')}\")\n        return result # Potentially wrap in OrderResponse(**result).dict()\n    except KiteApiException as e:\n        logger.error(f\"Kite API error during modify_order: {e}\")\n        return ErrorResponse(error=str(e), type=e.__class__.__name__).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error during modify_order: {e}\")\n        return ErrorResponse(error=\"An unexpected server error occurred.\", type=\"ServerError\").dict()\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"Cancel a pending order.\n\n    Args:\n        params: Parameters for cancelling the order.\n\n    Returns:\n        A dictionary containing the 'order_id' of the successfully cancelled order or an error dictionary.\n    \"\"\"\n    logger.info(f\"Received cancel_order request for order_id: {params.order_id}, variety: {params.variety}\")\n    try:\n        result = await kite_client.cancel_order(params)\n        logger.info(f\"Successfully cancelled order: {result.get('order_id')}\")\n        return result # Potentially wrap in OrderResponse(**result).dict()\n    except KiteApiException as e:\n        logger.error(f\"Kite API error during cancel_order: {e}\")\n        return ErrorResponse(error=str(e), type=e.__class__.__name__).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error during cancel_order: {e}\")\n        return ErrorResponse(error=\"An unexpected server error occurred.\", type=\"ServerError\").dict()\n\nif __name__ == \"__main__\":\n    import uvicorn\n    # Run the MCP server using uvicorn\n    # Example: uvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n    # The FastMCP object automatically creates a FastAPI app instance at mcp.app\n    logger.info(\"Starting KiteConnectOrders MCP server...\")\n    # Note: Running directly like this is for development.\n    # Use a proper ASGI server like uvicorn or hypercorn in production.\n    uvicorn.run(\"main:mcp.app\", host=\"0.0.0.0\", port=8000, reload=True)\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field, validator\nfrom typing import Optional, Literal, Dict, Any\n\n# Define Literal types for restricted parameter values\nVarietyType = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nExchangeType = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\nModifyVarietyType = Literal['regular', 'co']\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Input model for placing an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"The variety of the order.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., 'INFY', 'NIFTY23JUL18500CE').\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange.\")\n    transaction_type: TransactionType = Field(..., description=\"Transaction type.\")\n    order_type: OrderType = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: ProductType = Field(..., description=\"Product type (CNC, NRML, MIS, MTF).\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (required for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (required for SL, SL-M orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity: ValidityType = Field(..., description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes (required for TTL validity orders).\")\n    iceberg_legs: Optional[int] = Field(None, ge=2, le=10, description=\"Total number of legs for iceberg order type (2-10). Required for variety='iceberg'.\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs). Required for variety='iceberg'.\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction. Required for variety='auction'.\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"An optional tag to apply to an order (alphanumeric, max 20 chars).\")\n\n    @validator('price')\n    def check_price(cls, v, values):\n        if values.get('order_type') == 'LIMIT' and v is None:\n            raise ValueError('Price is required for LIMIT orders')\n        if values.get('order_type') == 'MARKET' and v is not None:\n            # Kite API might ignore price for MARKET, but good practice to not send it\n            pass # Or raise ValueError('Price should not be provided for MARKET orders')\n        return v\n\n    @validator('trigger_price')\n    def check_trigger_price(cls, v, values):\n        if values.get('order_type') in ['SL', 'SL-M'] and v is None:\n            raise ValueError('Trigger price is required for SL and SL-M orders')\n        return v\n\n    @validator('validity_ttl')\n    def check_validity_ttl(cls, v, values):\n        if values.get('validity') == 'TTL' and v is None:\n            raise ValueError('validity_ttl is required for TTL validity')\n        return v\n\n    @validator('iceberg_legs')\n    def check_iceberg_legs(cls, v, values):\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError('iceberg_legs is required for iceberg variety')\n        return v\n\n    @validator('iceberg_quantity')\n    def check_iceberg_quantity(cls, v, values):\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError('iceberg_quantity is required for iceberg variety')\n        # Add check: iceberg_quantity * iceberg_legs should ideally equal quantity\n        # This logic might be complex depending on rounding, leave to API validation for now\n        return v\n\n    @validator('auction_number')\n    def check_auction_number(cls, v, values):\n        if values.get('variety') == 'auction' and v is None:\n            raise ValueError('auction_number is required for auction variety')\n        return v\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Input model for modifying an order.\"\"\"\n    variety: ModifyVarietyType = Field(..., description=\"The variety of the order to modify. Currently supports 'regular' and 'co'.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Parent order id is required for second leg CO modification.\")\n    # Fields applicable primarily for 'regular' variety modification\n    order_type: Optional[OrderType] = Field(None, description=\"New order type (only applicable for variety='regular').\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity (only applicable for variety='regular').\")\n    # Price/Trigger Price applicable for both regular (LIMIT/SL/SL-M) and CO\n    price: Optional[float] = Field(None, description=\"New price (applicable for LIMIT orders for variety='regular', or for CO orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (applicable for SL, SL-M orders for variety='regular', or for LIMIT CO orders).\")\n    # Fields applicable only for 'regular' variety modification\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (only applicable for variety='regular').\")\n    validity: Optional[ValidityType] = Field(None, description=\"New validity (only applicable for variety='regular').\")\n\n    @validator('parent_order_id')\n    def check_parent_order_id(cls, v, values):\n        # Basic check, actual requirement depends on whether it's a second leg CO order\n        # This might need more context from the order being modified\n        return v\n\nclass CancelOrderParams(BaseModel):\n    \"\"\"Input model for cancelling an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"The variety of the order to cancel.\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Parent order id is required for second leg CO cancellation.\")\n\nclass OrderResponse(BaseModel):\n    \"\"\"Standard response model for successful order operations.\"\"\"\n    order_id: str = Field(..., description=\"The unique order ID.\")\n    # Kite API might return more data, but order_id is the key identifier\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response model.\"\"\"\n    error: str = Field(..., description=\"Description of the error.\")\n    type: str = Field(..., description=\"Type of the error (e.g., KiteInputException, ServerError).\")\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport os\nimport logging\nfrom typing import Dict, Any\n\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams\n\nlogger = logging.getLogger(__name__)\n\n# Custom Exception Hierarchy for Kite API Errors\nclass KiteApiException(Exception):\n    \"\"\"Base exception for Kite Connect API errors.\"\"\"\n    def __init__(self, message=\"Kite API error occurred\", status_code=None, details=None):\n        self.message = message\n        self.status_code = status_code\n        self.details = details\n        super().__init__(self.message)\n\n    def __str__(self):\n        return f\"{self.__class__.__name__}: {self.message} (Status: {self.status_code}, Details: {self.details})\"\n\nclass KiteInputException(KiteApiException):\n    \"\"\"Input validation errors (400 Bad Request).\"\"\"\n    pass\n\nclass KiteTokenException(KiteApiException):\n    \"\"\"Authentication errors (403 Forbidden - Invalid Token).\"\"\"\n    pass\n\nclass KitePermissionException(KiteApiException):\n    \"\"\"Permission errors (403 Forbidden - Other).\"\"\"\n    pass\n\nclass KiteNetworkException(KiteApiException):\n    \"\"\"Network or connection errors.\"\"\"\n    pass\n\nclass KiteOrderException(KiteApiException):\n    \"\"\"Order placement/modification/cancellation errors (RMS, etc.). Often 400 or 500 status.\"\"\"\n    pass\n\nclass KiteRateLimitException(KiteApiException):\n    \"\"\"Rate limit exceeded (429 Too Many Requests).\"\"\"\n    pass\n\nclass KiteGeneralException(KiteApiException):\n    \"\"\"Other unclassified API errors (e.g., 500 Internal Server Error).\"\"\"\n    pass\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect Orders API.\"\"\"\n\n    def __init__(self, timeout: float = 30.0):\n        \"\"\"Initializes the Kite Connect client.\n\n        Args:\n            timeout: Request timeout in seconds.\n\n        Raises:\n            ValueError: If required environment variables are not set.\n        \"\"\"\n        self.api_key = os.getenv(\"KITE_API_KEY\")\n        self.access_token = os.getenv(\"KITE_ACCESS_TOKEN\")\n        self.base_url = os.getenv(\"KITE_API_BASE_URL\", \"https://api.kite.trade\")\n\n        if not self.api_key:\n            raise ValueError(\"KITE_API_KEY environment variable not set.\")\n        if not self.access_token:\n            raise ValueError(\"KITE_ACCESS_TOKEN environment variable not set.\")\n\n        self.headers = {\n            \"X-Kite-Version\": \"3\",  # Specify Kite API version\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form data\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=timeout\n        )\n        logger.info(f\"KiteConnectClient initialized for base URL: {self.base_url}\")\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous request to the Kite API.\n\n        Args:\n            method: HTTP method (GET, POST, PUT, DELETE).\n            endpoint: API endpoint path.\n            data: Dictionary of form data for POST/PUT requests.\n\n        Returns:\n            The JSON response data as a dictionary.\n\n        Raises:\n            KiteApiException: If an API error occurs.\n            KiteNetworkException: If a network error occurs.\n        \"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Making {method} request to {url} with data: {data}\")\n\n        try:\n            response = await self.client.request(method, endpoint, data=data)\n\n            logger.debug(f\"Received response: Status={response.status_code}, Body={response.text[:500]}\") # Log truncated body\n\n            # Check for specific error status codes first\n            if response.status_code == 400:\n                error_data = self._parse_response(response)\n                raise KiteInputException(\"Input validation error\", response.status_code, error_data)\n            elif response.status_code == 403:\n                error_data = self._parse_response(response)\n                # Differentiate between token and permission errors if possible from response\n                if \"token\" in error_data.get(\"message\", \"\").lower():\n                     raise KiteTokenException(\"Authentication error (Invalid Token/Key)\", response.status_code, error_data)\n                else:\n                     raise KitePermissionException(\"Permission denied\", response.status_code, error_data)\n            elif response.status_code == 429:\n                raise KiteRateLimitException(\"Rate limit exceeded\", response.status_code, self._parse_response(response))\n            elif response.status_code == 500:\n                 raise KiteGeneralException(\"Internal server error\", response.status_code, self._parse_response(response))\n            elif response.status_code >= 400: # Catch other 4xx/5xx errors\n                error_data = self._parse_response(response)\n                # Try to map to OrderException if context suggests it, otherwise GeneralException\n                if \"order\" in endpoint: # Heuristic\n                    raise KiteOrderException(\"Order operation failed\", response.status_code, error_data)\n                else:\n                    raise KiteGeneralException(\"General API error\", response.status_code, error_data)\n\n            # Raise for status for any remaining >= 400 codes not explicitly handled\n            response.raise_for_status()\n\n            # Parse successful response\n            json_response = self._parse_response(response)\n            if json_response.get(\"status\") == \"error\":\n                # Handle cases where status is 200 but response indicates error\n                message = json_response.get(\"message\", \"Unknown API error\")\n                logger.error(f\"API returned 200 but error status: {message}\")\n                # Map based on message content if possible\n                if \"order\" in message.lower() or \"rms\" in message.lower():\n                    raise KiteOrderException(message, response.status_code, json_response)\n                else:\n                    raise KiteGeneralException(message, response.status_code, json_response)\n\n            return json_response.get(\"data\", {}) # Kite API wraps successful data in 'data'\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out: {e}\")\n            raise KiteNetworkException(f\"Request timed out: {e}\")\n        except httpx.RequestError as e:\n            logger.error(f\"HTTP request error: {e}\")\n            raise KiteNetworkException(f\"HTTP request error: {e}\")\n        except KiteApiException: # Re-raise specific Kite exceptions\n            raise\n        except Exception as e:\n            logger.exception(f\"Unexpected error during API request: {e}\")\n            raise KiteGeneralException(f\"An unexpected error occurred: {e}\")\n\n    def _parse_response(self, response: httpx.Response) -> Dict[str, Any]:\n        \"\"\"Safely parses JSON response.\"\"\"\n        try:\n            return response.json()\n        except Exception as e:\n            logger.warning(f\"Failed to parse JSON response (Status: {response.status_code}): {response.text}. Error: {e}\")\n            # Return a structured error if parsing fails but text might be useful\n            return {\"error\": \"Failed to parse JSON response\", \"raw_response\": response.text}\n\n    def _prepare_form_data(self, params: BaseModel) -> Dict[str, Any]:\n        \"\"\"Converts Pydantic model to a dictionary suitable for form data, excluding None values.\"\"\"\n        data = params.dict(exclude_unset=True, exclude_none=True)\n        # Convert boolean/numeric types to string if required by API, but Kite usually handles them\n        # Example: data = {k: str(v) for k, v in data.items()}\n        return data\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, str]:\n        \"\"\"Place an order.\n\n        Args:\n            params: Order placement parameters.\n\n        Returns:\n            Dictionary containing the 'order_id'.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Exclude 'variety' from the form data as it's in the path\n        form_data = self._prepare_form_data(params.copy(exclude={'variety'}))\n        return await self._request(\"POST\", endpoint, data=form_data)\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, str]:\n        \"\"\"Modify a pending order.\n\n        Args:\n            params: Order modification parameters.\n\n        Returns:\n            Dictionary containing the 'order_id'.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Exclude 'variety' and 'order_id' from the form data\n        form_data = self._prepare_form_data(params.copy(exclude={'variety', 'order_id'}))\n        return await self._request(\"PUT\", endpoint, data=form_data)\n\n    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, str]:\n        \"\"\"Cancel a pending order.\n\n        Args:\n            params: Order cancellation parameters.\n\n        Returns:\n            Dictionary containing the 'order_id'.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Include parent_order_id in form data if present\n        form_data = self._prepare_form_data(params.copy(exclude={'variety', 'order_id'}))\n        # Note: DELETE requests typically don't have a body, but Kite uses form data here\n        return await self._request(\"DELETE\", endpoint, data=form_data)\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=2.0.0,<3.0.0\nhttpx>=0.25.0,<0.28.0\npython-dotenv>=1.0.0\nuvicorn[standard]>=0.23.0,<0.28.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer account (https://developers.kite.trade/)\n\n# Your Kite application's API key\nKITE_API_KEY=\n\n# The access token obtained after the login flow (this is typically short-lived)\n# You might need a mechanism to refresh or obtain this token regularly.\nKITE_ACCESS_TOKEN=\n\n# Base URL for the Kite Connect API (usually doesn't need changing)\nKITE_API_BASE_URL=https://api.kite.trade\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server built with FastMCP to interact with the Zerodha Kite Connect Orders API. It allows language models or other applications to place, modify, and cancel stock market orders through a standardized interface.\n\n## Features\n\n*   **Place Orders:** Place various types of orders (regular, AMO, CO, Iceberg, Auction).\n*   **Modify Orders:** Modify pending regular or CO orders.\n*   **Cancel Orders:** Cancel pending orders.\n*   **Typed Interface:** Uses Pydantic models for clear and validated input/output.\n*   **Asynchronous:** Built with `asyncio` and `httpx` for non-blocking I/O.\n*   **Error Handling:** Maps Kite API errors to specific Python exceptions.\n\n## Setup\n\n1.  **Clone the Repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a Virtual Environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install Dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect API credentials:\n        *   `KITE_API_KEY`: Your application's API key from Kite Developer.\n        *   `KITE_ACCESS_TOKEN`: A valid access token obtained through the Kite Connect login flow. **Note:** Access tokens are typically short-lived and need to be refreshed or regenerated.\n        *   `KITE_API_BASE_URL`: (Optional) Defaults to `https://api.kite.trade`.\n\n## Running the Server\n\nUse an ASGI server like Uvicorn to run the FastMCP application:\n\n```bash\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n*   `--reload`: Automatically restarts the server when code changes (for development).\n\nThe MCP server will be available at `http://localhost:8000` (or the specified host/port).\n\n## Available Tools\n\nThe server exposes the following tools compatible with the MCP specification:\n\n1.  **`place_order`**\n    *   **Description:** Place an order of a particular variety.\n    *   **Input:** `PlaceOrderParams` model (see `models.py` for fields like `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, etc.).\n    *   **Output:** Dictionary containing the `order_id` on success, or an `ErrorResponse` dictionary on failure.\n\n2.  **`modify_order`**\n    *   **Description:** Modify attributes of a pending regular or CO order.\n    *   **Input:** `ModifyOrderParams` model (see `models.py` for fields like `variety`, `order_id`, `quantity`, `price`, `trigger_price`, etc.).\n    *   **Output:** Dictionary containing the `order_id` on success, or an `ErrorResponse` dictionary on failure.\n\n3.  **`cancel_order`**\n    *   **Description:** Cancel a pending order.\n    *   **Input:** `CancelOrderParams` model (see `models.py` for fields like `variety`, `order_id`, `parent_order_id`).\n    *   **Output:** Dictionary containing the `order_id` on success, or an `ErrorResponse` dictionary on failure.\n\n## Authentication\n\nAuthentication is handled via the `KITE_API_KEY` and `KITE_ACCESS_TOKEN` environment variables, which are passed in the `Authorization` header of requests to the Kite Connect API.\n\n**Important:** Managing the lifecycle of the `KITE_ACCESS_TOKEN` (obtaining and refreshing it) is outside the scope of this basic MCP server implementation and needs to be handled by your application's authentication flow.\n\n## Error Handling\n\nThe `KiteConnectClient` attempts to map HTTP status codes and error messages from the Kite API to specific exceptions (e.g., `KiteInputException`, `KiteTokenException`, `KiteOrderException`). These are caught in `main.py` and returned as structured `ErrorResponse` dictionaries.\n"
    }
  ]
}
{
  "files": [
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field, validator, root_validator\nfrom typing import Optional, Literal, Dict, Any\n\n# Define constants for reusable literals\nVarietyType = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nExchangeType = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety (regular, amo, co, iceberg, auction)\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange (NSE, BSE, NFO, CDS, BCD, MCX)\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., 'INFY', 'NIFTY21JUNFUT')\")\n    transaction_type: TransactionType = Field(..., description=\"Transaction type (BUY or SELL)\")\n    order_type: OrderType = Field(..., description=\"Order type (MARKET, LIMIT, SL, SL-M)\")\n    quantity: int = Field(..., description=\"Quantity to transact (must be positive)\")\n    product: ProductType = Field(..., description=\"Product type (CNC, NRML, MIS, MTF)\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT or SL orders. Required for LIMIT/SL, ignored for MARKET/SL-M.\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M, or CO orders. Required for SL/SL-M.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades only, must be non-negative)\")\n    validity: ValidityType = Field(\"DAY\", description=\"Order validity (DAY, IOC, TTL)\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes. Required if validity is TTL.\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order (must be 2-10). Required if variety is iceberg.\")\n    tag: Optional[str] = Field(None, description=\"An optional tag for the order. Max 20 chars.\") # Added common optional field\n\n    @validator('quantity')\n    def quantity_must_be_positive(cls, v):\n        if v <= 0:\n            raise ValueError('Quantity must be positive')\n        return v\n\n    @validator('disclosed_quantity')\n    def disclosed_quantity_must_be_non_negative(cls, v):\n        if v is not None and v < 0:\n            raise ValueError('Disclosed quantity must be non-negative')\n        return v\n\n    @root_validator\n    def check_conditional_required_fields(cls, values):\n        order_type = values.get('order_type')\n        price = values.get('price')\n        trigger_price = values.get('trigger_price')\n        variety = values.get('variety')\n        validity = values.get('validity')\n        validity_ttl = values.get('validity_ttl')\n        iceberg_legs = values.get('iceberg_legs')\n\n        if order_type in ['LIMIT', 'SL'] and price is None:\n            raise ValueError('Price is required for LIMIT and SL orders')\n\n        if order_type in ['SL', 'SL-M'] and trigger_price is None:\n            raise ValueError('Trigger price is required for SL and SL-M orders')\n\n        if variety == 'co' and trigger_price is None:\n             # Note: Kite Connect docs imply trigger_price might be optional for CO depending on context, \n             # but often it's needed or calculated. Adding validation based on common usage.\n             # Adjust if specific CO variations don't need it.\n             pass # Let's assume API handles CO trigger price logic for now, or adjust validation as needed.\n\n        if validity == 'TTL' and validity_ttl is None:\n            raise ValueError('validity_ttl is required when validity is TTL')\n\n        if validity != 'TTL' and validity_ttl is not None:\n            raise ValueError('validity_ttl is only applicable when validity is TTL')\n\n        if variety == 'iceberg' and iceberg_legs is None:\n            raise ValueError('iceberg_legs is required when variety is iceberg')\n        \n        if variety == 'iceberg' and iceberg_legs is not None and not (2 <= iceberg_legs <= 10):\n            raise ValueError('iceberg_legs must be between 2 and 10')\n\n        if variety != 'iceberg' and iceberg_legs is not None:\n            raise ValueError('iceberg_legs is only applicable when variety is iceberg')\n            \n        # Ensure trigger price logic for SL/SL-M\n        if order_type == 'SL':\n            transaction_type = values.get('transaction_type')\n            if transaction_type == 'BUY' and trigger_price is not None and price is not None and trigger_price >= price:\n                raise ValueError('For SL BUY orders, trigger_price must be less than price.')\n            if transaction_type == 'SELL' and trigger_price is not None and price is not None and trigger_price <= price:\n                raise ValueError('For SL SELL orders, trigger_price must be greater than price.')\n\n        return values\n\nclass PlaceOrderResponse(BaseModel):\n    \"\"\"Response after successfully placing an order.\"\"\"\n    order_id: str = Field(..., description=\"The unique order ID.\")\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response structure.\"\"\"\n    status: str = Field(..., description=\"Status of the response, e.g., 'error'\")\n    message: str = Field(..., description=\"Detailed error message\")\n    error_type: str = Field(..., description=\"Category of the error, e.g., 'InputException', 'NetworkException'\")\n    data: Optional[Dict[str, Any]] = Field(None, description=\"Additional error details if available\")\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nimport os\nimport asyncio\nfrom typing import Dict, Any, Optional\nfrom models import PlaceOrderParams, PlaceOrderResponse, ErrorResponse, VarietyType\n\nlogger = logging.getLogger(__name__)\n\nclass KiteConnectError(Exception):\n    \"\"\"Base exception for Kite Connect client errors.\"\"\"\n    def __init__(self, message=\"An error occurred with the Kite Connect API\", status_code=None, error_type=None, data=None):\n        self.message = message\n        self.status_code = status_code\n        self.error_type = error_type\n        self.data = data\n        super().__init__(self.message)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"status\": \"error\",\n            \"message\": self.message,\n            \"error_type\": self.error_type or self.__class__.__name__,\n            \"data\": self.data\n        }\n\nclass AuthenticationError(KiteConnectError):\n    \"\"\"Exception for authentication issues (403 Forbidden).\"\"\"\n    pass\n\nclass NetworkError(KiteConnectError):\n    \"\"\"Exception for network-related issues (timeouts, connection errors).\"\"\"\n    pass\n\nclass BadRequestError(KiteConnectError):\n    \"\"\"Exception for client-side errors (400 Bad Request).\"\"\"\n    pass\n\nclass ServerError(KiteConnectError):\n    \"\"\"Exception for server-side errors (5xx).\"\"\"\n    pass\n\nclass RateLimitError(KiteConnectError):\n    \"\"\"Exception for rate limit errors (429 Too Many Requests).\"\"\"\n    pass\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Zerodha Kite Connect API v3.\"\"\"\n\n    def __init__(self, max_retries: int = 3, backoff_factor: float = 0.5):\n        self.api_key = os.getenv(\"KITE_API_KEY\")\n        self.access_token = os.getenv(\"KITE_ACCESS_TOKEN\")\n        self.base_url = os.getenv(\"KITE_ROOT_URL\", \"https://api.kite.trade\")\n        self.max_retries = max_retries\n        self.backoff_factor = backoff_factor\n\n        if not self.api_key or not self.access_token:\n            raise ValueError(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n\n        self.headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form encoding\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=30.0  # Set a default timeout\n        )\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous request to the Kite Connect API with retry logic.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Requesting {method} {url} with data: {data}\")\n        \n        for attempt in range(self.max_retries + 1):\n            try:\n                response = await self.client.request(method, endpoint, data=data)\n                response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx\n                \n                json_response = response.json()\n                logger.debug(f\"Response {response.status_code} from {url}: {json_response}\")\n\n                # Check for Kite specific error structure within a 200 OK response\n                if json_response.get(\"status\") == \"error\":\n                    error_type = json_response.get(\"error_type\", \"UnknownKiteError\")\n                    message = json_response.get(\"message\", \"Unknown Kite API error\")\n                    logger.error(f\"Kite API error ({error_type}): {message}\")\n                    # Map Kite error types to our custom exceptions if needed\n                    if error_type == \"InputException\":\n                         raise BadRequestError(message=message, status_code=response.status_code, error_type=error_type, data=json_response.get(\"data\"))\n                    elif error_type == \"TokenException\":\n                         raise AuthenticationError(message=message, status_code=response.status_code, error_type=error_type, data=json_response.get(\"data\"))\n                    # Add more mappings as needed\n                    else:\n                        raise KiteConnectError(message=message, status_code=response.status_code, error_type=error_type, data=json_response.get(\"data\"))\n                \n                return json_response.get(\"data\", {}) # Successful response data is usually nested\n\n            except httpx.HTTPStatusError as e:\n                status_code = e.response.status_code\n                try:\n                    error_data = e.response.json()\n                    message = error_data.get(\"message\", f\"HTTP error {status_code}\")\n                    error_type = error_data.get(\"error_type\", f\"HTTP{status_code}\")\n                except Exception:\n                    message = f\"HTTP error {status_code}: {e.response.text[:100]}\" # Truncate long non-JSON errors\n                    error_type = f\"HTTP{status_code}\"\n                \n                logger.error(f\"HTTP error {status_code} from {url}: {message} (Attempt {attempt + 1}/{self.max_retries + 1})\")\n\n                if status_code == 400:\n                    raise BadRequestError(message=message, status_code=status_code, error_type=error_type, data=error_data if 'error_data' in locals() else None) from e\n                elif status_code == 403:\n                    raise AuthenticationError(message=message, status_code=status_code, error_type=error_type, data=error_data if 'error_data' in locals() else None) from e\n                elif status_code == 429:\n                    # Rate limited, retry if possible\n                    if attempt < self.max_retries:\n                        wait_time = self.backoff_factor * (2 ** attempt)\n                        logger.warning(f\"Rate limit hit. Retrying in {wait_time:.2f} seconds...\")\n                        await asyncio.sleep(wait_time)\n                        continue # Retry the loop\n                    else:\n                        raise RateLimitError(message=\"Rate limit exceeded after multiple retries.\", status_code=status_code, error_type=\"RateLimitError\") from e\n                elif status_code >= 500:\n                    # Server error, retry if possible\n                    if attempt < self.max_retries:\n                        wait_time = self.backoff_factor * (2 ** attempt)\n                        logger.warning(f\"Server error ({status_code}). Retrying in {wait_time:.2f} seconds...\")\n                        await asyncio.sleep(wait_time)\n                        continue # Retry the loop\n                    else:\n                         raise ServerError(message=f\"Server error {status_code} after multiple retries.\", status_code=status_code, error_type=\"ServerError\") from e\n                else:\n                    # Other unexpected 4xx errors\n                    raise KiteConnectError(message=message, status_code=status_code, error_type=error_type, data=error_data if 'error_data' in locals() else None) from e\n\n            except httpx.TimeoutException as e:\n                logger.error(f\"Request timed out to {url}: {str(e)} (Attempt {attempt + 1}/{self.max_retries + 1})\")\n                if attempt < self.max_retries:\n                    wait_time = self.backoff_factor * (2 ** attempt)\n                    logger.warning(f\"Timeout occurred. Retrying in {wait_time:.2f} seconds...\")\n                    await asyncio.sleep(wait_time)\n                    continue # Retry the loop\n                else:\n                    raise NetworkError(message=\"Request timed out after multiple retries.\", error_type=\"TimeoutException\") from e\n            \n            except httpx.NetworkError as e:\n                logger.error(f\"Network error connecting to {url}: {str(e)} (Attempt {attempt + 1}/{self.max_retries + 1})\")\n                if attempt < self.max_retries:\n                    wait_time = self.backoff_factor * (2 ** attempt)\n                    logger.warning(f\"Network error occurred. Retrying in {wait_time:.2f} seconds...\")\n                    await asyncio.sleep(wait_time)\n                    continue # Retry the loop\n                else:\n                    raise NetworkError(message=f\"Network error after multiple retries: {str(e)}\", error_type=\"NetworkError\") from e\n\n            except Exception as e:\n                logger.exception(f\"An unexpected error occurred during request to {url}: {str(e)}\")\n                raise KiteConnectError(message=f\"An unexpected error occurred: {str(e)}\", error_type=\"UnexpectedException\") from e\n        \n        # Should not be reached if retries are exhausted, as exceptions are raised\n        raise KiteConnectError(\"Request failed after maximum retries.\")\n\n    async def place_order(self, variety: VarietyType, params: PlaceOrderParams) -> PlaceOrderResponse:\n        \"\"\"\n        Places an order of a specific variety.\n\n        Args:\n            variety: The order variety (e.g., 'regular', 'amo').\n            params: An instance of PlaceOrderParams containing order details.\n\n        Returns:\n            PlaceOrderResponse containing the order_id.\n\n        Raises:\n            KiteConnectError: For API specific errors.\n            AuthenticationError: For auth issues.\n            NetworkError: For connection or timeout problems.\n            BadRequestError: For invalid input parameters.\n            ServerError: For Kite server issues.\n            RateLimitError: If rate limits are exceeded.\n        \"\"\"\n        endpoint = f\"/orders/{variety}\"\n        \n        # Convert Pydantic model to dict, excluding None values and the 'variety' field itself\n        payload = params.dict(exclude_none=True, exclude={'variety'})\n        \n        # Ensure required fields based on logic are present (Pydantic model handles most)\n        # Convert float values to strings where necessary if API expects strings\n        for key, value in payload.items():\n            if isinstance(value, float):\n                payload[key] = str(value)\n            if isinstance(value, int):\n                 payload[key] = str(value) # Kite API expects numbers as strings in form data\n\n        logger.info(f\"Placing {variety} order with payload: {payload}\")\n        \n        try:\n            response_data = await self._request(\"POST\", endpoint, data=payload)\n            \n            if \"order_id\" not in response_data:\n                 logger.error(f\"'order_id' not found in response: {response_data}\")\n                 raise KiteConnectError(message=\"'order_id' not found in the response data.\", data=response_data, error_type=\"MalformedResponse\")\n\n            return PlaceOrderResponse(order_id=response_data[\"order_id\"])\n        except KiteConnectError as e:\n            logger.error(f\"Failed to place order: {e.message} (Type: {e.error_type}, Data: {e.data})\")\n            raise # Re-raise the specific error\n        except Exception as e:\n            logger.exception(f\"Unexpected error during place_order: {str(e)}\")\n            raise KiteConnectError(message=f\"An unexpected error occurred while placing the order: {str(e)}\") from e\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTP client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, Optional\nfrom pydantic import ValidationError\nimport logging\nimport asyncio\nimport os\nfrom dotenv import load_dotenv\n\n# Import models and client\nfrom models import PlaceOrderParams, PlaceOrderResponse, ErrorResponse, VarietyType, ExchangeType, TransactionType, OrderType, ProductType, ValidityType\nfrom client import KiteConnectClient, KiteConnectError\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"zerodha_kite_connect_orders\",\n    description=\"MCP Server for managing orders (placing, modifying, cancelling, retrieving) and trades using the Zerodha Kite Connect API v3.\"\n)\n\n# Initialize Kite Connect Client\n# Client initialization might raise ValueError if env vars are missing\ntry:\n    kite_client = KiteConnectClient()\nexcept ValueError as e:\n    logger.error(f\"Failed to initialize KiteConnectClient: {e}\")\n    # Optionally, exit or prevent server startup if client can't be initialized\n    # raise SystemExit(f\"Configuration error: {e}\")\n    kite_client = None # Set to None to handle gracefully in tool calls\n\n@mcp.tool()\nasync def place_order(\n    variety: VarietyType,\n    tradingsymbol: str,\n    exchange: ExchangeType,\n    transaction_type: TransactionType,\n    order_type: OrderType,\n    quantity: int,\n    product: ProductType,\n    price: Optional[float] = None,\n    trigger_price: Optional[float] = None,\n    disclosed_quantity: Optional[int] = None,\n    validity: ValidityType = \"DAY\",\n    validity_ttl: Optional[int] = None,\n    iceberg_legs: Optional[int] = None,\n    tag: Optional[str] = None\n) -> Dict[str, Any]:\n    \"\"\"Place an order of a specific variety (regular, amo, co, iceberg, auction).\n    \n    Args:\n        variety: Order variety (regular, amo, co, iceberg, auction).\n        tradingsymbol: Tradingsymbol of the instrument (e.g., 'INFY', 'NIFTY21JUNFUT').\n        exchange: Name of the exchange (NSE, BSE, NFO, CDS, BCD, MCX).\n        transaction_type: Transaction type (BUY or SELL).\n        order_type: Order type (MARKET, LIMIT, SL, SL-M).\n        quantity: Quantity to transact (must be positive).\n        product: Product type (CNC, NRML, MIS, MTF).\n        price: The price for LIMIT or SL orders. Required for LIMIT/SL.\n        trigger_price: The trigger price for SL, SL-M, or CO orders. Required for SL/SL-M.\n        disclosed_quantity: Quantity to disclose publicly (equity only, non-negative).\n        validity: Order validity (DAY, IOC, TTL). Defaults to DAY.\n        validity_ttl: Order life span in minutes. Required if validity is TTL.\n        iceberg_legs: Total number of legs for iceberg order (2-10). Required if variety is iceberg.\n        tag: An optional tag for the order (Max 20 chars).\n\n    Returns:\n        A dictionary containing the order_id on success, or an error dictionary on failure.\n    \"\"\"\n    if kite_client is None:\n        logger.error(\"Kite client is not initialized. Cannot place order.\")\n        return ErrorResponse(status=\"error\", message=\"Kite client not initialized due to configuration error.\", error_type=\"ConfigurationError\").dict()\n        \n    try:\n        # Validate parameters using Pydantic model\n        params = PlaceOrderParams(\n            variety=variety,\n            tradingsymbol=tradingsymbol,\n            exchange=exchange,\n            transaction_type=transaction_type,\n            order_type=order_type,\n            quantity=quantity,\n            product=product,\n            price=price,\n            trigger_price=trigger_price,\n            disclosed_quantity=disclosed_quantity,\n            validity=validity,\n            validity_ttl=validity_ttl,\n            iceberg_legs=iceberg_legs,\n            tag=tag\n        )\n\n        logger.info(f\"Received place_order request for {tradingsymbol}, quantity {quantity}\")\n        \n        # Call the client method\n        response: PlaceOrderResponse = await kite_client.place_order(variety=variety, params=params)\n        \n        logger.info(f\"Successfully placed order {response.order_id} for {tradingsymbol}\")\n        return response.dict()\n\n    except ValidationError as e:\n        logger.warning(f\"Input validation failed for place_order: {e.errors()}\")\n        # Return a structured error based on Pydantic validation details\n        return ErrorResponse(\n            status=\"error\", \n            message=f\"Input validation failed: {e.errors()}\", \n            error_type=\"ValidationError\"\n        ).dict()\n        \n    except KiteConnectError as e:\n        logger.error(f\"Kite API error during place_order: {e.message} (Type: {e.error_type})\")\n        return e.to_dict() # Use the error's built-in dict representation\n        \n    except Exception as e:\n        logger.exception(f\"Unexpected error in place_order tool: {str(e)}\")\n        return ErrorResponse(\n            status=\"error\", \n            message=f\"An unexpected server error occurred: {str(e)}\", \n            error_type=\"InternalServerError\"\n        ).dict()\n\n# Add a health check endpoint (optional but good practice)\n@mcp.get(\"/health\")\nasync def health_check():\n    \"\"\"Basic health check endpoint.\"\"\"\n    return {\"status\": \"ok\", \"service\": mcp.service_name}\n\n# Graceful shutdown\n@mcp.on_event(\"shutdown\")\nasync def shutdown_event():\n    if kite_client:\n        logger.info(\"Shutting down Kite client...\")\n        await kite_client.close()\n    logger.info(\"MCP server shutdown complete.\")\n\nif __name__ == \"__main__\":\n    # Run the MCP server using uvicorn\n    # Use 'uvicorn main:mcp.app --reload' for development\n    # Use 'uvicorn main:mcp.app --host 0.0.0.0 --port 8000' for production\n    import uvicorn\n    logger.info(f\"Starting MCP server '{mcp.service_name}'...\")\n    # Note: Uvicorn should be run from the command line, this is illustrative\n    # uvicorn.run(mcp.app, host=\"127.0.0.1\", port=8000)\n    print(\"MCP server defined. Run with: uvicorn main:mcp.app --reload\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=2.0.0,<3.0.0\nhttpx>=0.25.0,<0.28.0\npython-dotenv>=1.0.0,<2.0.0\nuvicorn[standard]>=0.20.0,<0.25.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Zerodha Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer Console: https://developers.kite.trade/\n\n# Your Kite application's API key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# The access token obtained after the login flow (this is typically short-lived)\n# You will need a mechanism to refresh or regenerate this token regularly.\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# The root URL for the Kite Connect API\n# Use https://api.kite.trade for the live environment\nKITE_ROOT_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Zerodha Kite Connect Orders MCP Server\n\nThis MCP (Model Context Protocol) server provides tools for managing orders (placing, modifying, cancelling, retrieving) using the Zerodha Kite Connect API v3.\n\nIt exposes Kite Connect order functionalities as callable tools for language models or other applications via the MCP standard.\n\n## Features\n\n*   Place various types of orders (regular, AMO, CO, Iceberg).\n*   Built using `FastMCP`.\n*   Asynchronous API client (`httpx`).\n*   Typed requests and responses using `Pydantic`.\n*   Handles API authentication, errors, timeouts, and basic retries.\n*   Configurable via environment variables.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <your-repo-url>\n    cd <your-repo-directory>\n    ```\n\n2.  **Create a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n## Configuration\n\nConfiguration is managed through environment variables. Create a `.env` file in the project root directory by copying the example file:\n\n```bash\ncp .env.example .env\n```\n\nNow, edit the `.env` file and add your Zerodha Kite Connect API credentials:\n\n*   `KITE_API_KEY`: Your application's API key obtained from the [Kite Developer Console](https://developers.kite.trade/).\n*   `KITE_ACCESS_TOKEN`: The access token generated after a successful Kite Connect login flow. **Note:** Access tokens are typically short-lived and need to be regenerated periodically. This server implementation assumes a valid access token is provided via the environment variable. You will need a separate process or mechanism to handle the Kite Connect login flow and update the `KITE_ACCESS_TOKEN`.\n*   `KITE_ROOT_URL`: The base URL for the Kite Connect API. Defaults to `https://api.kite.trade` (live environment).\n\n## Running the Server\n\nUse `uvicorn` to run the FastMCP application:\n\n```bash\n# For development with auto-reload\nuvicorn main:mcp.app --reload\n\n# For production\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000 \n```\n\nThe server will start, and you can interact with it using an MCP client at `http://127.0.0.1:8000` (or the host/port you specified).\n\n## Available Tools\n\nThe following tools are exposed by this MCP server:\n\n### `place_order`\n\n*   **Description:** Place an order of a specific variety (regular, amo, co, iceberg, auction).\n*   **Parameters:**\n    *   `variety` (string, required): Order variety (`regular`, `amo`, `co`, `iceberg`, `auction`).\n    *   `tradingsymbol` (string, required): Tradingsymbol of the instrument (e.g., `INFY`, `NIFTY21JUNFUT`).\n    *   `exchange` (string, required): Name of the exchange (`NSE`, `BSE`, `NFO`, `CDS`, `BCD`, `MCX`).\n    *   `transaction_type` (string, required): Transaction type (`BUY` or `SELL`).\n    *   `order_type` (string, required): Order type (`MARKET`, `LIMIT`, `SL`, `SL-M`).\n    *   `quantity` (integer, required): Quantity to transact (must be positive).\n    *   `product` (string, required): Product type (`CNC`, `NRML`, `MIS`, `MTF`).\n    *   `price` (float, optional): The price for `LIMIT` or `SL` orders. Required for `LIMIT`/`SL`.\n    *   `trigger_price` (float, optional): The trigger price for `SL`, `SL-M`, or `CO` orders. Required for `SL`/`SL-M`.\n    *   `disclosed_quantity` (integer, optional): Quantity to disclose publicly (equity only, non-negative).\n    *   `validity` (string, optional): Order validity (`DAY`, `IOC`, `TTL`). Defaults to `DAY`.\n    *   `validity_ttl` (integer, optional): Order life span in minutes. Required if `validity` is `TTL`.\n    *   `iceberg_legs` (integer, optional): Total number of legs for iceberg order (2-10). Required if `variety` is `iceberg`.\n    *   `tag` (string, optional): An optional tag for the order (Max 20 chars).\n*   **Returns:** A dictionary containing `{\"order_id\": \"...\"}` on success, or an error dictionary (e.g., `{\"status\": \"error\", \"message\": \"...\", \"error_type\": \"...\"}`) on failure.\n\n## Error Handling\n\nThe server catches common errors:\n*   **Validation Errors:** If input parameters don't match the required format or constraints.\n*   **Authentication Errors:** If the `KITE_API_KEY` or `KITE_ACCESS_TOKEN` is invalid or expired (HTTP 403).\n*   **Bad Request Errors:** If the Kite API rejects the request due to invalid parameters (HTTP 400).\n*   **Rate Limit Errors:** If the application exceeds Kite API rate limits (HTTP 429). Basic retry logic is implemented.\n*   **Network Errors:** Timeouts or connection issues when communicating with the Kite API.\n*   **Server Errors:** If the Kite API experiences internal issues (HTTP 5xx). Basic retry logic is implemented.\n*   **Internal Server Errors:** Unexpected errors within the MCP server itself.\n\nError responses are returned as JSON objects with `status`, `message`, and `error_type` fields.\n"
    }
  ]
}
{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, Optional, List\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom models import (\n    PlaceOrderParams,\n    ModifyOrderParams,\n    CancelOrderParams,\n    GetOrderHistoryParams,\n    OrderResponse,\n    OrderDetails,\n    OrderHistoryItem,\n    ErrorResponse\n)\nfrom client import KiteConnectClient, KiteApiException\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectOrders\",\n    description=\"MCP service for managing trading orders using the Kite Connect API v3. Allows placing, modifying, cancelling, and retrieving orders and trades.\"\n)\n\n# Initialize Kite Connect Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables or .env file.\")\n    # Optionally raise an error or exit if credentials are critical for startup\n    # raise ValueError(\"Kite API credentials not found.\")\n    kite_client = None # Client will be unusable, tools will fail\nelse:\n    try:\n        kite_client = KiteConnectClient(api_key=api_key, access_token=access_token, base_url=base_url)\n        logger.info(\"KiteConnectClient initialized successfully.\")\n    except Exception as e:\n        logger.exception(f\"Failed to initialize KiteConnectClient: {e}\")\n        kite_client = None\n\n# --- MCP Tools ---\n\n@mcp.tool()\ndef place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\"\"\"\n    if not kite_client:\n        return ErrorResponse(error=\"Kite client not initialized. Check credentials.\").dict()\n    try:\n        logger.info(f\"Placing order with params: {params.dict(exclude_none=True)}\")\n        result = kite_client.place_order(params)\n        logger.info(f\"Order placed successfully: {result}\")\n        # Assuming result is already Dict[str, str] like {'order_id': '...'}\n        return result\n    except KiteApiException as e:\n        logger.error(f\"Kite API error placing order: {e}\")\n        return ErrorResponse(error=str(e), error_type=e.error_type, status_code=e.status_code).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error placing order: {e}\")\n        return ErrorResponse(error=f\"An unexpected error occurred: {e}\").dict()\n\n@mcp.tool()\ndef modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modify attributes of a pending regular or cover order.\"\"\"\n    if not kite_client:\n        return ErrorResponse(error=\"Kite client not initialized. Check credentials.\").dict()\n    try:\n        logger.info(f\"Modifying order {params.order_id} with params: {params.dict(exclude={'order_id', 'variety'}, exclude_none=True)}\")\n        result = kite_client.modify_order(params)\n        logger.info(f\"Order modified successfully: {result}\")\n        # Assuming result is already Dict[str, str] like {'order_id': '...'}\n        return result\n    except KiteApiException as e:\n        logger.error(f\"Kite API error modifying order: {e}\")\n        return ErrorResponse(error=str(e), error_type=e.error_type, status_code=e.status_code).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error modifying order: {e}\")\n        return ErrorResponse(error=f\"An unexpected error occurred: {e}\").dict()\n\n@mcp.tool()\ndef cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"Cancel a pending order.\"\"\"\n    if not kite_client:\n        return ErrorResponse(error=\"Kite client not initialized. Check credentials.\").dict()\n    try:\n        logger.info(f\"Cancelling order {params.order_id} (variety: {params.variety}) with params: {params.dict(exclude={'order_id', 'variety'}, exclude_none=True)}\")\n        result = kite_client.cancel_order(params)\n        logger.info(f\"Order cancelled successfully: {result}\")\n        # Assuming result is already Dict[str, str] like {'order_id': '...'}\n        return result\n    except KiteApiException as e:\n        logger.error(f\"Kite API error cancelling order: {e}\")\n        return ErrorResponse(error=str(e), error_type=e.error_type, status_code=e.status_code).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error cancelling order: {e}\")\n        return ErrorResponse(error=f\"An unexpected error occurred: {e}\").dict()\n\n@mcp.tool()\ndef get_orders() -> Dict[str, Any]:\n    \"\"\"Retrieve the list of all orders (open, pending, executed) for the current trading day.\"\"\"\n    if not kite_client:\n        return ErrorResponse(error=\"Kite client not initialized. Check credentials.\").dict()\n    try:\n        logger.info(\"Retrieving all orders for the day.\")\n        orders = kite_client.get_orders()\n        logger.info(f\"Retrieved {len(orders)} orders.\")\n        # Wrap the list in a dictionary for standard MCP response format\n        return {\"orders\": orders}\n    except KiteApiException as e:\n        logger.error(f\"Kite API error retrieving orders: {e}\")\n        return ErrorResponse(error=str(e), error_type=e.error_type, status_code=e.status_code).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error retrieving orders: {e}\")\n        return ErrorResponse(error=f\"An unexpected error occurred: {e}\").dict()\n\n@mcp.tool()\ndef get_order_history(params: GetOrderHistoryParams) -> Dict[str, Any]:\n    \"\"\"Retrieve the history (various stages) of a given order.\"\"\"\n    if not kite_client:\n        return ErrorResponse(error=\"Kite client not initialized. Check credentials.\").dict()\n    try:\n        logger.info(f\"Retrieving history for order ID: {params.order_id}\")\n        history = kite_client.get_order_history(params.order_id)\n        logger.info(f\"Retrieved {len(history)} history items for order {params.order_id}.\")\n        # Wrap the list in a dictionary for standard MCP response format\n        return {\"history\": history}\n    except KiteApiException as e:\n        logger.error(f\"Kite API error retrieving order history: {e}\")\n        return ErrorResponse(error=str(e), error_type=e.error_type, status_code=e.status_code).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error retrieving order history: {e}\")\n        return ErrorResponse(error=f\"An unexpected error occurred: {e}\").dict()\n\n\nif __name__ == \"__main__\":\n    # Example of how to run (requires uvicorn)\n    # You would typically run this using: uvicorn main:mcp.app --reload\n    logger.info(\"Starting KiteConnectOrders MCP server.\")\n    # mcp.run() # This might be blocking depending on FastMCP implementation\n    # Instead, use uvicorn command line:\n    print(\"Run the server using: uvicorn main:mcp.app --host 0.0.0.0 --port 8000\")\n    # For development: uvicorn main:mcp.app --reload\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field\nfrom typing import Optional, List, Dict, Any\nfrom enum import Enum\n\n# --- Enums for specific fields (optional but recommended for validation) ---\n\nclass VarietyEnum(str, Enum):\n    regular = \"regular\"\n    amo = \"amo\"\n    co = \"co\"\n    iceberg = \"iceberg\"\n    auction = \"auction\"\n\nclass TransactionTypeEnum(str, Enum):\n    buy = \"BUY\"\n    sell = \"SELL\"\n\nclass OrderTypeEnum(str, Enum):\n    market = \"MARKET\"\n    limit = \"LIMIT\"\n    sl = \"SL\"\n    slm = \"SL-M\"\n\nclass ProductEnum(str, Enum):\n    cnc = \"CNC\"\n    nrml = \"NRML\"\n    mis = \"MIS\"\n    mtf = \"MTF\"\n\nclass ValidityEnum(str, Enum):\n    day = \"DAY\"\n    ioc = \"IOC\"\n    ttl = \"TTL\"\n\n# --- Input Parameter Models ---\n\nclass PlaceOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument\")\n    exchange: str = Field(..., description=\"Name of the exchange (e.g., NSE, BSE, NFO, MCX)\")\n    transaction_type: TransactionTypeEnum = Field(..., description=\"BUY or SELL\")\n    order_type: OrderTypeEnum = Field(..., description=\"Order type (MARKET, LIMIT, SL, SL-M)\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact\")\n    product: ProductEnum = Field(..., description=\"Product code (CNC, NRML, MIS, MTF)\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity)\")\n    validity: Optional[ValidityEnum] = Field(ValidityEnum.day, description=\"Order validity (DAY, IOC, TTL). Default is DAY.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders\")\n    iceberg_legs: Optional[int] = Field(None, ge=2, le=10, description=\"Total number of legs for iceberg order (2-10)\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order\")\n    auction_number: Optional[str] = Field(None, description=\"Unique identifier for a particular auction\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"Optional tag for the order (alphanumeric, max 20 chars)\")\n\n    # TODO: Add custom validation logic if needed (e.g., price required for LIMIT)\n\nclass ModifyOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety (regular, co)\")\n    order_id: str = Field(..., description=\"ID of the order to modify\")\n    parent_order_id: Optional[str] = Field(None, description=\"Parent order ID if modifying a second leg CO order\")\n    order_type: Optional[OrderTypeEnum] = Field(None, description=\"New order type (only for regular orders)\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity (only for regular orders)\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders)\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, CO orders)\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (only for regular equity orders)\")\n    validity: Optional[ValidityEnum] = Field(None, description=\"New validity (only for regular orders, DAY or IOC)\")\n\nclass CancelOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety (regular, amo, co, iceberg, auction)\")\n    order_id: str = Field(..., description=\"ID of the order to cancel\")\n    parent_order_id: Optional[str] = Field(None, description=\"Parent order ID if cancelling a second leg CO order\")\n\nclass GetOrderHistoryParams(BaseModel):\n    order_id: str = Field(..., description=\"ID of the order to retrieve history for\")\n\n# --- Response Models (Placeholders - Define based on actual Kite API response structure) ---\n\nclass OrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID\")\n\nclass OrderDetails(BaseModel):\n    # Example fields - adjust based on Kite API v3 documentation\n    order_id: Optional[str] = None\n    parent_order_id: Optional[str] = None\n    exchange_order_id: Optional[str] = None\n    status: Optional[str] = None\n    status_message: Optional[str] = None\n    status_message_raw: Optional[str] = None\n    order_timestamp: Optional[str] = None # Consider datetime type\n    exchange_timestamp: Optional[str] = None # Consider datetime type\n    variety: Optional[str] = None\n    exchange: Optional[str] = None\n    tradingsymbol: Optional[str] = None\n    instrument_token: Optional[int] = None\n    order_type: Optional[str] = None\n    transaction_type: Optional[str] = None\n    validity: Optional[str] = None\n    product: Optional[str] = None\n    quantity: Optional[int] = None\n    disclosed_quantity: Optional[int] = None\n    price: Optional[float] = None\n    trigger_price: Optional[float] = None\n    average_price: Optional[float] = None\n    filled_quantity: Optional[int] = None\n    pending_quantity: Optional[int] = None\n    cancelled_quantity: Optional[int] = None\n    tag: Optional[str] = None\n    meta: Optional[Dict[str, Any]] = None\n\nclass OrderHistoryItem(BaseModel):\n    # Example fields - adjust based on Kite API v3 documentation for order history\n    order_id: Optional[str] = None\n    status: Optional[str] = None\n    status_message: Optional[str] = None\n    order_timestamp: Optional[str] = None # Consider datetime type\n    # Add other relevant fields from the history/update structure\n    # Example: quantity, price, trigger_price changes if applicable\n\n# --- Error Response Model ---\n\nclass ErrorResponse(BaseModel):\n    error: str\n    error_type: Optional[str] = None\n    status_code: Optional[int] = None\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nfrom typing import Dict, Any, Optional, List, Union\n\nfrom models import (\n    PlaceOrderParams,\n    ModifyOrderParams,\n    CancelOrderParams,\n    OrderDetails,\n    OrderHistoryItem\n)\n\nlogger = logging.getLogger(__name__)\n\n# Custom Exception for Kite API specific errors\nclass KiteApiException(Exception):\n    def __init__(self, message, status_code=None, error_type=None):\n        super().__init__(message)\n        self.status_code = status_code\n        self.error_type = error_type\n        self.message = message\n\n    def __str__(self):\n        return f\"Kite API Error (Status: {self.status_code}, Type: {self.error_type}): {self.message}\"\n\nclass KiteConnectClient:\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.timeout = timeout\n        self._headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form data for POST/PUT\n        }\n        self._client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self._headers,\n            timeout=self.timeout,\n            event_hooks={'request': [self._log_request], 'response': [self._log_response]}\n        )\n\n    async def _log_request(self, request):\n        # Redact Authorization header before logging\n        headers = dict(request.headers)\n        if \"Authorization\" in headers:\n            headers[\"Authorization\"] = \"[REDACTED]\"\n        logger.debug(f\"Request: {request.method} {request.url} - Headers: {headers}\")\n        if request.content:\n             # Be careful logging potentially sensitive form data\n             # Consider logging only keys or omitting content logging in production\n             try:\n                 content = await request.aread()\n                 logger.debug(f\"Request Body: {content.decode()}\")\n             except Exception:\n                 logger.debug(\"Could not read or decode request body for logging.\")\n\n\n    async def _log_response(self, response):\n        await response.aread() # Ensure response body is available\n        logger.debug(f\"Response: {response.status_code} {response.request.method} {response.request.url} - Body: {response.text}\")\n\n    async def _request(self, method: str, endpoint: str, params: Optional[Dict] = None, data: Optional[Dict] = None) -> Any:\n        \"\"\"Makes an asynchronous HTTP request to the Kite API.\"\"\"\n        try:\n            response = await self._client.request(\n                method=method,\n                url=endpoint,\n                params=params, # For query parameters (GET, DELETE)\n                data=data      # For form data (POST, PUT)\n            )\n\n            # Check for HTTP errors (4xx, 5xx)\n            response.raise_for_status()\n\n            # Parse JSON response\n            json_response = response.json()\n\n            # Check for Kite specific errors within the JSON response\n            if json_response.get(\"status\") == \"error\":\n                error_type = json_response.get(\"error_type\", \"UnknownError\")\n                message = json_response.get(\"message\", \"Unknown Kite API error\")\n                logger.error(f\"Kite API returned error: Type={error_type}, Message={message}\")\n                raise KiteApiException(message, status_code=response.status_code, error_type=error_type)\n\n            # Return the 'data' part of the response if present, else the whole response\n            return json_response.get(\"data\", json_response)\n\n        except httpx.HTTPStatusError as e:\n            # Attempt to parse error details from Kite's response body\n            error_type = \"HTTPError\"\n            message = f\"HTTP error occurred: {e.response.status_code} {e.response.reason_phrase}\"\n            try:\n                error_data = e.response.json()\n                error_type = error_data.get(\"error_type\", error_type)\n                message = error_data.get(\"message\", message)\n            except Exception:\n                # If response is not JSON or parsing fails, use the raw text\n                message = f\"{message} - Response: {e.response.text[:500]}...\"\ # Limit log size\n\n            logger.error(f\"HTTP error during Kite API request to {e.request.url}: {message}\", exc_info=True)\n            raise KiteApiException(message, status_code=e.response.status_code, error_type=error_type) from e\n\n        except httpx.RequestError as e:\n            logger.error(f\"Network or request error during Kite API request to {e.request.url}: {e}\", exc_info=True)\n            raise KiteApiException(f\"Network error: {e}\", error_type=\"NetworkException\") from e\n\n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during Kite API request: {e}\")\n            raise KiteApiException(f\"An unexpected error occurred: {e}\", error_type=\"GeneralException\") from e\n\n    def _prepare_payload(self, params: BaseModel) -> Dict[str, Any]:\n        \"\"\"Converts Pydantic model to dict, removing None values.\"\"\"\n        return params.dict(exclude_none=True)\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, str]:\n        \"\"\"Place an order.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}\"\n        data = self._prepare_payload(params)\n        # Remove 'variety' as it's in the path\n        data.pop('variety', None)\n        # Convert enums back to strings if necessary (httpx might handle it)\n        for key, value in data.items():\n            if isinstance(value, Enum):\n                 data[key] = value.value\n\n        logger.info(f\"Placing order via API: {endpoint} with data: {data}\")\n        response_data = await self._request(\"POST\", endpoint, data=data)\n        if isinstance(response_data, dict) and 'order_id' in response_data:\n             return {\"order_id\": str(response_data['order_id'])} # Ensure string type\n        else:\n             logger.error(f\"Unexpected response format for place_order: {response_data}\")\n             raise KiteApiException(\"Unexpected response format after placing order.\", error_type=\"DataException\")\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, str]:\n        \"\"\"Modify a pending order.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}/{params.order_id}\"\n        data = self._prepare_payload(params)\n        # Remove path parameters from data payload\n        data.pop('variety', None)\n        data.pop('order_id', None)\n        # Convert enums back to strings if necessary\n        for key, value in data.items():\n            if isinstance(value, Enum):\n                 data[key] = value.value\n\n        logger.info(f\"Modifying order via API: {endpoint} with data: {data}\")\n        response_data = await self._request(\"PUT\", endpoint, data=data)\n        if isinstance(response_data, dict) and 'order_id' in response_data:\n             return {\"order_id\": str(response_data['order_id'])} # Ensure string type\n        else:\n             logger.error(f\"Unexpected response format for modify_order: {response_data}\")\n             raise KiteApiException(\"Unexpected response format after modifying order.\", error_type=\"DataException\")\n\n    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, str]:\n        \"\"\"Cancel a pending order.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}/{params.order_id}\"\n        query_params = {}\n        if params.parent_order_id:\n            query_params['parent_order_id'] = params.parent_order_id\n\n        logger.info(f\"Cancelling order via API: {endpoint} with params: {query_params}\")\n        response_data = await self._request(\"DELETE\", endpoint, params=query_params)\n        if isinstance(response_data, dict) and 'order_id' in response_data:\n             return {\"order_id\": str(response_data['order_id'])} # Ensure string type\n        else:\n             logger.error(f\"Unexpected response format for cancel_order: {response_data}\")\n             raise KiteApiException(\"Unexpected response format after cancelling order.\", error_type=\"DataException\")\n\n    async def get_orders(self) -> List[Dict[str, Any]]: # Return raw dicts for flexibility\n        \"\"\"Retrieve the list of orders for the day.\"\"\"\n        endpoint = \"/orders\"\n        logger.info(f\"Getting orders via API: {endpoint}\")\n        response_data = await self._request(\"GET\", endpoint)\n        if isinstance(response_data, list):\n            # TODO: Optionally parse each item into OrderDetails model if strict typing is needed\n            return response_data\n        else:\n            logger.error(f\"Unexpected response format for get_orders: {response_data}\")\n            raise KiteApiException(\"Expected a list of orders, but received different format.\", error_type=\"DataException\")\n\n    async def get_order_history(self, order_id: str) -> List[Dict[str, Any]]: # Return raw dicts\n        \"\"\"Retrieve the history of a given order.\"\"\"\n        endpoint = f\"/orders/{order_id}\"\n        logger.info(f\"Getting order history via API: {endpoint}\")\n        response_data = await self._request(\"GET\", endpoint)\n        if isinstance(response_data, list):\n             # TODO: Optionally parse each item into OrderHistoryItem model\n             return response_data\n        # Handle case where a single order detail dict might be returned instead of history list?\n        # Based on plan, expecting List[OrderHistoryItem]\n        elif isinstance(response_data, dict) and 'order_id' in response_data:\n             logger.warning(f\"Received single order detail instead of history list for {order_id}. Returning as list.\")\n             return [response_data] # Wrap single dict in a list if API behaves differently\n        else:\n             logger.error(f\"Unexpected response format for get_order_history: {response_data}\")\n             raise KiteApiException(\"Expected a list of order history items.\", error_type=\"DataException\")\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self._client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0 # Use appropriate version\npydantic>=1.9.0,<2.0.0 # Or >=2.0.0 if FastMCP supports it\nhttpx>=0.23.0\npython-dotenv>=0.20.0\nuvicorn>=0.17.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer account (https://developers.kite.trade/)\n\n# Your Kite API Key\nKITE_API_KEY=\n\n# The access token obtained after a successful login flow (valid for one day)\n# You need a mechanism to generate/refresh this token daily.\nKITE_ACCESS_TOKEN=\n\n# Base URL for the Kite Connect API (usually doesn't need changing)\n# KITE_BASE_URL=https://api.kite.trade\n"
    },
    {
      "name": "README.md",
      "content": "# KiteConnectOrders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect API v3, specifically focusing on order management operations.\n\nIt allows language models or other applications to place, modify, cancel, and retrieve trading orders via a standardized MCP interface, leveraging the FastMCP framework.\n\n## Features\n\n*   Place new orders (regular, AMO, CO, Iceberg, Auction).\n*   Modify existing pending orders.\n*   Cancel pending orders.\n*   Retrieve a list of all orders for the current trading day.\n*   Retrieve the history/updates for a specific order.\n*   Built with FastMCP for easy integration.\n*   Asynchronous API client using `httpx`.\n*   Typed requests and responses using Pydantic.\n*   Environment variable-based configuration for API keys.\n*   Basic error handling for API and network issues.\n\n## Prerequisites\n\n*   Python 3.8+\n*   Zerodha Kite Developer Account and API Key.\n*   A valid `access_token` (obtained via the Kite Connect login flow - this token is typically valid for one trading day).\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    Copy the example environment file:\n    ```bash\n    cp .env.example .env\n    ```\n    Edit the `.env` file and add your Kite API Key and a valid Access Token:\n    ```\n    KITE_API_KEY=your_api_key\n    KITE_ACCESS_TOKEN=your_valid_access_token\n    # KITE_BASE_URL=https://api.kite.trade # Optional: Uncomment to override default\n    ```\n    **Important:** The `KITE_ACCESS_TOKEN` needs to be generated daily through the Kite Connect login flow. This MCP server does *not* handle the login flow itself; it assumes a valid token is provided.\n\n## Running the Server\n\nUse Uvicorn to run the FastMCP application:\n\n```bash\n# For development with auto-reload\nuvicorn main:mcp.app --reload --host 0.0.0.0 --port 8000\n\n# For production\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000\n```\n\nThe server will be available at `http://localhost:8000` (or the specified host/port).\n\n## Available Tools\n\nThe following tools are exposed via the MCP server:\n\n1.  **`place_order`**\n    *   Description: Place an order of a particular variety.\n    *   Input: `PlaceOrderParams` model (see `models.py` for fields like `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, etc.)\n    *   Returns: `Dict[str, str]` containing `order_id` on success, or `ErrorResponse` on failure.\n\n2.  **`modify_order`**\n    *   Description: Modify attributes of a pending regular or cover order.\n    *   Input: `ModifyOrderParams` model (see `models.py` for fields like `variety`, `order_id`, `quantity`, `price`, `trigger_price`, etc.)\n    *   Returns: `Dict[str, str]` containing `order_id` on success, or `ErrorResponse` on failure.\n\n3.  **`cancel_order`**\n    *   Description: Cancel a pending order.\n    *   Input: `CancelOrderParams` model (see `models.py` for fields like `variety`, `order_id`, `parent_order_id`)\n    *   Returns: `Dict[str, str]` containing `order_id` on success, or `ErrorResponse` on failure.\n\n4.  **`get_orders`**\n    *   Description: Retrieve the list of all orders for the current trading day.\n    *   Input: None\n    *   Returns: `Dict[str, List[OrderDetails]]` containing a list of orders under the `orders` key, or `ErrorResponse` on failure.\n\n5.  **`get_order_history`**\n    *   Description: Retrieve the history (various stages/updates) of a given order.\n    *   Input: `GetOrderHistoryParams` model (see `models.py` for `order_id` field)\n    *   Returns: `Dict[str, List[OrderHistoryItem]]` containing a list of history items under the `history` key, or `ErrorResponse` on failure.\n\nRefer to `models.py` for detailed definitions of the input parameter models and the structure of response models (`OrderDetails`, `OrderHistoryItem`). Note that response models are based on typical structures and might need adjustments based on the exact Kite API v3 responses.\n\n## Error Handling\n\nThe API client (`client.py`) attempts to catch common errors:\n*   `httpx.HTTPStatusError`: For 4xx/5xx responses from the Kite API.\n*   `httpx.RequestError`: For network issues (DNS resolution, connection errors).\n*   Kite API specific errors: If the response JSON indicates an error (`status: 'error'`).\n\nThese are wrapped in a custom `KiteApiException` which includes the status code and error type where available. The MCP tools in `main.py` catch these exceptions and return a standardized `ErrorResponse` dictionary.\n\n## Rate Limiting\n\nThe Kite Connect API has rate limits (typically around 3 requests per second per API key for order operations). This client does *not* implement client-side rate limiting. If you exceed the limits, the API will return a 429 error, which will be caught and raised as a `KiteApiException`.\n\n## Disclaimer\n\nTrading involves risks. This software is provided \"as is\" without warranty of any kind. Ensure you understand the Kite Connect API documentation and the risks associated with automated trading before using this tool.\n"
    }
  ]
}
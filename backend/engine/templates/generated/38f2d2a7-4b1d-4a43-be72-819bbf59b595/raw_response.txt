{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, Optional, List, Union\nfrom pydantic import BaseModel, Field\nimport httpx\nimport logging\nimport asyncio\nimport os\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# --- Pydantic Models ---\n\nclass DeepsearchQueryParams(BaseModel):\n    \"\"\"Parameters for the Deepsearch API call.\"\"\"\n    query: str = Field(..., description=\"The search query to send to the Deepsearch API.\")\n    model: str = Field(\"deepsearch-default\", description=\"The specific model to use for the search and generation.\")\n    max_results: int = Field(10, gt=0, le=50, description=\"Maximum number of search results to consider or return.\")\n    # Add other potential parameters if the Deepsearch API supports them\n    # e.g., search_depth: Optional[str] = Field(None, description=\"Depth of search (e.g., 'basic', 'advanced')\")\n\nclass Source(BaseModel):\n    \"\"\"Represents a single source document used for the answer.\"\"\"\n    title: Optional[str] = Field(None, description=\"Title of the source document.\")\n    url: Optional[str] = Field(None, description=\"URL of the source document.\")\n    snippet: Optional[str] = Field(None, description=\"Relevant snippet from the source document.\")\n\nclass DeepsearchUsage(BaseModel):\n    \"\"\"Token usage information from the Deepsearch API.\"\"\"\n    prompt_tokens: Optional[int] = Field(None, description=\"Tokens used in the prompt.\")\n    completion_tokens: Optional[int] = Field(None, description=\"Tokens generated in the completion.\")\n    total_tokens: Optional[int] = Field(None, description=\"Total tokens used.\")\n\nclass DeepsearchResult(BaseModel):\n    \"\"\"Structured result from the Deepsearch API.\"\"\"\n    answer: str = Field(..., description=\"The generated answer based on the search results.\")\n    sources: List[Source] = Field([], description=\"List of sources used to generate the answer.\")\n    usage: Optional[DeepsearchUsage] = Field(None, description=\"Token usage information for the API call.\")\n    # Add other potential fields like query_id, latency, etc.\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response.\"\"\"\n    error: str = Field(..., description=\"Description of the error that occurred.\")\n    details: Optional[str] = Field(None, description=\"Additional details about the error.\")\n\n# --- API Client ---\n\nclass DeepsearchAPIClient:\n    \"\"\"Client to interact with the hypothetical Deepsearch API.\"\"\"\n\n    DEFAULT_TIMEOUT = 60.0  # seconds\n\n    def __init__(self):\n        \"\"\"Initializes the Deepsearch API client.\"\"\"\n        self.api_key = os.getenv(\"DEEPSEARCH_API_KEY\")\n        self.base_url = os.getenv(\"DEEPSEARCH_API_BASE_URL\")\n\n        if not self.api_key:\n            logger.error(\"DEEPSEARCH_API_KEY environment variable not set.\")\n            raise ValueError(\"DEEPSEARCH_API_KEY must be set\")\n        if not self.base_url:\n            logger.error(\"DEEPSEARCH_API_BASE_URL environment variable not set.\")\n            raise ValueError(\"DEEPSEARCH_API_BASE_URL must be set\")\n\n        self.headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {self.api_key}\"\n        }\n        # Use a context manager for the client in the actual request method\n        # to ensure proper resource cleanup.\n\n    async def _request(self, method: str, endpoint: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Deepsearch API.\"\"\"\n        url = f\"{self.base_url.rstrip('/')}/{endpoint.lstrip('/')}\"\n        async with httpx.AsyncClient(headers=self.headers, timeout=self.DEFAULT_TIMEOUT) as client:\n            try:\n                logger.debug(f\"Sending {method} request to {url} with payload: {kwargs.get('json')}\")\n                response = await client.request(method, url, **kwargs)\n                response.raise_for_status()  # Raise HTTPStatusError for 4xx/5xx responses\n                logger.debug(f\"Received successful response ({response.status_code}) from {url}\")\n                return response.json()\n            except httpx.TimeoutException as e:\n                logger.error(f\"Request timed out after {self.DEFAULT_TIMEOUT}s: {url} - {e}\")\n                raise TimeoutError(f\"Request to Deepsearch API timed out: {e}\") from e\n            except httpx.HTTPStatusError as e:\n                logger.error(f\"HTTP error occurred: {e.response.status_code} - {e.response.text} for url: {e.request.url}\")\n                # Attempt to parse error details from response\n                try:\n                    error_details = e.response.json()\n                except Exception:\n                    error_details = e.response.text\n                raise ConnectionError(f\"Deepsearch API request failed with status {e.response.status_code}: {error_details}\") from e\n            except httpx.RequestError as e:\n                logger.error(f\"An error occurred while requesting {e.request.url!r}: {e}\")\n                raise ConnectionError(f\"Error connecting to Deepsearch API: {e}\") from e\n            except Exception as e:\n                logger.error(f\"An unexpected error occurred during the API request: {e}\")\n                raise\n\n    async def search(self, params: DeepsearchQueryParams) -> Dict[str, Any]:\n        \"\"\"\n        Executes a search query using the Deepsearch API.\n\n        Args:\n            params: The parameters for the search query.\n\n        Returns:\n            The raw dictionary response from the Deepsearch API.\n\n        Raises:\n            ValueError: If required parameters are missing.\n            TimeoutError: If the request times out.\n            ConnectionError: If there's an issue connecting to the API or an HTTP error.\n            Exception: For other unexpected errors.\n        \"\"\"\n        if not params.query:\n            raise ValueError(\"Query parameter cannot be empty.\")\n\n        # Construct the payload based on a hypothetical Deepsearch API structure\n        # This might need adjustment based on the actual API specification.\n        payload = {\n            \"model\": params.model,\n            \"query\": params.query,\n            \"max_results\": params.max_results,\n            # Add other parameters from DeepsearchQueryParams if needed\n            # \"search_depth\": params.search_depth,\n        }\n\n        # Assuming the endpoint is something like '/v1/search' or '/search'\n        # This should be verified with the actual Deepsearch API documentation.\n        endpoint = \"/v1/search\"\n\n        logger.info(f\"Initiating Deepsearch for query: '{params.query[:50]}...' with model: {params.model}\")\n        response_data = await self._request(\"POST\", endpoint, json=payload)\n        logger.info(f\"Successfully received Deepsearch response for query: '{params.query[:50]}...'\" )\n        return response_data\n\n# --- MCP Server ---\n\nmcp = FastMCP(\n    name=\"deepsearch-mcp\",\n    description=\"MCP server for interacting with a Deepsearch API.\",\n    version=\"1.0.0\"\n)\n\n# Instantiate the API client (ensure environment variables are set)\ntry:\n    api_client = DeepsearchAPIClient()\nexcept ValueError as e:\n    logger.critical(f\"Failed to initialize DeepsearchAPIClient: {e}. Ensure .env file is present and variables are set.\")\n    # Exit or prevent server start if client can't be initialized?\n    # For now, we'll let it proceed, but tools will fail.\n    api_client = None\n\n@mcp.tool()\nasync def deep_search(query: str) -> Union[DeepsearchResult, ErrorResponse]:\n    \"\"\"\n    Performs a search using the Deepsearch API with default settings.\n\n    Args:\n        query: The search query.\n\n    Returns:\n        A DeepsearchResult object containing the answer and sources, or an ErrorResponse on failure.\n    \"\"\"\n    if not api_client:\n        return ErrorResponse(error=\"API Client not initialized. Check server logs.\")\n\n    try:\n        params = DeepsearchQueryParams(query=query)\n        result_dict = await api_client.search(params)\n\n        # Validate and parse the response using Pydantic models\n        # Assuming the API returns keys like 'answer', 'sources', 'usage'\n        parsed_result = DeepsearchResult(\n            answer=result_dict.get(\"answer\", \"No answer provided.\"),\n            sources=[Source(**source) for source in result_dict.get(\"sources\", [])],\n            usage=DeepsearchUsage(**result_dict[\"usage\"]) if \"usage\" in result_dict else None\n        )\n        return parsed_result\n    except (ValueError, TimeoutError, ConnectionError) as e:\n        logger.error(f\"Error in deep_search for query '{query[:50]}...': {e}\")\n        return ErrorResponse(error=f\"API Request Failed: {type(e).__name__}\", details=str(e))\n    except Exception as e:\n        logger.exception(f\"Unexpected error in deep_search for query '{query[:50]}...': {e}\", exc_info=True)\n        return ErrorResponse(error=\"Internal Server Error\", details=str(e))\n\n@mcp.tool()\nasync def deep_search_custom(params: DeepsearchQueryParams) -> Union[DeepsearchResult, ErrorResponse]:\n    \"\"\"\n    Performs a search using the Deepsearch API with custom parameters.\n\n    Args:\n        params: A DeepsearchQueryParams object containing the query and custom settings\n                (e.g., model, max_results).\n\n    Returns:\n        A DeepsearchResult object containing the answer and sources, or an ErrorResponse on failure.\n    \"\"\"\n    if not api_client:\n        return ErrorResponse(error=\"API Client not initialized. Check server logs.\")\n\n    try:\n        logger.info(f\"Executing custom deep search with params: {params.dict()}\")\n        result_dict = await api_client.search(params)\n\n        # Validate and parse the response\n        parsed_result = DeepsearchResult(\n            answer=result_dict.get(\"answer\", \"No answer provided.\"),\n            sources=[Source(**source) for source in result_dict.get(\"sources\", [])],\n            usage=DeepsearchUsage(**result_dict[\"usage\"]) if \"usage\" in result_dict else None\n        )\n        return parsed_result\n    except (ValueError, TimeoutError, ConnectionError) as e:\n        logger.error(f\"Error in deep_search_custom with params {params.dict()}: {e}\")\n        return ErrorResponse(error=f\"API Request Failed: {type(e).__name__}\", details=str(e))\n    except Exception as e:\n        logger.exception(f\"Unexpected error in deep_search_custom with params {params.dict()}: {e}\", exc_info=True)\n        return ErrorResponse(error=\"Internal Server Error\", details=str(e))\n\n# Run the MCP server\nif __name__ == \"__main__\":\n    logger.info(\"Starting Deepsearch MCP server...\")\n    # Note: Authentication for the MCP server itself (if needed) should be configured\n    # via MCP's mechanisms or a reverse proxy, not handled directly here.\n    mcp.run()\n"
    },
    {
      "name": "requirements.txt",
      "content": "mcp>=0.1.0\nfastapi>=0.100.0 # Required by FastMCP\nuvicorn[standard]>=0.20.0 # Required by FastMCP\nhttpx>=0.25.0\npydantic>=2.0.0\npython-dotenv>=1.0.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Environment variables for the Deepsearch MCP Server\n\n# The API key for authenticating with the Deepsearch API\nDEEPSEARCH_API_KEY=\"your_deepsearch_api_key_here\"\n\n# The base URL for the Deepsearch API\n# Example: https://api.deepsearch.com\nDEEPSEARCH_API_BASE_URL=\"https://your_deepsearch_api_base_url_here\"\n\n# Optional: MCP Server Host and Port (defaults to 127.0.0.1:8000)\n# MCP_HOST=0.0.0.0\n# MCP_PORT=8080\n"
    },
    {
      "name": "README.md",
      "content": "# Deepsearch MCP Server\n\nThis project provides a Model Context Protocol (MCP) server built with FastMCP to interact with a hypothetical \"Deepsearch\" API. Deepsearch is assumed to be a service that takes a query and returns a generated answer based on relevant search results (similar to RAG - Retrieval-Augmented Generation).\n\n## Features\n\n*   Provides MCP tools to perform searches via the Deepsearch API.\n*   Uses Pydantic for request and response validation.\n*   Includes asynchronous API client (`httpx`).\n*   Handles API authentication via environment variables.\n*   Includes error handling and logging.\n*   Configurable via environment variables.\n\n## Prerequisites\n\n*   Python 3.8+\n*   Access to a Deepsearch API (or equivalent) and its API key/base URL.\n\n## Setup\n\n1.  **Clone the repository (or download the files):**\n    ```bash\n    # git clone <repository_url>\n    # cd <repository_directory>\n    ```\n\n2.  **Create a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure environment variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your actual Deepsearch API key and base URL:\n        ```dotenv\n        DEEPSEARCH_API_KEY=\"your_actual_api_key\"\n        DEEPSEARCH_API_BASE_URL=\"https://actual.api.base.url\"\n        ```\n\n## Running the Server\n\nStart the MCP server using Uvicorn (which is installed as part of `uvicorn[standard]`):\n\n```bash\npython main.py\n```\n\nOr directly with uvicorn for more options (like hot-reloading):\n\n```bash\n# Ensure venv is active\nuvicorn main:mcp --reload --host 127.0.0.1 --port 8000\n```\n\nThe server will be available at `http://127.0.0.1:8000` by default.\n\n## Available MCP Tools\n\nThe server exposes the following tools:\n\n1.  **`deep_search`**\n    *   **Description:** Performs a search using the Deepsearch API with default settings.\n    *   **Input:**\n        *   `query` (string, required): The search query.\n    *   **Output:** `DeepsearchResult` (object containing `answer`, `sources`, `usage`) or `ErrorResponse`.\n\n2.  **`deep_search_custom`**\n    *   **Description:** Performs a search using the Deepsearch API with custom parameters.\n    *   **Input:** `params` (object)\n        *   `query` (string, required): The search query.\n        *   `model` (string, optional, default: \"deepsearch-default\"): The model to use.\n        *   `max_results` (integer, optional, default: 10): Max results to use/return.\n    *   **Output:** `DeepsearchResult` (object containing `answer`, `sources`, `usage`) or `ErrorResponse`.\n\n## API Client (`DeepsearchAPIClient`)\n\nThe `main.py` includes a `DeepsearchAPIClient` class responsible for:\n\n*   Reading API key and base URL from environment variables.\n*   Constructing API request headers (including Authorization).\n*   Making asynchronous POST requests to the `/v1/search` endpoint (configurable).\n*   Handling HTTP errors (4xx, 5xx), timeouts, and connection errors.\n*   Parsing the JSON response.\n\n**Note:** The specific API endpoint (`/v1/search`) and the request/response structure are based on assumptions. You may need to modify `DeepsearchAPIClient.search` and the Pydantic models (`DeepsearchQueryParams`, `DeepsearchResult`, `Source`, `DeepsearchUsage`) to match the actual Deepsearch API specification.\n\n## Error Handling\n\n*   The API client raises specific exceptions (`TimeoutError`, `ConnectionError`) for network/API issues.\n*   MCP tools catch these exceptions and return a structured `ErrorResponse` object.\n*   Unexpected errors within the tools also return an `ErrorResponse`.\n*   Failures during API client initialization (missing environment variables) are logged critically.\n\n## Authentication\n\n*   **API Authentication:** The server authenticates with the Deepsearch API using a Bearer token (API key) provided via the `DEEPSEARCH_API_KEY` environment variable.\n*   **MCP Server Authentication:** This implementation does *not* include authentication for accessing the MCP server itself. If required, this should be handled at a higher level, for example, using a reverse proxy (like Nginx or Traefik) or by leveraging MCP's built-in authentication features if available/configured.\n"
    }
  ]
}
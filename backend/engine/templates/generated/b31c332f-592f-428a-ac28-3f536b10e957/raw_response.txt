{
  "files": [
    {
      "name": "main.py",
      "content": "import logging\nimport os\nfrom typing import Dict, Any, List\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import KiteConnectClient, KiteConnectError\nfrom models import (\n    PlaceOrderParams,\n    ModifyOrderParams,\n    CancelOrderParams,\n    GetOrdersParams,\n    OrderIDResponse,\n    Order\n)\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP server\nmcp = FastMCP(\n    service_name=\"KiteConnectMCP\",\n    description=\"MCP server for interacting with the Kite Connect API, focusing on order management and retrieval functionalities. Allows placing, modifying, cancelling orders, and fetching order history and trades.\"\n)\n\n# Initialize Kite Connect Client\n# Ensure KITE_API_KEY and KITE_ACCESS_TOKEN are set in your .env file or environment\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n    # Exiting or raising an error might be appropriate in a real application\n    # For this example, we'll proceed but the client will fail.\n    kite_client = None\nelse:\n    try:\n        kite_client = KiteConnectClient(api_key=api_key, access_token=access_token, base_url=base_url)\n        logger.info(\"KiteConnectClient initialized successfully.\")\n    except Exception as e:\n        logger.exception(f\"Failed to initialize KiteConnectClient: {e}\")\n        kite_client = None\n\ndef handle_api_error(tool_name: str, error: Exception) -> Dict[str, Any]:\n    \"\"\"Handles errors from the KiteConnectClient.\"\"\"\n    logger.error(f\"Error in {tool_name}: {error}\", exc_info=True)\n    if isinstance(error, KiteConnectError):\n        return {\"error\": error.message, \"status_code\": error.status_code, \"details\": error.details}\n    else:\n        return {\"error\": f\"An unexpected error occurred in {tool_name}: {str(error)}\"}\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\"\"\"\n    if not kite_client:\n        return {\"error\": \"KiteConnectClient not initialized. Check API keys.\"}\n    try:\n        logger.info(f\"Placing order with params: {params.dict(exclude_none=True)}\")\n        result = await kite_client.place_order(params)\n        logger.info(f\"Order placed successfully: {result}\")\n        # Ensure the return type matches the expected Dict[str, str]\n        # The client method already returns OrderIDResponse which is compatible\n        return result.dict()\n    except Exception as e:\n        return handle_api_error(\"place_order\", e)\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modify an open or pending order.\"\"\"\n    if not kite_client:\n        return {\"error\": \"KiteConnectClient not initialized. Check API keys.\"}\n    try:\n        logger.info(f\"Modifying order {params.order_id} ({params.variety}) with params: {params.dict(exclude={'order_id', 'variety'}, exclude_none=True)}\")\n        result = await kite_client.modify_order(params)\n        logger.info(f\"Order modified successfully: {result}\")\n        return result.dict()\n    except Exception as e:\n        return handle_api_error(\"modify_order\", e)\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"Cancel an open or pending order.\"\"\"\n    if not kite_client:\n        return {\"error\": \"KiteConnectClient not initialized. Check API keys.\"}\n    try:\n        logger.info(f\"Cancelling order {params.order_id} ({params.variety}) with parent_order_id: {params.parent_order_id}\")\n        result = await kite_client.cancel_order(params)\n        logger.info(f\"Order cancelled successfully: {result}\")\n        return result.dict()\n    except Exception as e:\n        return handle_api_error(\"cancel_order\", e)\n\n@mcp.tool()\nasync def get_orders(params: GetOrdersParams = GetOrdersParams()) -> Dict[str, Any]:\n    \"\"\"Retrieve the list of all orders (open, pending, and executed) for the day.\"\"\"\n    # Note: GetOrdersParams is currently empty, added for future extensibility or consistency.\n    if not kite_client:\n        return {\"error\": \"KiteConnectClient not initialized. Check API keys.\"}\n    try:\n        logger.info(\"Fetching orders.\")\n        orders: List[Order] = await kite_client.get_orders()\n        logger.info(f\"Fetched {len(orders)} orders.\")\n        # MCP tools typically return Dicts, so we wrap the list\n        return {\"orders\": [order.dict() for order in orders]}\n    except Exception as e:\n        return handle_api_error(\"get_orders\", e)\n\nif __name__ == \"__main__\":\n    if not kite_client:\n        print(\"ERROR: Kite Connect client failed to initialize. Please check environment variables and logs.\")\n        print(\"MCP server will start, but tools will return errors.\")\n    # Add logic here to potentially wait for client initialization or handle it gracefully\n    mcp.run()\n"
    },
    {
      "name": "models.py",
      "content": "from typing import Optional, List, Literal, Dict, Any\nfrom pydantic import BaseModel, Field, validator\nimport datetime\n\n# Define Literal types for parameters\nVarietyType = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nExchangeType = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\nModifyVarietyType = Literal['regular', 'co', 'amo', 'iceberg']\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange.\")\n    transaction_type: TransactionType = Field(..., description=\"Transaction type.\")\n    order_type: OrderType = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: ProductType = Field(..., description=\"Product code.\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (SL, SL-M, CO).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity: ValidityType = Field(..., description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\")\n    iceberg_legs: Optional[int] = Field(None, ge=2, le=10, description=\"Total number of legs for iceberg order type (2-10).\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order.\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction.\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"An optional tag to apply to an order (alphanumeric, max 20 chars).\")\n\n    @validator('price')\n    def check_price_for_limit(cls, v, values):\n        if values.get('order_type') == 'LIMIT' and v is None:\n            raise ValueError('Price is required for LIMIT orders')\n        if values.get('order_type') == 'MARKET' and v is not None:\n            # Kite API might ignore it, but good practice to validate\n            # raise ValueError('Price should not be set for MARKET orders')\n            pass # Allow sending 0 for market orders if API requires\n        return v\n\n    @validator('trigger_price')\n    def check_trigger_price(cls, v, values):\n        if values.get('order_type') in ['SL', 'SL-M'] and v is None:\n            raise ValueError('Trigger price is required for SL and SL-M orders')\n        if values.get('variety') == 'co' and v is None:\n             raise ValueError('Trigger price is required for CO orders')\n        return v\n\n    @validator('validity_ttl')\n    def check_validity_ttl(cls, v, values):\n        if values.get('validity') == 'TTL' and v is None:\n            raise ValueError('validity_ttl is required for TTL validity')\n        if values.get('validity') != 'TTL' and v is not None:\n            raise ValueError('validity_ttl is only applicable for TTL validity')\n        return v\n\n    @validator('iceberg_legs', 'iceberg_quantity')\n    def check_iceberg_params(cls, v, values, field):\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError(f'{field.name} is required for iceberg orders')\n        if values.get('variety') != 'iceberg' and v is not None:\n            raise ValueError(f'{field.name} is only applicable for iceberg orders')\n        # Additional validation: iceberg_quantity should be less than total quantity\n        if field.name == 'iceberg_quantity' and v is not None and values.get('quantity') is not None:\n            if v >= values['quantity']:\n                 raise ValueError('iceberg_quantity must be less than total quantity')\n            if values.get('iceberg_legs') is not None and values['quantity'] / v > values['iceberg_legs']:\n                 # This logic might need refinement based on exact Kite rules\n                 pass\n        return v\n\n    @validator('auction_number')\n    def check_auction_number(cls, v, values):\n        if values.get('variety') == 'auction' and v is None:\n            raise ValueError('auction_number is required for auction orders')\n        if values.get('variety') != 'auction' and v is not None:\n            raise ValueError('auction_number is only applicable for auction orders')\n        return v\n\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Parameters for modifying an order.\"\"\"\n    variety: ModifyVarietyType = Field(..., description=\"Order variety.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for modifying second leg of CO.\")\n    order_type: Optional[OrderType] = Field(None, description=\"New order type (regular orders).\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity (regular orders).\")\n    price: Optional[float] = Field(None, description=\"New price (LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (SL, SL-M, CO).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (regular equity orders).\")\n    validity: Optional[ValidityType] = Field(None, description=\"New validity (regular orders).\")\n\n    @validator('parent_order_id')\n    def check_parent_order_id_for_co(cls, v, values):\n        # This validation might depend on which leg is being modified, API specifics needed.\n        # Assuming modification applies to the main order unless parent_order_id is specified for the second leg.\n        # if values.get('variety') == 'co' and v is None: # This might be too strict\n        #     raise ValueError('parent_order_id might be required for modifying CO legs')\n        return v\n\nclass CancelOrderParams(BaseModel):\n    \"\"\"Parameters for cancelling an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety.\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for cancelling second leg of CO.\")\n\n    @validator('parent_order_id')\n    def check_parent_order_id_for_co_cancel(cls, v, values):\n        # Similar to modify, API specifics needed for when parent_order_id is strictly required.\n        # if values.get('variety') == 'co' and v is None: # Might be too strict\n        #     raise ValueError('parent_order_id might be required for cancelling CO legs')\n        return v\n\nclass GetOrdersParams(BaseModel):\n    \"\"\"Parameters for retrieving orders (currently none).\"\"\"\n    pass # No parameters needed for fetching all orders for the day\n\nclass OrderIDResponse(BaseModel):\n    \"\"\"Standard response containing an order ID.\"\"\"\n    order_id: str = Field(..., description=\"The ID of the order affected by the operation.\")\n\nclass Order(BaseModel):\n    \"\"\"Represents a single order retrieved from the API.\"\"\"\n    # Based on common fields in Kite Connect order responses\n    order_id: str\n    parent_order_id: Optional[str] = None\n    exchange_order_id: Optional[str] = None\n    status: str # e.g., OPEN, COMPLETE, CANCELLED, REJECTED\n    status_message: Optional[str] = None\n    status_message_raw: Optional[str] = None\n    order_timestamp: datetime.datetime\n    exchange_timestamp: Optional[datetime.datetime] = None\n    variety: str\n    exchange: str\n    tradingsymbol: str\n    instrument_token: int\n    order_type: str\n    transaction_type: str\n    validity: str\n    validity_ttl: Optional[int] = None # Added based on PlaceOrderParams\n    product: str\n    quantity: int\n    disclosed_quantity: int\n    price: float\n    trigger_price: float\n    average_price: float\n    filled_quantity: int\n    pending_quantity: int\n    cancelled_quantity: int # Added for clarity\n    market_protection: Optional[float] = Field(None, alias=\"market_protection\") # Check alias if needed\n    meta: Optional[Dict[str, Any]] = None\n    tag: Optional[str] = None\n    guid: Optional[str] = None # Internal ID\n\n    class Config:\n        allow_population_by_field_name = True # If API uses snake_case\n"
    },
    {
      "name": "client.py",
      "content": "import logging\nfrom typing import Dict, Any, List, Optional\n\nimport httpx\nfrom pydantic import ValidationError\n\nfrom models import (\n    PlaceOrderParams,\n    ModifyOrderParams,\n    CancelOrderParams,\n    OrderIDResponse,\n    Order\n)\n\nlogger = logging.getLogger(__name__)\n\nclass KiteConnectError(Exception):\n    \"\"\"Custom exception class for Kite Connect API errors.\"\"\"\n    def __init__(self, message: str, status_code: Optional[int] = None, details: Optional[Any] = None):\n        self.message = message\n        self.status_code = status_code\n        self.details = details\n        super().__init__(message)\n\n    def __str__(self):\n        return f\"KiteConnectError(status_code={self.status_code}): {self.message} {self.details or ''}\"\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect API.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        \"\"\"\n        Initializes the Kite Connect client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after successful login.\n            base_url: The base URL for the Kite Connect API.\n            timeout: Default request timeout in seconds.\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self._headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form encoding\n        }\n        self._client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self._headers,\n            timeout=timeout\n        )\n        logger.info(f\"KiteConnectClient initialized for base URL: {self.base_url}\")\n\n    async def _request(self, method: str, endpoint: str, params: Optional[Dict] = None, data: Optional[Dict] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous request to the Kite Connect API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Making request: {method} {url} | Params: {params} | Data: {data}\")\n        try:\n            response = await self._client.request(method, endpoint, params=params, data=data)\n            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx\n            json_response = response.json()\n            logger.debug(f\"Response status: {response.status_code}, Response data: {json_response}\")\n\n            # Kite API specific response structure check\n            if json_response.get(\"status\") == \"error\":\n                error_type = json_response.get(\"error_type\", \"UnknownError\")\n                message = json_response.get(\"message\", \"Unknown API error\")\n                logger.error(f\"Kite API Error ({error_type}): {message} | Status Code: {response.status_code}\")\n                raise KiteConnectError(message=message, status_code=response.status_code, details={\"error_type\": error_type})\n\n            # Successful response usually contains a 'data' field\n            return json_response.get(\"data\", {})\n\n        except httpx.HTTPStatusError as e:\n            status_code = e.response.status_code\n            try:\n                # Attempt to parse error details from response body\n                error_data = e.response.json()\n                message = error_data.get(\"message\", f\"HTTP Error {status_code}\")\n                error_type = error_data.get(\"error_type\", \"HTTPError\")\n                details = {\"error_type\": error_type, \"content\": error_data}\n            except Exception:\n                message = f\"HTTP Error {status_code}: {e.response.text[:200]}...\"\n                details = {\"content\": e.response.text}\n\n            logger.error(f\"HTTP Error: {status_code} {message}\", exc_info=False) # Avoid logging full trace for HTTP errors unless debugging\n            # Map common HTTP errors to KiteConnectError types\n            if status_code == 400:\n                raise KiteConnectError(message=f\"Bad Request/Validation Error: {message}\", status_code=status_code, details=details) from e\n            elif status_code in [401, 403]:\n                raise KiteConnectError(message=f\"Authentication/Authorization Error: {message}\", status_code=status_code, details=details) from e\n            elif status_code == 404:\n                raise KiteConnectError(message=f\"Not Found: {message}\", status_code=status_code, details=details) from e\n            elif status_code == 429:\n                raise KiteConnectError(message=f\"Rate Limit Exceeded: {message}\", status_code=status_code, details=details) from e\n            elif status_code >= 500:\n                raise KiteConnectError(message=f\"Server Error: {message}\", status_code=status_code, details=details) from e\n            else:\n                raise KiteConnectError(message=message, status_code=status_code, details=details) from e\n\n        except httpx.RequestError as e:\n            logger.error(f\"Network or Request Error: {e}\", exc_info=True)\n            raise KiteConnectError(message=f\"Network request failed: {e}\") from e\n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during API request: {e}\")\n            raise KiteConnectError(message=f\"An unexpected error occurred: {e}\") from e\n\n    async def place_order(self, params: PlaceOrderParams) -> OrderIDResponse:\n        \"\"\"Place an order.\"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Convert Pydantic model to dict, excluding None values\n        data = params.dict(exclude={'variety'}, exclude_none=True)\n        try:\n            response_data = await self._request(\"POST\", endpoint, data=data)\n            return OrderIDResponse(**response_data)\n        except ValidationError as e:\n            logger.error(f\"Response validation error for place_order: {e}\")\n            raise KiteConnectError(message=\"Invalid response format from API\", details=str(e))\n\n    async def modify_order(self, params: ModifyOrderParams) -> OrderIDResponse:\n        \"\"\"Modify an existing order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Only include fields relevant for modification, exclude identifiers and None\n        data = params.dict(exclude={'variety', 'order_id'}, exclude_none=True)\n        try:\n            response_data = await self._request(\"PUT\", endpoint, data=data)\n            return OrderIDResponse(**response_data)\n        except ValidationError as e:\n            logger.error(f\"Response validation error for modify_order: {e}\")\n            raise KiteConnectError(message=\"Invalid response format from API\", details=str(e))\n\n    async def cancel_order(self, params: CancelOrderParams) -> OrderIDResponse:\n        \"\"\"Cancel an existing order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        query_params = {}\n        if params.parent_order_id:\n            query_params['parent_order_id'] = params.parent_order_id\n\n        try:\n            response_data = await self._request(\"DELETE\", endpoint, params=query_params)\n            return OrderIDResponse(**response_data)\n        except ValidationError as e:\n            logger.error(f\"Response validation error for cancel_order: {e}\")\n            raise KiteConnectError(message=\"Invalid response format from API\", details=str(e))\n\n    async def get_orders(self) -> List[Order]:\n        \"\"\"Retrieve the list of orders for the day.\"\"\"\n        endpoint = \"/orders\"\n        try:\n            response_data = await self._request(\"GET\", endpoint)\n            # response_data is expected to be a list of order dictionaries\n            if not isinstance(response_data, list):\n                 logger.error(f\"Unexpected response format for get_orders: expected list, got {type(response_data)}\")\n                 raise KiteConnectError(message=\"Invalid response format from API: Expected a list of orders.\", details=response_data)\n\n            orders = [Order(**order_data) for order_data in response_data]\n            return orders\n        except ValidationError as e:\n            logger.error(f\"Response validation error for get_orders: {e}\")\n            raise KiteConnectError(message=\"Invalid order data format in API response\", details=str(e))\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTP client.\"\"\"\n        await self._client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.2.0\npydantic>=1.9.0,<2.0.0\nhttpx>=0.23.0\npython-dotenv>=0.20.0\n# typing_extensions might be needed for Literal in older Python versions\n# typing_extensions>=4.0.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Copy this file to .env and fill in your actual credentials.\n\n# Obtain these from https://developers.kite.trade/\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# This is obtained after a successful login flow (e.g., using Kite Connect Python client or manual login)\n# It's session-specific and typically expires daily.\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# Optional: Base URL for the Kite API (defaults to https://api.kite.trade)\n# KITE_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect MCP Server\n\nThis project implements a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect API. It allows language models or other applications to manage trading orders (place, modify, cancel) and retrieve order history using a standardized MCP interface.\n\n## Features\n\n*   Place new orders (regular, AMO, CO, Iceberg, Auction).\n*   Modify existing pending orders.\n*   Cancel existing pending orders.\n*   Retrieve the list of all orders for the day.\n*   Built using FastMCP for efficient serving.\n*   Asynchronous API client (`httpx`) for non-blocking operations.\n*   Pydantic models for request/response validation.\n*   Environment variable based configuration.\n*   Basic error handling for API and network issues.\n\n## Prerequisites\n\n*   Python 3.8+\n*   A Zerodha Kite Connect API key and secret.\n*   A valid `access_token` obtained through the Kite Connect login flow. This token usually has daily validity.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository_url>\n    cd <repository_directory>\n    ```\n\n2.  **Create a virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure environment variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect `API_KEY` and a valid `ACCESS_TOKEN`:\n        ```dotenv\n        KITE_API_KEY=\"YOUR_API_KEY\"\n        KITE_ACCESS_TOKEN=\"YOUR_VALID_ACCESS_TOKEN\"\n        # Optional: KITE_BASE_URL=\"https://api.kite.trade\"\n        ```\n    *   **Important:** The `ACCESS_TOKEN` needs to be periodically refreshed as it expires. This server assumes a valid token is provided at startup.\n\n## Running the Server\n\nStart the MCP server using:\n\n```bash\npython main.py\n```\n\nThe server will start, typically listening on `http://127.0.0.1:8000` (or the configured host/port for FastMCP).\n\n## Available Tools\n\nThe following tools are exposed via the MCP server:\n\n1.  **`place_order`**\n    *   Description: Place an order of a particular variety.\n    *   Input (`PlaceOrderParams` model):\n        *   `variety` (required): 'regular', 'amo', 'co', 'iceberg', 'auction'\n        *   `tradingsymbol` (required): e.g., \"INFY\", \"NIFTY23JULFUT\"\n        *   `exchange` (required): 'NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'\n        *   `transaction_type` (required): 'BUY', 'SELL'\n        *   `order_type` (required): 'MARKET', 'LIMIT', 'SL', 'SL-M'\n        *   `quantity` (required): Positive integer\n        *   `product` (required): 'CNC', 'NRML', 'MIS', 'MTF'\n        *   `price` (optional): Float, required for 'LIMIT' orders.\n        *   `trigger_price` (optional): Float, required for 'SL', 'SL-M', 'CO' orders.\n        *   `disclosed_quantity` (optional): Integer\n        *   `validity` (required): 'DAY', 'IOC', 'TTL'\n        *   `validity_ttl` (optional): Integer (minutes), required if validity is 'TTL'.\n        *   `iceberg_legs` (optional): Integer (2-10), required for 'iceberg' variety.\n        *   `iceberg_quantity` (optional): Integer, required for 'iceberg' variety.\n        *   `auction_number` (optional): String, required for 'auction' variety.\n        *   `tag` (optional): String (max 20 chars).\n    *   Returns: `{\"order_id\": \"<string>\"}` on success, or `{\"error\": \"...\"}` on failure.\n\n2.  **`modify_order`**\n    *   Description: Modify an open or pending order.\n    *   Input (`ModifyOrderParams` model):\n        *   `variety` (required): 'regular', 'co', 'amo', 'iceberg'\n        *   `order_id` (required): The ID of the order to modify.\n        *   `parent_order_id` (optional): String, required for modifying second leg of CO.\n        *   `order_type` (optional): New order type ('MARKET', 'LIMIT', 'SL', 'SL-M').\n        *   `quantity` (optional): New quantity (positive integer).\n        *   `price` (optional): New price (float, for LIMIT).\n        *   `trigger_price` (optional): New trigger price (float, for SL, SL-M, CO).\n        *   `disclosed_quantity` (optional): New disclosed quantity (integer).\n        *   `validity` (optional): New validity ('DAY', 'IOC', 'TTL').\n    *   Returns: `{\"order_id\": \"<string>\"}` on success, or `{\"error\": \"...\"}` on failure.\n\n3.  **`cancel_order`**\n    *   Description: Cancel an open or pending order.\n    *   Input (`CancelOrderParams` model):\n        *   `variety` (required): 'regular', 'co', 'amo', 'iceberg', 'auction'\n        *   `order_id` (required): The ID of the order to cancel.\n        *   `parent_order_id` (optional): String, required for cancelling second leg of CO.\n    *   Returns: `{\"order_id\": \"<string>\"}` on success, or `{\"error\": \"...\"}` on failure.\n\n4.  **`get_orders`**\n    *   Description: Retrieve the list of all orders (open, pending, and executed) for the day.\n    *   Input (`GetOrdersParams` model): None required.\n    *   Returns: `{\"orders\": [Order, Order, ...]}` where `Order` is a dictionary containing detailed order information (see `models.py/Order` for fields), or `{\"error\": \"...\"}` on failure.\n\n## Error Handling\n\nThe server attempts to catch common errors:\n\n*   **Authentication Errors:** If the `API_KEY` or `ACCESS_TOKEN` is invalid or expired (HTTP 401/403).\n*   **Validation Errors:** If the input parameters are incorrect (HTTP 400 or Pydantic validation errors).\n*   **Not Found Errors:** If an `order_id` doesn't exist (HTTP 404).\n*   **Rate Limit Errors:** If the Kite API rate limits are exceeded (HTTP 429).\n*   **Network Errors:** If the server cannot reach the Kite API.\n*   **API Errors:** Specific errors returned by the Kite API (e.g., insufficient funds, RMS rejection).\n\nErrors are returned as a JSON dictionary with an `\"error\"` key containing a descriptive message, and potentially `\"status_code\"` and `\"details\"` keys.\n\n## Disclaimer\n\nTrading involves substantial risk. This software is provided \"as is\" without warranty of any kind. Use it at your own risk. Ensure you understand the Kite Connect API documentation and the implications of automated trading before use.\n"
    }
  ]
}
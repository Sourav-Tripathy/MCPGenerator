{
  "files": [
    {
      "name": "main.py",
      "content": "import logging\nimport os\nfrom typing import Any, Dict\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import KiteConnectClient, KiteConnectError\nfrom models import CancelOrderParams, ModifyOrderParams, PlaceOrderParams, OrderResponse\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectOrders\",\n    description=\"MCP server for managing trading orders (placing, modifying, cancelling) via the Kite Connect API v3.\"\n)\n\n# Initialize Kite Connect Client\nAPI_KEY = os.getenv(\"KITE_API_KEY\")\nACCESS_TOKEN = os.getenv(\"KITE_ACCESS_TOKEN\")\nBASE_URL = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not API_KEY or not ACCESS_TOKEN:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n    # Optionally raise an error or exit if credentials are critical for startup\n    # raise ValueError(\"API Key and Access Token are required.\")\n    # For now, we allow startup but client calls will fail.\n    kite_client = None\nelse:\n    try:\n        kite_client = KiteConnectClient(api_key=API_KEY, access_token=ACCESS_TOKEN, base_url=BASE_URL)\n        logger.info(\"KiteConnectClient initialized successfully.\")\n    except Exception as e:\n        logger.exception(\"Failed to initialize KiteConnectClient\")\n        kite_client = None\n\n# --- MCP Tools ---\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Place an order of a particular variety (regular, amo, co, iceberg, auction).\n\n    Args:\n        params: Order placement parameters including variety, tradingsymbol, exchange, etc.\n\n    Returns:\n        A dictionary containing the 'order_id' upon success, or an error dictionary.\n    \"\"\"\n    if not kite_client:\n        logger.error(\"place_order: KiteConnectClient is not initialized.\")\n        return {\"status\": \"error\", \"message\": \"Kite Connect client not initialized. Check credentials.\"}\n\n    logger.info(f\"Attempting to place order: {params.dict(exclude_unset=True)}\")\n    try:\n        response_data = await kite_client.place_order_async(params)\n        logger.info(f\"Successfully placed order: {response_data}\")\n        # Assuming the API returns {'status': 'success', 'data': {'order_id': '...'}}\n        if isinstance(response_data, dict) and response_data.get(\"status\") == \"success\":\n             # Validate and return using Pydantic model if desired, or return raw dict\n            return response_data\n        else:\n            # Handle unexpected success response format\n            logger.warning(f\"Received unexpected success response format: {response_data}\")\n            return {\"status\": \"success\", \"data\": response_data} # Return raw data\n\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error placing order: {e}\")\n        return {\"status\": \"error\", \"message\": str(e), \"details\": e.details}\n    except Exception as e:\n        logger.exception(\"Unexpected error placing order\")\n        return {\"status\": \"error\", \"message\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Modify an open or pending order of a particular variety (regular, co).\n\n    Args:\n        params: Order modification parameters including variety, order_id, and fields to modify.\n\n    Returns:\n        A dictionary containing the 'order_id' upon success, or an error dictionary.\n    \"\"\"\n    if not kite_client:\n        logger.error(\"modify_order: KiteConnectClient is not initialized.\")\n        return {\"status\": \"error\", \"message\": \"Kite Connect client not initialized. Check credentials.\"}\n\n    logger.info(f\"Attempting to modify order {params.order_id}: {params.dict(exclude={'order_id', 'variety'}, exclude_unset=True)}\")\n    try:\n        response_data = await kite_client.modify_order_async(params)\n        logger.info(f\"Successfully modified order {params.order_id}: {response_data}\")\n        if isinstance(response_data, dict) and response_data.get(\"status\") == \"success\":\n            return response_data\n        else:\n            logger.warning(f\"Received unexpected success response format for modify: {response_data}\")\n            return {\"status\": \"success\", \"data\": response_data}\n\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error modifying order {params.order_id}: {e}\")\n        return {\"status\": \"error\", \"message\": str(e), \"details\": e.details}\n    except Exception as e:\n        logger.exception(f\"Unexpected error modifying order {params.order_id}\")\n        return {\"status\": \"error\", \"message\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Cancel an open or pending order.\n\n    Args:\n        params: Order cancellation parameters including variety and order_id.\n\n    Returns:\n        A dictionary containing the 'order_id' upon success, or an error dictionary.\n    \"\"\"\n    if not kite_client:\n        logger.error(\"cancel_order: KiteConnectClient is not initialized.\")\n        return {\"status\": \"error\", \"message\": \"Kite Connect client not initialized. Check credentials.\"}\n\n    logger.info(f\"Attempting to cancel order {params.order_id} (variety: {params.variety})\")\n    try:\n        response_data = await kite_client.cancel_order_async(params)\n        logger.info(f\"Successfully cancelled order {params.order_id}: {response_data}\")\n        if isinstance(response_data, dict) and response_data.get(\"status\") == \"success\":\n            return response_data\n        else:\n            logger.warning(f\"Received unexpected success response format for cancel: {response_data}\")\n            return {\"status\": \"success\", \"data\": response_data}\n\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error cancelling order {params.order_id}: {e}\")\n        return {\"status\": \"error\", \"message\": str(e), \"details\": e.details}\n    except Exception as e:\n        logger.exception(f\"Unexpected error cancelling order {params.order_id}\")\n        return {\"status\": \"error\", \"message\": f\"An unexpected error occurred: {str(e)}\"}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    logger.info(\"Starting KiteConnectOrders MCP server...\")\n    # Run with uvicorn. Note: For production, consider using a process manager like Gunicorn.\n    # The host and port can be configured via environment variables or command-line arguments if needed.\n    uvicorn.run(mcp.app, host=\"0.0.0.0\", port=8000)\n"
    },
    {
      "name": "models.py",
      "content": "from typing import Literal, Optional, Dict, Any\nfrom pydantic import BaseModel, Field, validator, root_validator\n\n# Define Literal types for constrained fields\nVarietyType = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nExchangeType = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\nModifiableVarietyType = Literal['regular', 'co'] # Based on plan description\nModifiableOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nModifiableValidityType = Literal['DAY', 'IOC', 'TTL']\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\n\n    Corresponds to the input model for the 'place_order' tool.\n    \"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety type.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange.\")\n    transaction_type: TransactionType = Field(..., description=\"Transaction type.\")\n    order_type: OrderType = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: ProductType = Field(..., description=\"Product type (margin product).\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (required for LIMIT orders).\", ge=0)\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (required for SL, SL-M orders).\", ge=0)\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\", ge=0)\n    validity: ValidityType = Field(..., description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\", ge=1)\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10).\", ge=2, le=10)\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs).\", ge=1)\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction.\")\n    tag: Optional[str] = Field(None, description=\"An optional tag to apply to an order (alphanumeric, max 20 chars).\", max_length=20)\n\n    @root_validator\n    def check_conditional_required_fields(cls, values):\n        order_type = values.get('order_type')\n        price = values.get('price')\n        trigger_price = values.get('trigger_price')\n        validity = values.get('validity')\n        validity_ttl = values.get('validity_ttl')\n        variety = values.get('variety')\n        iceberg_legs = values.get('iceberg_legs')\n        iceberg_quantity = values.get('iceberg_quantity')\n        quantity = values.get('quantity')\n        auction_number = values.get('auction_number')\n\n        if order_type == 'LIMIT' and price is None:\n            raise ValueError(\"Price is required for LIMIT orders.\")\n        if order_type in ('SL', 'SL-M') and trigger_price is None:\n            raise ValueError(\"Trigger price is required for SL and SL-M orders.\")\n        if validity == 'TTL' and validity_ttl is None:\n            raise ValueError(\"validity_ttl is required for TTL validity.\")\n        if variety == 'iceberg' and (iceberg_legs is None or iceberg_quantity is None):\n            raise ValueError(\"iceberg_legs and iceberg_quantity are required for iceberg orders.\")\n        if variety == 'auction' and auction_number is None:\n            raise ValueError(\"auction_number is required for auction orders.\")\n\n        if iceberg_legs and iceberg_quantity and quantity:\n            if quantity % iceberg_legs != 0:\n                raise ValueError(\"Quantity must be a multiple of iceberg_legs.\")\n            if iceberg_quantity != quantity // iceberg_legs:\n                raise ValueError(\"iceberg_quantity must be equal to quantity / iceberg_legs.\")\n\n        return values\n\n    class Config:\n        use_enum_values = True # Ensure literals are passed as strings\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Parameters for modifying an order.\n\n    Corresponds to the input model for the 'modify_order' tool.\n    \"\"\"\n    variety: ModifiableVarietyType = Field(..., description=\"Order variety type ('regular' or 'co').\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    order_type: Optional[ModifiableOrderType] = Field(None, description=\"New order type (for regular orders).\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (for regular orders).\", gt=0)\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders).\", ge=0)\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, LIMIT CO orders).\", ge=0)\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (for regular equity orders).\", ge=0)\n    validity: Optional[ModifiableValidityType] = Field(None, description=\"New validity (for regular orders).\")\n\n    @root_validator\n    def check_at_least_one_modifiable_field(cls, values):\n        modifiable_fields = ['order_type', 'quantity', 'price', 'trigger_price', 'disclosed_quantity', 'validity']\n        if not any(values.get(field) is not None for field in modifiable_fields):\n            raise ValueError(\"At least one field (order_type, quantity, price, trigger_price, disclosed_quantity, validity) must be provided for modification.\")\n        return values\n\n    # Add further validation if needed, e.g., price required if modifying to LIMIT\n\n    class Config:\n        use_enum_values = True\n\nclass CancelOrderParams(BaseModel):\n    \"\"\"Parameters for cancelling an order.\n\n    Corresponds to the input model for the 'cancel_order' tool.\n    \"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety type.\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel.\")\n\n    class Config:\n        use_enum_values = True\n\nclass OrderResponseData(BaseModel):\n    \"\"\"Data part of a successful order response.\"\"\"\n    order_id: str\n\nclass OrderResponse(BaseModel):\n    \"\"\"Standard response structure for order operations.\"\"\"\n    status: Literal['success']\n    data: OrderResponseData\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response structure.\"\"\"\n    status: Literal['error']\n    message: str\n    details: Optional[Dict[str, Any]] = None\n"
    },
    {
      "name": "client.py",
      "content": "import logging\nfrom typing import Any, Dict, Optional\n\nimport httpx\n\nfrom models import CancelOrderParams, ModifyOrderParams, PlaceOrderParams\n\nlogger = logging.getLogger(__name__)\n\nKITE_API_VERSION = \"3\" # As per Kite Connect v3 documentation\n\nclass KiteConnectError(Exception):\n    \"\"\"Custom exception class for Kite Connect API errors.\"\"\"\n    def __init__(self, message: str, status_code: Optional[int] = None, details: Optional[Dict[str, Any]] = None):\n        super().__init__(message)\n        self.status_code = status_code\n        self.details = details if details else {}\n\n    def __str__(self):\n        return f\"KiteConnectError(status_code={self.status_code}): {super().__str__()}\"\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect API v3 (Orders).\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        \"\"\"\n        Initializes the Kite Connect client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after successful login.\n            base_url: The base URL for the Kite Connect API.\n            timeout: Default request timeout in seconds.\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self._headers = {\n            \"X-Kite-Version\": KITE_API_VERSION,\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite API uses form encoding\n        }\n        self._client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self._headers,\n            timeout=timeout\n        )\n        # Note: Rate limiting (10 requests/sec) is enforced by Kite. This client\n        # does not implement explicit rate limiting. Ensure usage stays within limits.\n        logger.info(f\"KiteConnectClient initialized for base URL: {self.base_url}\")\n        logger.warning(\"Ensure API usage adheres to Kite Connect rate limits (e.g., 10 requests/second).\")\n\n    async def _request(self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Making Kite API request: {method} {url}\")\n        logger.debug(f\"Request Headers: {self._headers}\") # Be cautious logging tokens in production\n        logger.debug(f\"Request Params: {params}\")\n        logger.debug(f\"Request Data: {data}\")\n\n        try:\n            response = await self._client.request(method, endpoint, params=params, data=data)\n            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx responses\n            response_data = response.json()\n            logger.debug(f\"Kite API Response Status: {response.status_code}\")\n            logger.debug(f\"Kite API Response Body: {response_data}\")\n\n            # Check for Kite specific error structure within a 200 OK response\n            if isinstance(response_data, dict) and response_data.get('status') == 'error':\n                logger.error(f\"Kite API returned error in success response: {response_data}\")\n                raise KiteConnectError(\n                    message=response_data.get('message', 'Unknown API error'),\n                    status_code=response.status_code,\n                    details=response_data\n                )\n\n            return response_data\n\n        except httpx.HTTPStatusError as e:\n            status_code = e.response.status_code\n            try:\n                # Attempt to parse error details from response body\n                error_data = e.response.json()\n                message = error_data.get('message', f\"HTTP Error {status_code}\")\n                details = error_data\n                logger.error(f\"Kite API HTTP Error {status_code}: {message} | Details: {details}\")\n            except Exception:\n                # Fallback if response body is not JSON or parsing fails\n                message = f\"HTTP Error {status_code}: {e.response.text or 'No details available'}\"\n                details = {\"raw_response\": e.response.text}\n                logger.error(f\"Kite API HTTP Error {status_code}: {message}\")\n\n            # Map specific status codes if needed (e.g., 401/403 for auth)\n            if status_code in [401, 403]:\n                raise KiteConnectError(\"AuthenticationError: Invalid API key or access token.\", status_code, details)\n            elif status_code == 404:\n                 raise KiteConnectError(\"NotFoundError: Resource not found.\", status_code, details)\n            elif status_code == 400:\n                 raise KiteConnectError(\"InvalidInputError: Bad request, check parameters.\", status_code, details)\n            elif status_code == 429:\n                 raise KiteConnectError(\"RateLimitError: Too many requests.\", status_code, details)\n            else:\n                raise KiteConnectError(message, status_code, details)\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Kite API request timed out: {e}\")\n            raise KiteConnectError(\"NetworkError: Request timed out.\")\n        except httpx.RequestError as e:\n            logger.error(f\"Kite API request failed: {e}\")\n            raise KiteConnectError(f\"NetworkError: Could not connect to Kite API. {e}\")\n        except Exception as e:\n            logger.exception(\"An unexpected error occurred during Kite API request\")\n            raise KiteConnectError(f\"Unexpected error: {str(e)}\")\n\n    async def place_order_async(self, params: PlaceOrderParams) -> Dict[str, Any]:\n        \"\"\"Place an order asynchronously.\"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Convert model to dict, excluding None values and the 'variety' path param\n        data = params.dict(exclude={'variety'}, exclude_unset=True)\n        # Convert boolean/numeric types to strings if required by API (Kite uses form encoding, usually handles this)\n        # Ensure required fields based on logic (e.g., price for LIMIT) are present (handled by Pydantic model)\n        return await self._request(\"POST\", endpoint, data=data)\n\n    async def modify_order_async(self, params: ModifyOrderParams) -> Dict[str, Any]:\n        \"\"\"Modify an order asynchronously.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Convert model to dict, excluding None values and path params\n        data = params.dict(exclude={'variety', 'order_id'}, exclude_unset=True)\n        return await self._request(\"PUT\", endpoint, data=data)\n\n    async def cancel_order_async(self, params: CancelOrderParams) -> Dict[str, Any]:\n        \"\"\"Cancel an order asynchronously.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # No data payload for DELETE usually, params are in the URL\n        return await self._request(\"DELETE\", endpoint)\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTP client.\"\"\"\n        await self._client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0,<0.2.0\npydantic>=1.9.0,<2.0.0\nhttpx>=0.23.0,<0.28.0\npython-dotenv>=0.19.0,<1.1.0\nuvicorn>=0.15.0,<0.30.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer Console (https://developers.kite.trade/)\n\n# Your Kite application's API key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# The access token obtained after a successful user login flow (valid for one day)\n# This needs to be generated daily or managed via a refresh token mechanism (outside scope of this MCP)\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# (Optional) Base URL for the Kite Connect API, defaults to production\n# KITE_BASE_URL=\"https://api.kite.trade\"\n\n# (Optional) User ID associated with the access token (not directly used by client but good for reference)\n# KITE_USER_ID=\"YOUR_USER_ID\"\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the order placement and management functionalities of the Zerodha Kite Connect API v3.\n\nIt allows language models or other applications to place, modify, and cancel trading orders programmatically via the MCP interface.\n\n**Disclaimer:** Trading involves risk. Ensure you understand the Kite Connect API, the parameters involved, and the risks associated with automated trading before using this software with real funds.\n\n## Features\n\n*   Provides MCP tools for:\n    *   `place_order`: Place regular, AMO, CO, Iceberg, and Auction orders.\n    *   `modify_order`: Modify pending regular and CO orders.\n    *   `cancel_order`: Cancel pending orders of any variety.\n*   Uses Pydantic models for clear request parameter validation.\n*   Asynchronous API client (`httpx`) for non-blocking requests.\n*   Handles authentication using Kite API Key and Access Token.\n*   Basic error handling for API and network issues.\n*   Configurable via environment variables.\n\n## Prerequisites\n\n*   Python 3.8+\n*   A Zerodha Kite account.\n*   Kite Developer API credentials (API Key).\n*   A valid `access_token` (obtained through the Kite Connect login flow - see [Kite Connect Documentation](https://kite.trade/docs/connect/v3/user/)).\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd kiteconnect-mcp-server\n    ```\n\n2.  **Create and activate a virtual environment:**\n    ```bash\n    python -m venv venv\n    # On Windows\n    # venv\\Scripts\\activate\n    # On macOS/Linux\n    source venv/bin/activate\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure environment variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite `API_KEY` and a valid `ACCESS_TOKEN`:\n        ```dotenv\n        KITE_API_KEY=\"YOUR_ACTUAL_API_KEY\"\n        KITE_ACCESS_TOKEN=\"YOUR_GENERATED_ACCESS_TOKEN\"\n        # Optional: KITE_BASE_URL=\"https://api.kite.trade\"\n        ```\n    *   **Important:** The `ACCESS_TOKEN` is typically valid for only one day. You will need a mechanism to refresh or regenerate this token regularly for continuous operation.\n\n## Running the Server\n\nUse `uvicorn` to run the FastMCP application:\n\n```bash\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n*   `--reload`: Automatically restarts the server when code changes (useful for development).\n\nThe MCP server will be available at `http://localhost:8000` (or your machine's IP address on port 8000).\n\n## Available Tools\n\nThe server exposes the following tools via the MCP protocol:\n\n1.  **`place_order`**\n    *   **Description:** Place an order of a particular variety.\n    *   **Input:** `PlaceOrderParams` model (see `models.py` for fields like `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, `price`, `trigger_price`, etc.).\n    *   **Returns:** Dictionary with `order_id` on success, or an error dictionary.\n\n2.  **`modify_order`**\n    *   **Description:** Modify an open/pending regular or CO order.\n    *   **Input:** `ModifyOrderParams` model (see `models.py` for fields like `variety`, `order_id`, `quantity`, `price`, `trigger_price`, etc.). Note that only `regular` and `co` varieties are typically modifiable.\n    *   **Returns:** Dictionary with `order_id` on success, or an error dictionary.\n\n3.  **`cancel_order`**\n    *   **Description:** Cancel an open/pending order.\n    *   **Input:** `CancelOrderParams` model (see `models.py` for fields `variety`, `order_id`).\n    *   **Returns:** Dictionary with `order_id` on success, or an error dictionary.\n\n## Authentication\n\nThe server authenticates with the Kite Connect API using the `KITE_API_KEY` and `KITE_ACCESS_TOKEN` provided in the `.env` file. Ensure these are kept secure and that the `ACCESS_TOKEN` is valid.\n\n## Error Handling\n\nThe server attempts to catch common errors:\n*   **Configuration Errors:** Missing API key or access token.\n*   **Validation Errors:** Incorrect parameters passed to tools (handled by Pydantic).\n*   **Kite API Errors:** Errors returned by the Kite Connect API (e.g., insufficient funds, invalid parameters, authentication failure, rate limits) are wrapped in a `KiteConnectError` and returned as an error dictionary in the MCP response.\n*   **Network Errors:** Timeouts or connection issues when communicating with the Kite API.\n\nError responses generally follow the format:\n`{\"status\": \"error\", \"message\": \"Error description\", \"details\": {...}}`\n\n## Rate Limiting\n\nThe Kite Connect API enforces rate limits (typically 10 requests per second per API key). This MCP server **does not implement client-side rate limiting**. It is the responsibility of the application using this MCP server to manage request rates and stay within the API limits to avoid `429 Too Many Requests` errors.\n\n## Disclaimer\n\nThis software is provided \"as is\", without warranty of any kind. The authors or copyright holders are not liable for any claim, damages, or other liability arising from the use of this software, especially concerning financial losses incurred through trading.\n"
    }
  ]
}
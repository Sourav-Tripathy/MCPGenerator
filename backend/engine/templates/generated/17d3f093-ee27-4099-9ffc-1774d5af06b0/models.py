from typing import List, Optional, Dict, Any, Union
from pydantic import BaseModel, Field

# --- Type Definitions from Implementation Plan ---

class Message(BaseModel):
    """Represents a single message in the conversation."""
    role: str = Field(..., description="The role of the message author ('user' or 'assistant').")
    content: Union[str, List[Dict[str, Any]]] = Field(..., description="The content of the message. Can be simple text, or a list for complex content like images/files (e.g., [{'type': 'text', 'text': '...'}, {'type': 'image_url', 'image_url': {'url': 'data:image/jpeg;base64,...'}}]).")

class URLCitation(BaseModel):
    """Details of a URL citation used in the response."""
    title: Optional[str] = Field(None, description="Title of the cited page.")
    exactQuote: Optional[str] = Field(None, alias="exactQuote", description="The exact quote from the source.")
    url: str = Field(..., description="URL of the citation.")
    dateTime: Optional[str] = Field(None, alias="dateTime", description="Timestamp associated with the citation.")

class Annotation(BaseModel):
    """Annotation within the response content, e.g., a URL citation."""
    type: str = Field(..., description="Type of annotation, e.g., 'url_citation'.")
    url_citation: Optional[URLCitation] = Field(None, description="Details if the annotation is a URL citation.")
    # Add other potential annotation types if known

# --- Input Model for chat_completion Tool ---

class ChatCompletionParams(BaseModel):
    """Input parameters for the chat_completion tool."""
    messages: List[Message] = Field(..., description="A list of messages comprising the conversation so far. Includes user queries and assistant responses. Can include text, images (webp, png, jpeg encoded as data URI), or files (txt, pdf encoded as data URI, up to 10MB).")
    model: str = Field(..., description="ID of the model to use. e.g., 'jina-deepsearch-v1'")
    stream: bool = Field(True, description="Whether to deliver events as they occur through server-sent events. Strongly recommended to keep enabled to avoid timeouts. The MCP tool will handle stream aggregation internally and return the final result.")
    reasoning_effort: Optional[str] = Field("medium", description="Constrains effort on reasoning. Supported values: 'low', 'medium', 'high'. Reducing effort can speed up responses and reduce token usage.")
    budget_tokens: Optional[int] = Field(None, description="Maximum number of tokens allowed for the DeepSearch process. Larger budgets may improve quality for complex queries. Overrides reasoning_effort.")
    max_attempts: Optional[int] = Field(None, description="Maximum number of retries for solving the problem using different approaches. Overrides reasoning_effort.")
    no_direct_answer: Optional[bool] = Field(False, description="Forces thinking/search steps even for trivial queries.")
    max_returned_urls: Optional[int] = Field(None, description="Maximum number of URLs to include in the final answer, sorted by relevance.")
    structured_output: Optional[Dict[str, Any]] = Field(None, description="Enables Structured Outputs, ensuring the final answer matches the supplied JSON schema.")
    good_domains: Optional[List[str]] = Field(None, description="List of domains to prioritize for content retrieval.")
    bad_domains: Optional[List[str]] = Field(None, description="List of domains to strictly exclude from content retrieval.")
    only_domains: Optional[List[str]] = Field(None, description="List of domains to exclusively include in content retrieval.")

    class Config:
        extra = 'ignore' # Ignore extra fields if provided

# --- Output Models for chat_completion Tool (Based on OpenAI structure + DeepSearch specifics) ---

class ResponseMessage(Message):
    """Message object within the response, potentially including annotations."""
    # DeepSearch might include annotations directly or indirectly.
    # Assuming content might contain markers or the API provides structured annotations separately.
    # For now, keeping it similar to input Message, but content might be structured differently in reality.
    pass

class ChatCompletionChoice(BaseModel):
    """A single choice generated by the model."""
    index: int
    message: ResponseMessage
    finish_reason: Optional[str] = Field(None, description="Reason the model stopped generating tokens.")
    # DeepSearch might add other fields here, like specific search metadata per choice.

class Usage(BaseModel):
    """Token usage statistics for the request."""
    prompt_tokens: Optional[int] = None
    completion_tokens: Optional[int] = None
    total_tokens: Optional[int] = None

class ChatCompletionResponse(BaseModel):
    """The final aggregated response from the DeepSearch process."""
    id: str = Field(..., description="A unique identifier for the chat completion.")
    object: str = Field(..., description="The object type, typically 'chat.completion'.")
    created: int = Field(..., description="The Unix timestamp (in seconds) of when the chat completion was created.")
    model: str = Field(..., description="The model used for the chat completion.")
    choices: List[ChatCompletionChoice] = Field(..., description="A list of chat completion choices. Usually one.")
    usage: Optional[Usage] = Field(None, description="Usage statistics for the completion request.")
    # Add specific DeepSearch fields if known, e.g., visited_urls
    # visited_urls: Optional[List[str]] = Field(None, description="List of URLs visited during the search process.")
    # Annotations might be embedded within message content or provided separately.

    class Config:
        extra = 'allow' # Allow extra fields from the API response

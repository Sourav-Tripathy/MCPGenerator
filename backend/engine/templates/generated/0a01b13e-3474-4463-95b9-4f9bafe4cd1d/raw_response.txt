{
  "files": [
    {
      "name": "main.py",
      "content": "import logging\nimport os\nfrom typing import Dict, Any\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import KiteConnectClient, KiteConnectError\nfrom models import PlaceOrderParams, ModifyOrderParams, OrderIdResponse\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"ZerodhaKiteConnect\",\n    description=\"MCP Server for interacting with the Zerodha Kite Connect API (v3) to manage trading orders and retrieve trade information. Allows placing, modifying, cancelling orders, and fetching order history and trades.\"\n)\n\n# Initialize Kite Connect Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_API_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n    # Optionally raise an error or exit if credentials are required at startup\n    # raise ValueError(\"API Key and Access Token are required.\")\n    kite_client = None # Or handle appropriately\nelse:\n    try:\n        kite_client = KiteConnectClient(api_key=api_key, access_token=access_token, base_url=base_url)\n        logger.info(\"KiteConnectClient initialized successfully.\")\n    except Exception as e:\n        logger.exception(\"Failed to initialize KiteConnectClient\")\n        kite_client = None\n\n@mcp.tool()\ndef place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\n\n    Args:\n        params: Order placement parameters including variety, tradingsymbol, exchange, etc.\n\n    Returns:\n        Dictionary containing the order_id of the placed order or an error message.\n    \"\"\"\n    if not kite_client:\n        logger.error(\"Kite client not initialized. Cannot place order.\")\n        return {\"error\": \"Kite client not initialized. Check credentials.\"}\n\n    logger.info(f\"Attempting to place order: {params.dict(exclude_none=True)}\")\n    try:\n        result = kite_client.place_order(params)\n        logger.info(f\"Order placed successfully: {result}\")\n        # Ensure the response matches the OrderIdResponse model structure\n        return OrderIdResponse(**result).dict()\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error placing order: {e}\")\n        return {\"error\": str(e), \"error_type\": e.__class__.__name__}\n    except Exception as e:\n        logger.exception(\"Unexpected error placing order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\", \"error_type\": \"ServerError\"}\n\n@mcp.tool()\ndef modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modify attributes of a pending regular or cover order (CO).\n\n    Args:\n        params: Order modification parameters including variety, order_id, and fields to modify.\n\n    Returns:\n        Dictionary containing the order_id of the modified order or an error message.\n    \"\"\"\n    if not kite_client:\n        logger.error(\"Kite client not initialized. Cannot modify order.\")\n        return {\"error\": \"Kite client not initialized. Check credentials.\"}\n\n    logger.info(f\"Attempting to modify order: {params.dict(exclude_none=True)}\")\n    try:\n        result = kite_client.modify_order(params)\n        logger.info(f\"Order modified successfully: {result}\")\n        # Ensure the response matches the OrderIdResponse model structure\n        return OrderIdResponse(**result).dict()\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error modifying order: {e}\")\n        return {\"error\": str(e), \"error_type\": e.__class__.__name__}\n    except Exception as e:\n        logger.exception(\"Unexpected error modifying order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\", \"error_type\": \"ServerError\"}\n\n\nif __name__ == \"__main__\":\n    if not kite_client:\n        print(\"ERROR: Kite client could not be initialized. Please check logs and environment variables.\")\n    else:\n        # Note: FastMCP doesn't have a direct run method like Flask/FastAPI.\n        # You typically run it using a command like:\n        # mcp run main:mcp --port 8000\n        # This block is mostly for informational purposes or potential future direct run capabilities.\n        print(\"MCP server defined. Run using: mcp run main:mcp --port <your_port>\")\n        # To run programmatically (if needed, requires uvicorn):\n        # import uvicorn\n        # uvicorn.run(mcp.build_app(), host=\"0.0.0.0\", port=8000)\n"
    },
    {
      "name": "models.py",
      "content": "from typing import Optional, Literal\nfrom pydantic import BaseModel, Field, validator, root_validator\n\n# --- Common Response Models ---\n\nclass OrderIdResponse(BaseModel):\n    \"\"\"Standard response containing an order ID.\"\"\"\n    order_id: str = Field(..., description=\"The unique order ID.\")\n\n# --- Input Models for Tools ---\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\"\"\"\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., 'INFY', 'NIFTY23JULCE')\")\n    exchange: Literal['NSE', 'BSE', 'NFO', 'MCX', 'CDS', 'BFO'] = Field(..., description=\"Name of the exchange\")\n    transaction_type: Literal['BUY', 'SELL'] = Field(..., description=\"'BUY' or 'SELL'\")\n    order_type: Literal['MARKET', 'LIMIT', 'SL', 'SL-M'] = Field(..., description=\"Order type\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact\")\n    product: Literal['CNC', 'NRML', 'MIS', 'MTF'] = Field(..., description=\"Product type ('CNC', 'NRML', 'MIS', 'MTF')\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades)\")\n    validity: Literal['DAY', 'IOC', 'TTL'] = Field('DAY', description=\"Order validity ('DAY', 'IOC', 'TTL')\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders (1-120)\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10)\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order\")\n    auction_number: Optional[str] = Field(None, description=\"Unique identifier for a specific auction (for auction orders)\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"Optional tag for the order (alphanumeric, max 20 chars)\")\n\n    @root_validator\n    def check_conditional_fields(cls, values):\n        order_type = values.get('order_type')\n        price = values.get('price')\n        trigger_price = values.get('trigger_price')\n        validity = values.get('validity')\n        validity_ttl = values.get('validity_ttl')\n        variety = values.get('variety')\n        iceberg_legs = values.get('iceberg_legs')\n        iceberg_quantity = values.get('iceberg_quantity')\n        auction_number = values.get('auction_number')\n\n        if order_type == 'LIMIT' and price is None:\n            raise ValueError(\"Price is required for LIMIT orders\")\n        if order_type in ('SL', 'SL-M') and trigger_price is None:\n            raise ValueError(\"Trigger price is required for SL and SL-M orders\")\n        if validity == 'TTL' and validity_ttl is None:\n            raise ValueError(\"validity_ttl is required for TTL validity\")\n        if validity == 'TTL' and (validity_ttl is None or not (1 <= validity_ttl <= 120)):\n             raise ValueError(\"validity_ttl must be between 1 and 120 for TTL validity\")\n        if variety == 'iceberg' and (iceberg_legs is None or iceberg_quantity is None):\n            raise ValueError(\"iceberg_legs and iceberg_quantity are required for iceberg orders\")\n        if variety == 'iceberg' and iceberg_legs is not None and not (2 <= iceberg_legs <= 10):\n            raise ValueError(\"iceberg_legs must be between 2 and 10\")\n        if variety == 'auction' and auction_number is None:\n             raise ValueError(\"auction_number is required for auction orders\")\n\n        # CO specific checks (can add more if needed)\n        if variety == 'co' and order_type not in ('LIMIT', 'MARKET'):\n            raise ValueError(\"Cover orders (co) must be MARKET or LIMIT\")\n        if variety == 'co' and trigger_price is None:\n            raise ValueError(\"Trigger price is required for Cover Orders (co)\")\n\n        return values\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Parameters for modifying a pending order.\"\"\"\n    variety: Literal['regular', 'co'] = Field(..., description=\"Order variety ('regular', 'co')\")\n    order_id: str = Field(..., description=\"The ID of the order to modify\")\n    parent_order_id: Optional[str] = Field(None, description=\"The parent order ID (required for modifying second leg of CO)\")\n    order_type: Optional[Literal['LIMIT', 'SL', 'SL-M']] = Field(None, description=\"New order type (only for regular orders)\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity (only for regular orders)\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders, both regular and CO)\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M regular orders; required for LIMIT CO modification)\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (only for regular equity orders)\")\n    validity: Optional[Literal['DAY', 'IOC']] = Field(None, description=\"New validity ('DAY', 'IOC') (only for regular orders)\")\n\n    @root_validator\n    def check_modify_conditions(cls, values):\n        variety = values.get('variety')\n        parent_order_id = values.get('parent_order_id')\n        order_type = values.get('order_type')\n        quantity = values.get('quantity')\n        price = values.get('price')\n        trigger_price = values.get('trigger_price')\n        validity = values.get('validity')\n\n        if variety == 'co' and parent_order_id is None:\n            # Modifying the main leg of CO\n            if order_type is not None or quantity is not None or validity is not None:\n                raise ValueError(\"Cannot modify order_type, quantity, or validity for the main leg of a CO order\")\n            if price is None and trigger_price is None:\n                 raise ValueError(\"Either price or trigger_price must be provided when modifying a CO order\")\n        elif variety == 'co' and parent_order_id is not None:\n             # Modifying the SL leg of CO\n             if order_type is not None or quantity is not None or validity is not None or price is not None:\n                 raise ValueError(\"Only trigger_price can be modified for the second leg of a CO order\")\n             if trigger_price is None:\n                  raise ValueError(\"trigger_price is required when modifying the second leg of a CO order\")\n\n        if variety == 'regular':\n            if order_type == 'LIMIT' and price is None:\n                # If changing to LIMIT, price is needed. If already LIMIT, price might be optional if not changing it.\n                # Kite API might require it anyway, best to include if modifying price.\n                pass # Let API handle this potentially complex validation\n            if order_type in ('SL', 'SL-M') and trigger_price is None:\n                # Similar logic for trigger_price\n                pass # Let API handle\n\n        return values\n"
    },
    {
      "name": "client.py",
      "content": "import logging\nfrom typing import Dict, Any, Optional\n\nimport httpx\nfrom tenacity import retry, stop_after_attempt, wait_fixed, retry_if_exception_type\n\nfrom models import PlaceOrderParams, ModifyOrderParams\n\nlogger = logging.getLogger(__name__)\n\n# --- Custom Exceptions ---\n\nclass KiteConnectError(Exception):\n    \"\"\"Base exception for Kite Connect client errors.\"\"\"\n    def __init__(self, message=\"An error occurred with the Kite Connect API\", status_code: Optional[int] = None, error_type: Optional[str] = None):\n        self.message = message\n        self.status_code = status_code\n        self.error_type = error_type # Kite specific error type if available\n        super().__init__(self.message)\n\n    def __str__(self):\n        return f\"{self.__class__.__name__}(status_code={self.status_code}, error_type={self.error_type}): {self.message}\"\n\nclass AuthenticationError(KiteConnectError):\n    \"\"\"Error related to authentication (invalid API key, access token).\"\"\"\n    pass\n\nclass ValidationError(KiteConnectError):\n    \"\"\"Error related to invalid input parameters.\"\"\"\n    pass\n\nclass OrderNotFoundOrCompletedError(KiteConnectError):\n    \"\"\"Error when trying to modify/cancel an order that doesn't exist or is already completed.\"\"\"\n    pass\n\nclass InsufficientFundsError(KiteConnectError):\n    \"\"\"Error due to insufficient funds or margin.\"\"\"\n    pass\n\nclass NetworkError(KiteConnectError):\n    \"\"\"Error related to network connectivity issues.\"\"\"\n    pass\n\nclass RateLimitError(KiteConnectError):\n    \"\"\"Error due to exceeding API rate limits.\"\"\"\n    pass\n\nclass ExchangeError(KiteConnectError):\n    \"\"\"Error reported by the exchange.\"\"\"\n    pass\n\nclass GeneralAPIError(KiteConnectError):\n    \"\"\"General or unknown errors from the Kite API.\"\"\"\n    pass\n\n# --- Kite Connect Client ---\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Zerodha Kite Connect API v3.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        \"\"\"Initialize the client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after successful login.\n            base_url: The base URL for the Kite Connect API.\n            timeout: Default request timeout in seconds.\n        \"\"\"\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.timeout = timeout\n        self._headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form data\n        }\n        self._client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self._headers,\n            timeout=self.timeout\n        )\n        logger.info(f\"KiteConnectClient initialized for base URL: {self.base_url}\")\n\n    def _map_error(self, status_code: int, response_data: Optional[Dict[str, Any]] = None) -> KiteConnectError:\n        \"\"\"Maps HTTP status codes and response data to specific KiteConnectError exceptions.\"\"\"\n        message = \"Unknown API error\"\n        error_type = \"UnknownError\"\n        if response_data and isinstance(response_data.get('message'), str):\n            message = response_data['message']\n        if response_data and isinstance(response_data.get('error_type'), str):\n            error_type = response_data['error_type']\n\n        if status_code == 400:\n            # Often validation errors, but can be others\n            if error_type == \"InputException\":\n                return ValidationError(message, status_code, error_type)\n            elif error_type == \"OrderException\": # e.g., margin errors\n                 # Check for specific messages if needed\n                 if \"margin\" in message.lower() or \"funds\" in message.lower():\n                      return InsufficientFundsError(message, status_code, error_type)\n                 return ExchangeError(message, status_code, error_type)\n            return ValidationError(message, status_code, error_type) # Default to validation for 400\n        elif status_code == 403:\n            return AuthenticationError(message, status_code, error_type)\n        elif status_code == 404:\n            return OrderNotFoundOrCompletedError(message, status_code, error_type)\n        elif status_code == 429:\n            return RateLimitError(message, status_code, error_type)\n        elif status_code == 500:\n            return GeneralAPIError(message, status_code, error_type)\n        elif status_code == 502 or status_code == 503 or status_code == 504:\n             return ExchangeError(f\"Exchange/Gateway Error: {message}\", status_code, error_type)\n        else:\n            return GeneralAPIError(f\"Unexpected HTTP status {status_code}: {message}\", status_code, error_type)\n\n    @retry(stop=stop_after_attempt(3), wait=wait_fixed(2), retry=retry_if_exception_type((NetworkError, RateLimitError)))\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous request to the Kite API with error handling and retries.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Making request: {method} {url}, Data: {data}\")\n\n        try:\n            response = await self._client.request(method, endpoint, data=data)\n            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx\n            json_response = response.json()\n            if json_response.get(\"status\") == \"error\":\n                logger.warning(f\"API returned error status: {json_response}\")\n                raise self._map_error(response.status_code, json_response)\n            logger.debug(f\"Request successful: {response.status_code}\")\n            # Kite API often wraps successful responses in a 'data' field\n            return json_response.get(\"data\", {})\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out: {method} {url} - {e}\")\n            raise NetworkError(f\"Request timed out: {e}\", error_type=\"Timeout\")\n        except httpx.NetworkError as e:\n            logger.error(f\"Network error during request: {method} {url} - {e}\")\n            raise NetworkError(f\"Network error: {e}\", error_type=\"NetworkException\")\n        except httpx.HTTPStatusError as e:\n            logger.error(f\"HTTP error: {e.response.status_code} for {method} {url}. Response: {e.response.text}\")\n            try:\n                response_data = e.response.json()\n            except Exception:\n                response_data = {\"message\": e.response.text, \"error_type\": \"UnknownHttpError\"}\n            raise self._map_error(e.response.status_code, response_data)\n        except KiteConnectError as e: # Re-raise specific mapped errors\n             raise e\n        except Exception as e:\n            logger.exception(f\"Unexpected error during request: {method} {url}\")\n            raise GeneralAPIError(f\"An unexpected error occurred: {str(e)}\", error_type=\"ClientException\")\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, Any]:\n        \"\"\"Place an order.\n\n        Args:\n            params: PlaceOrderParams object containing order details.\n\n        Returns:\n            Dictionary containing the order_id.\n\n        Raises:\n            KiteConnectError: If the API call fails.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Convert Pydantic model to dict, removing None values\n        data = params.dict(exclude={'variety'}, exclude_none=True)\n        logger.info(f\"Placing order to {endpoint} with data: {data}\")\n        return await self._request(\"POST\", endpoint, data=data)\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, Any]:\n        \"\"\"Modify a pending order.\n\n        Args:\n            params: ModifyOrderParams object containing modification details.\n\n        Returns:\n            Dictionary containing the order_id.\n\n        Raises:\n            KiteConnectError: If the API call fails.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Convert Pydantic model to dict, removing None values and path params\n        data = params.dict(exclude={'variety', 'order_id'}, exclude_none=True)\n        logger.info(f\"Modifying order {params.order_id} ({params.variety}) at {endpoint} with data: {data}\")\n        return await self._request(\"PUT\", endpoint, data=data)\n\n    async def close(self):\n        \"\"\"Close the underlying HTTPX client.\"\"\"\n        await self._client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0,<0.2.0\nhttpx[http2]>=0.25.0,<0.28.0\npydantic>=1.10.0,<2.8.0\npython-dotenv>=1.0.0,<2.0.0\nuvicorn>=0.23.0,<0.30.0\ntenacity>=8.0.0,<9.0.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Zerodha Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer Console: https://developers.kite.trade/\n\n# Your Kite Connect API Key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# Your Kite Connect Access Token (This is short-lived and needs to be generated regularly)\n# See Kite Connect documentation for the login flow: https://kite.trade/docs/connect/v3/user/\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# Base URL for the Kite Connect API (usually doesn't need changing)\nKITE_API_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Zerodha Kite Connect MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect API (v3). It allows language models or other applications to manage trading orders through a standardized interface.\n\n## Features\n\n*   **Place Orders:** Place various types of orders (regular, AMO, CO, Iceberg, Auction).\n*   **Modify Orders:** Modify attributes of pending regular or cover orders.\n*   **Asynchronous:** Built with `httpx` for non-blocking API calls.\n*   **Typed:** Uses Pydantic models for clear request/response structures and validation.\n*   **Error Handling:** Maps Kite Connect API errors to specific Python exceptions.\n*   **Configurable:** Uses environment variables for API credentials.\n\n## Implemented Tools\n\n*   `place_order(params: PlaceOrderParams) -> OrderIdResponse`\n    *   Places a new trading order.\n    *   Input: `PlaceOrderParams` model (includes variety, tradingsymbol, exchange, transaction\_type, order\_type, quantity, product, etc.)\n    *   Output: `OrderIdResponse` model (contains the `order_id`).\n*   `modify_order(params: ModifyOrderParams) -> OrderIdResponse`\n    *   Modifies an existing pending order.\n    *   Input: `ModifyOrderParams` model (includes variety, order\_id, and fields to modify like quantity, price, trigger\_price).\n    *   Output: `OrderIdResponse` model (contains the `order_id`).\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure environment variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Zerodha Kite Connect API credentials:\n        *   `KITE_API_KEY`: Your application's API key.\n        *   `KITE_ACCESS_TOKEN`: A valid access token. **Note:** Access tokens are short-lived and need to be generated periodically through the Kite Connect login flow (see [Kite Connect User API Docs](https://kite.trade/docs/connect/v3/user/)). This server assumes a valid token is provided via the environment variable.\n        *   `KITE_API_BASE_URL` (Optional): Defaults to `https://api.kite.trade`.\n\n## Running the Server\n\nUse the `mcp` command-line tool (installed with `fastmcp`) to run the server:\n\n```bash\nmcp run main:mcp --port 8000\n```\n\nReplace `8000` with your desired port number.\nThe server will start, and the MCP tools (`place_order`, `modify_order`) will be available for interaction.\n\n## Authentication\n\nAuthentication with the Kite Connect API is handled via the `KITE_API_KEY` and `KITE_ACCESS_TOKEN` provided in the `.env` file. Ensure the `KITE_ACCESS_TOKEN` is valid and refreshed as needed.\n\n## Error Handling\n\nThe client (`client.py`) attempts to map common HTTP status codes and Kite API error responses (`error_type` field in JSON response) to specific Python exceptions (e.g., `AuthenticationError`, `ValidationError`, `InsufficientFundsError`, `RateLimitError`). Tools in `main.py` catch these exceptions and return a JSON object with an `\"error\"` key and often an `\"error_type\"` key.\n\n## Rate Limits\n\nThe Kite Connect API has rate limits (e.g., 10 requests per second for order placement/modification). The client includes basic retry logic for rate limit errors (`RateLimitError`) and network issues (`NetworkError`) using the `tenacity` library. However, sustained high traffic might still hit limits. Implement more sophisticated rate limiting strategies if required.\n\n## Environment Variables\n\n*   `KITE_API_KEY` (Required): Your Kite Connect API key.\n*   `KITE_ACCESS_TOKEN` (Required): Your Kite Connect access token.\n*   `KITE_API_BASE_URL` (Optional): The base URL for the Kite API. Defaults to `https://api.kite.trade`.\n"
    }
  ]
}
{
  "files": [
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field\nfrom typing import Optional, Dict\nfrom enum import Enum\n\n# --- Enums based on Kite Connect API --- #\n\nclass VarietyEnum(str, Enum):\n    REGULAR = \"regular\"\n    AMO = \"amo\"\n    CO = \"co\"\n    ICEBERG = \"iceberg\"\n    AUCTION = \"auction\"\n\nclass ExchangeEnum(str, Enum):\n    NSE = \"NSE\"\n    BSE = \"BSE\"\n    NFO = \"NFO\"\n    MCX = \"MCX\"\n    CDS = \"CDS\"\n    BFO = \"BFO\"\n    BCD = \"BCD\"\n\nclass TransactionTypeEnum(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n\nclass OrderTypeEnum(str, Enum):\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n    SL = \"SL\"\n    SLM = \"SL-M\"\n\nclass ProductEnum(str, Enum):\n    CNC = \"CNC\"\n    NRML = \"NRML\"\n    MIS = \"MIS\"\n    MTF = \"MTF\"\n\nclass ValidityEnum(str, Enum):\n    DAY = \"DAY\"\n    IOC = \"IOC\"\n    TTL = \"TTL\"\n\n# --- Input Models for Tools --- #\n\nclass PlaceOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety ('regular', 'amo', 'co', 'iceberg', 'auction')\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., 'SBIN')\")\n    exchange: ExchangeEnum = Field(..., description=\"Name of the exchange (e.g., 'NSE', 'BSE', 'NFO')\")\n    transaction_type: TransactionTypeEnum = Field(..., description=\"Transaction type ('BUY' or 'SELL')\")\n    order_type: OrderTypeEnum = Field(..., description=\"Order type ('MARKET', 'LIMIT', 'SL', 'SL-M')\")\n    quantity: int = Field(..., description=\"Quantity to transact\")\n    product: ProductEnum = Field(..., description=\"Product type ('CNC', 'NRML', 'MIS', 'MTF')\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades)\")\n    validity: ValidityEnum = Field(..., description=\"Order validity ('DAY', 'IOC', 'TTL')\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10)\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs)\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction\")\n    tag: Optional[str] = Field(None, description=\"Optional tag for the order (alphanumeric, max 20 chars)\")\n\nclass ModifyOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety ('regular', 'co', etc.)\")\n    order_id: str = Field(..., description=\"The ID of the order to modify\")\n    parent_order_id: Optional[str] = Field(None, description=\"The parent order ID if modifying a second-leg CO order (usually not needed for standard modification)\")\n    order_type: Optional[OrderTypeEnum] = Field(None, description=\"New order type (Regular orders only)\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (Regular orders only)\")\n    price: Optional[float] = Field(None, description=\"New price (Regular LIMIT orders)\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (Regular SL/SL-M or CO orders)\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (Regular equity orders only)\")\n    validity: Optional[ValidityEnum] = Field(None, description=\"New validity (Regular orders only, typically DAY or IOC)\")\n\n# --- Output/Response Models --- #\n\nclass OrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID.\")\n\nclass ErrorResponse(BaseModel):\n    status: str = Field(\"error\", description=\"Indicates an error occurred.\")\n    message: str = Field(..., description=\"Description of the error.\")\n    error_type: Optional[str] = Field(None, description=\"Category of the error (e.g., InputException, TokenException).\")\n    data: Optional[Dict] = Field(None, description=\"Additional error data, if available.\")\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nimport os\nfrom typing import Dict, Any, Optional, Union\nfrom models import PlaceOrderParams, ModifyOrderParams, OrderResponse, ErrorResponse, VarietyEnum\n\nlogger = logging.getLogger(__name__)\n\nclass KiteConnectError(Exception):\n    \"\"\"Base exception class for Kite Connect client errors.\"\"\"\n    def __init__(self, message: str, status_code: Optional[int] = None, error_type: Optional[str] = None):\n        self.message = message\n        self.status_code = status_code\n        self.error_type = error_type\n        super().__init__(self.message)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"status\": \"error\",\n            \"message\": self.message,\n            \"error_type\": self.error_type or self.__class__.__name__,\n            \"status_code\": self.status_code\n        }\n\nclass AuthenticationError(KiteConnectError):\n    \"\"\"Raised for authentication failures (403 Forbidden).\"\"\"\n    pass\n\nclass BadRequestError(KiteConnectError):\n    \"\"\"Raised for general 4xx client errors (e.g., invalid input).\"\"\"\n    pass\n\nclass RateLimitError(KiteConnectError):\n    \"\"\"Raised for 429 Too Many Requests errors.\"\"\"\n    pass\n\nclass ServerError(KiteConnectError):\n    \"\"\"Raised for 5xx server errors.\"\"\"\n    pass\n\nclass NetworkError(KiteConnectError):\n    \"\"\"Raised for network-related issues (timeouts, connection errors).\"\"\"\n    pass\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect Orders API (v3).\"\"\"\n\n    def __init__(self):\n        self.api_key = os.getenv(\"KITE_API_KEY\")\n        self.access_token = os.getenv(\"KITE_ACCESS_TOKEN\")\n        self.base_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n        self.api_version = \"3\"\n\n        if not self.api_key or not self.access_token:\n            raise ValueError(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n\n        self.headers = {\n            \"X-Kite-Version\": self.api_version,\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite API uses form encoding\n        }\n        # Increased timeout for potentially slower trading operations\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=30.0\n        )\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite Connect API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.info(f\"Making Kite API request: {method} {url}\")\n        if data:\n            # Filter out None values before sending\n            payload = {k: v for k, v in data.items() if v is not None}\n            logger.debug(f\"Request payload: {payload}\")\n        else:\n            payload = None\n\n        try:\n            response = await self.client.request(method, endpoint, data=payload)\n\n            # Check for specific Kite Connect error structure in JSON response\n            try:\n                json_response = response.json()\n                if isinstance(json_response, dict) and json_response.get(\"status\") == \"error\":\n                    error_message = json_response.get(\"message\", \"Unknown API error\")\n                    error_type = json_response.get(\"error_type\", \"APIError\")\n                    logger.error(f\"Kite API Error ({response.status_code}): {error_message} (Type: {error_type})\")\n                    # Map Kite error types to custom exceptions if needed, or raise a general one\n                    if response.status_code == 403:\n                         raise AuthenticationError(error_message, response.status_code, error_type)\n                    elif response.status_code == 429:\n                         raise RateLimitError(error_message, response.status_code, error_type)\n                    elif 400 <= response.status_code < 500:\n                         raise BadRequestError(error_message, response.status_code, error_type)\n                    else:\n                         raise KiteConnectError(error_message, response.status_code, error_type)\n            except ValueError: # Handle cases where response is not valid JSON\n                pass # Let raise_for_status handle non-JSON errors\n\n            response.raise_for_status() # Raise HTTPError for 4xx/5xx status codes if not caught above\n            logger.info(f\"Kite API request successful ({response.status_code})\")\n            return response.json()\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Kite API request timed out: {e}\")\n            raise NetworkError(f\"Request timed out: {e}\", error_type=\"TimeoutError\")\n        except httpx.RequestError as e:\n            logger.error(f\"Kite API request network error: {e}\")\n            raise NetworkError(f\"Network error during request: {e}\", error_type=\"NetworkException\")\n        except httpx.HTTPStatusError as e:\n            logger.error(f\"Kite API HTTP error: {e.response.status_code} - {e.response.text}\")\n            if e.response.status_code == 403:\n                raise AuthenticationError(f\"Authentication failed: {e.response.text}\", e.response.status_code, \"TokenException\")\n            elif e.response.status_code == 400:\n                 raise BadRequestError(f\"Bad request: {e.response.text}\", e.response.status_code, \"InputException\")\n            elif e.response.status_code == 429:\n                raise RateLimitError(f\"Rate limit exceeded: {e.response.text}\", e.response.status_code, \"RateLimitError\")\n            elif 500 <= e.response.status_code < 600:\n                raise ServerError(f\"Kite API server error: {e.response.text}\", e.response.status_code, \"GeneralException\")\n            else:\n                raise KiteConnectError(f\"HTTP error: {e.response.text}\", e.response.status_code, \"HTTPError\")\n        except KiteConnectError: # Re-raise errors caught and processed from JSON response\n             raise\n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during Kite API request: {e}\")\n            raise KiteConnectError(f\"An unexpected error occurred: {str(e)}\", error_type=\"UnexpectedError\")\n\n    async def place_order(self, params: PlaceOrderParams) -> Union[OrderResponse, ErrorResponse]:\n        \"\"\"Places an order with the specified parameters.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}\"\n        try:\n            # Convert Pydantic model to dict, excluding 'variety' as it's in the path\n            data = params.dict(exclude={'variety'}, exclude_none=True)\n            response_data = await self._request(\"POST\", endpoint, data=data)\n\n            # Kite API returns {'status': 'success', 'data': {'order_id': '...'}}\n            if response_data.get(\"status\") == \"success\" and \"data\" in response_data and \"order_id\" in response_data[\"data\"]:\n                return OrderResponse(order_id=response_data[\"data\"][\"order_id\"])\n            else:\n                logger.error(f\"Unexpected successful response format from place_order: {response_data}\")\n                # Attempt to parse as error just in case\n                if response_data.get(\"status\") == \"error\":\n                     return ErrorResponse(\n                         message=response_data.get(\"message\", \"Unknown error during order placement.\"),\n                         error_type=response_data.get(\"error_type\", \"OrderException\")\n                     )\n                # Fallback error\n                return ErrorResponse(message=\"Order placement status unknown or failed. Unexpected response format.\", error_type=\"UnexpectedResponse\")\n\n        except KiteConnectError as e:\n            logger.error(f\"Failed to place order: {e.message} (Type: {e.error_type}, Code: {e.status_code})\")\n            return ErrorResponse(message=e.message, error_type=e.error_type)\n        except Exception as e:\n            logger.exception(\"Unexpected error in place_order tool execution\")\n            return ErrorResponse(message=f\"An unexpected server error occurred: {str(e)}\", error_type=\"InternalServerError\")\n\n    async def modify_order(self, params: ModifyOrderParams) -> Union[OrderResponse, ErrorResponse]:\n        \"\"\"Modifies a pending order with the specified parameters.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}/{params.order_id}\"\n        try:\n            # Convert Pydantic model to dict, excluding 'variety' and 'order_id'\n            data = params.dict(exclude={'variety', 'order_id'}, exclude_none=True)\n            response_data = await self._request(\"PUT\", endpoint, data=data)\n\n            # Kite API returns {'status': 'success', 'data': {'order_id': '...'}}\n            if response_data.get(\"status\") == \"success\" and \"data\" in response_data and \"order_id\" in response_data[\"data\"]:\n                # Modification successful, returns the same order_id\n                return OrderResponse(order_id=response_data[\"data\"][\"order_id\"])\n            else:\n                logger.error(f\"Unexpected successful response format from modify_order: {response_data}\")\n                if response_data.get(\"status\") == \"error\":\n                     return ErrorResponse(\n                         message=response_data.get(\"message\", \"Unknown error during order modification.\"),\n                         error_type=response_data.get(\"error_type\", \"OrderException\")\n                     )\n                return ErrorResponse(message=\"Order modification status unknown or failed. Unexpected response format.\", error_type=\"UnexpectedResponse\")\n\n        except KiteConnectError as e:\n            logger.error(f\"Failed to modify order {params.order_id}: {e.message} (Type: {e.error_type}, Code: {e.status_code})\")\n            return ErrorResponse(message=e.message, error_type=e.error_type)\n        except Exception as e:\n            logger.exception(f\"Unexpected error in modify_order tool execution for order {params.order_id}\")\n            return ErrorResponse(message=f\"An unexpected server error occurred: {str(e)}\", error_type=\"InternalServerError\")\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"Kite Connect client closed.\")\n"
    },
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, Union\nimport logging\nimport os\nfrom dotenv import load_dotenv\nimport asyncio\n\nfrom models import PlaceOrderParams, ModifyOrderParams, OrderResponse, ErrorResponse\nfrom client import KiteConnectClient, KiteConnectError\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# --- MCP Server Initialization --- #\n\nmcp = FastMCP(\n    service_name=\"kite_connect_orders\",\n    description=\"MCP service for interacting with the Kite Connect Orders API (v3) to place and modify stock market orders.\"\n)\n\n# --- Global API Client --- #\n# Initialize the client globally or manage its lifecycle if needed (e.g., startup/shutdown events)\nkite_client: KiteConnectClient\n\n@mcp.on_event(\"startup\")\nasync def startup_event():\n    global kite_client\n    try:\n        kite_client = KiteConnectClient()\n        logger.info(\"Kite Connect client initialized successfully.\")\n    except ValueError as e:\n        logger.error(f\"Failed to initialize Kite Connect client: {e}\")\n        # Depending on the desired behavior, you might want to exit or prevent startup\n        raise RuntimeError(f\"Client initialization failed: {e}\") from e\n    except Exception as e:\n        logger.exception(\"Unexpected error during Kite Connect client initialization.\")\n        raise RuntimeError(\"Unexpected error during client initialization\") from e\n\n@mcp.on_event(\"shutdown\")\nasync def shutdown_event():\n    global kite_client\n    if kite_client:\n        await kite_client.close()\n        logger.info(\"Kite Connect client shut down gracefully.\")\n\n# --- MCP Tools --- #\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Places an order of a specified variety (regular, amo, co, iceberg, auction). Does not guarantee execution.\n\n    Args:\n        params (PlaceOrderParams): Parameters for placing the order.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing the 'order_id' on success, or an error structure on failure.\n    \"\"\"\n    logger.info(f\"Received place_order request: {params.dict(exclude_none=True)}\")\n    try:\n        result = await kite_client.place_order(params)\n        return result.dict()\n    except AttributeError:\n        # Handle case where kite_client might not be initialized if startup failed\n        logger.error(\"Kite client not available for place_order.\")\n        return ErrorResponse(message=\"Kite client not initialized.\", error_type=\"ConfigurationError\").dict()\n    except Exception as e:\n        # Catch any unexpected errors during the tool execution itself\n        logger.exception(\"Unexpected error executing place_order tool.\")\n        return ErrorResponse(message=f\"Internal server error: {str(e)}\", error_type=\"InternalServerError\").dict()\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modifies attributes of a pending order (e.g., quantity, price). For Cover Orders (CO), only trigger_price can be modified.\n\n    Args:\n        params (ModifyOrderParams): Parameters for modifying the order.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing the 'order_id' on success (confirming modification), or an error structure on failure.\n    \"\"\"\n    logger.info(f\"Received modify_order request for order_id {params.order_id}: {params.dict(exclude={'order_id'}, exclude_none=True)}\")\n    try:\n        result = await kite_client.modify_order(params)\n        return result.dict()\n    except AttributeError:\n        logger.error(\"Kite client not available for modify_order.\")\n        return ErrorResponse(message=\"Kite client not initialized.\", error_type=\"ConfigurationError\").dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error executing modify_order tool for order {params.order_id}.\")\n        return ErrorResponse(message=f\"Internal server error: {str(e)}\", error_type=\"InternalServerError\").dict()\n\n\n# --- Main Execution --- #\n\nif __name__ == \"__main__\":\n    # FastMCP automatically handles running the Uvicorn server\n    # You might need to configure host and port if defaults are not suitable\n    # Example: mcp.run(host=\"0.0.0.0\", port=8000)\n    mcp.run()\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.2.0\npydantic>=1.9.0,<2.0.0\nhttpx>=0.23.0\npython-dotenv>=0.20.0\nuvicorn>=0.17.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials\n# Obtain these from your Kite Developer Console (https://developers.kite.trade/)\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# This is a short-lived token obtained after a successful login flow\n# See Kite Connect documentation for how to generate this\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# Optional: Base URL for the Kite Connect API (defaults to https://api.kite.trade if not set)\n# KITE_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect Orders API (v3). It allows language models or other agents to place and modify stock market orders through a standardized interface.\n\n## Features\n\n*   **Place Orders:** Supports placing various order types (regular, AMO, CO, Iceberg, Auction) via the `place_order` tool.\n*   **Modify Orders:** Supports modifying pending orders (quantity, price, trigger price, etc.) via the `modify_order` tool.\n*   **Typed Interface:** Uses Pydantic models for clear and validated input parameters.\n*   **Asynchronous:** Built with `asyncio` and `httpx` for efficient I/O operations.\n*   **Error Handling:** Captures and reports common API errors (authentication, rate limits, input errors, server errors).\n*   **Configuration:** Uses environment variables for API credentials.\n\n## Prerequisites\n\n*   Python 3.8+\n*   A Zerodha Kite Connect API key and a valid access token. You can get these from the [Kite Developer Console](https://developers.kite.trade/).\n*   Understanding of the Kite Connect API v3, especially order parameters and potential error conditions.\n\n## Setup\n\n1.  **Clone the repository (or create the files):**\n    ```bash\n    # If cloned\n    git clone <repository_url>\n    cd kite_connect_mcp\n    ```\n\n2.  **Create a virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure environment variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect `API_KEY` and `ACCESS_TOKEN`:\n        ```dotenv\n        KITE_API_KEY=\"YOUR_ACTUAL_API_KEY\"\n        KITE_ACCESS_TOKEN=\"YOUR_GENERATED_ACCESS_TOKEN\"\n        # KITE_BASE_URL=\"https://api.kite.trade\" # Optional\n        ```\n    *   **Important:** The `ACCESS_TOKEN` is short-lived and needs to be generated regularly using the Kite Connect login flow. This MCP server assumes a valid token is provided via the environment variable.\n\n## Running the Server\n\nStart the MCP server using:\n\n```bash\npip install uvicorn # If not already installed via requirements\npython main.py\n```\n\nBy default, the server will run on `http://127.0.0.1:8080` (FastMCP's default). You can check the server logs for the exact address.\n\nThe server exposes the following endpoints for MCP interaction:\n\n*   `GET /` : Returns the MCP manifest describing the service and tools.\n*   `POST /invoke/{tool_name}`: Executes the specified tool.\n\n## Available Tools\n\n### 1. `place_order`\n\nPlaces a new order.\n\n*   **Description:** Places an order of a specified variety (regular, amo, co, iceberg, auction). Does not guarantee execution.\n*   **Input Model:** `PlaceOrderParams` (see `models.py` for fields like `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, `validity`, etc.)\n*   **Returns:** A dictionary containing `{\"order_id\": \"<order_id>\"}` on success, or an error dictionary (`{\"status\": \"error\", \"message\": \"...\", \"error_type\": \"...\"}`) on failure.\n\n### 2. `modify_order`\n\nModifies an existing pending order.\n\n*   **Description:** Modifies attributes of a pending regular order (e.g., quantity, price). For Cover Orders (CO), only trigger_price can be modified.\n*   **Input Model:** `ModifyOrderParams` (see `models.py` for fields like `variety`, `order_id`, `quantity`, `price`, `trigger_price`, etc.)\n*   **Returns:** A dictionary containing `{\"order_id\": \"<order_id>\"}` on successful modification, or an error dictionary on failure.\n\n## Error Handling\n\nThe client (`client.py`) attempts to catch various errors:\n\n*   **Authentication Errors:** Invalid `api_key` or `access_token` (HTTP 403).\n*   **Bad Request Errors:** Invalid input parameters (HTTP 400, Kite `InputException`).\n*   **Rate Limit Errors:** Exceeding API request limits (HTTP 429).\n*   **Server Errors:** Issues on the Kite Connect server side (HTTP 5xx).\n*   **Network Errors:** Timeouts or connection problems.\n*   **API-Specific Errors:** Errors returned in the JSON response body by Kite (e.g., `OrderException`, `TokenException`).\n\nErrors are returned to the MCP caller in a structured format:\n\n```json\n{\n  \"status\": \"error\",\n  \"message\": \"Descriptive error message\",\n  \"error_type\": \"ErrorCategory\" // e.g., AuthenticationError, BadRequestError, RateLimitError, APIError\n}\n```\n\n## Important Considerations\n\n*   **Access Token Management:** This server requires a *pre-generated*, valid `access_token`. Implementing the full OAuth2 login flow to generate this token is outside the scope of this basic MCP server.\n*   **Rate Limits:** The Kite Connect API has rate limits (e.g., 10 requests/second for order placement/modification). While the server handles 429 errors, it doesn't implement client-side rate limiting. High-frequency usage might require additional logic.\n*   **Security:** Ensure your API key and access token are kept secure. Do not commit them directly into your code.\n*   **Disclaimer:** Trading involves risks. Use this tool responsibly and ensure you understand the behavior of the Kite Connect API and the orders you are placing/modifying.\n"
    }
  ]
}
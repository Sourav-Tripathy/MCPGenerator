{
  "files": [
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field\nfrom typing import Optional, Dict, Any, List\nfrom enum import Enum\n\n# --- Enums based on Zerodha Kite Connect API Documentation ---\n\nclass VarietyEnum(str, Enum):\n    REGULAR = \"regular\"\n    AMO = \"amo\"\n    CO = \"co\"\n    ICEBERG = \"iceberg\"\n    AUCTION = \"auction\"\n\nclass ExchangeEnum(str, Enum):\n    NSE = \"NSE\"\n    BSE = \"BSE\"\n    NFO = \"NFO\"\n    CDS = \"CDS\"\n    BCD = \"BCD\"\n    MCX = \"MCX\"\n\nclass TransactionTypeEnum(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n\nclass OrderTypeEnum(str, Enum):\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n    SL = \"SL\"\n    SL_M = \"SL-M\"\n\nclass ProductEnum(str, Enum):\n    CNC = \"CNC\"  # Cash N Carry for equity\n    NRML = \"NRML\" # Normal for F&O, Currency, Commodity\n    MIS = \"MIS\"  # Margin Intraday Squareoff\n    MTF = \"MTF\"  # Margin Trading Facility\n\nclass ValidityEnum(str, Enum):\n    DAY = \"DAY\"\n    IOC = \"IOC\"  # Immediate or Cancel\n    TTL = \"TTL\"  # Time to Live (in minutes)\n\n# --- Input Models for Tools ---\n\nclass PlaceOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety (regular, amo, co, iceberg, auction)\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., 'INFY', 'NIFTY23JUL18000CE').\")\n    exchange: ExchangeEnum = Field(..., description=\"Name of the exchange (NSE, BSE, NFO, CDS, BCD, MCX).\")\n    transaction_type: TransactionTypeEnum = Field(..., description=\"Transaction type: BUY or SELL.\")\n    order_type: OrderTypeEnum = Field(..., description=\"Order type (MARKET, LIMIT, SL, SL-M).\")\n    quantity: int = Field(..., description=\"Quantity to transact.\")\n    product: ProductEnum = Field(..., description=\"Product type (CNC, NRML, MIS, MTF).\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (required for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (required for SL, SL-M orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades). Defaults to 0.\")\n    validity: ValidityEnum = Field(ValidityEnum.DAY, description=\"Order validity (DAY, IOC, TTL). Defaults to DAY.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes (required for TTL validity orders).\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10). Required for variety='iceberg'.\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs). Required for variety='iceberg'.\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction. Required for variety='auction'.\")\n    tag: Optional[str] = Field(None, description=\"An optional tag (alphanumeric, max 20 chars) to identify the order.\")\n\n    class Config:\n        use_enum_values = True # Serialize enums to their string values\n\nclass ModifyOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety (regular, co).\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    parent_order_id: Optional[str] = Field(None, description=\"The parent order ID if modifying a second leg of a multi-legged order (like CO).\")\n    order_type: Optional[OrderTypeEnum] = Field(None, description=\"New order type (only applicable for regular variety).\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (only applicable for regular variety).\")\n    price: Optional[float] = Field(None, description=\"New price (only applicable for regular or CO LIMIT variety).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (applicable for SL, SL-M, CO LIMIT orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (only applicable for regular variety equity trades). Defaults to 0.\")\n    validity: Optional[ValidityEnum] = Field(None, description=\"New validity (only applicable for regular variety). Must be DAY.\")\n\n    class Config:\n        use_enum_values = True # Serialize enums to their string values\n\n# --- Response Models ---\n\nclass PlaceOrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID.\")\n\nclass ModifyOrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID of the modified order.\")\n\nclass ErrorResponse(BaseModel):\n    status: str = Field(\"error\", description=\"Status indicator.\")\n    message: str = Field(..., description=\"Detailed error message.\")\n    error_type: Optional[str] = Field(None, description=\"Specific Kite Connect error type (e.g., InputException, TokenException).\")\n    details: Optional[Dict[str, Any]] = Field(None, description=\"Additional error details.\")\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nimport os\nfrom typing import Dict, Any, Optional\nfrom models import (\n    PlaceOrderParams, PlaceOrderResponse,\n    ModifyOrderParams, ModifyOrderResponse,\n    ErrorResponse, VarietyEnum\n)\n\nlogger = logging.getLogger(__name__)\n\n# --- Custom Exceptions ---\nclass KiteConnectAPIError(Exception):\n    \"\"\"Base exception for Kite Connect API errors.\"\"\"\n    def __init__(self, status_code: int, response_data: Dict[str, Any]):\n        self.status_code = status_code\n        self.status = response_data.get(\"status\", \"error\")\n        self.message = response_data.get(\"message\", \"Unknown API error\")\n        self.error_type = response_data.get(\"error_type\")\n        super().__init__(f\"[{self.status_code}/{self.error_type}] {self.message}\")\n\nclass AuthenticationError(KiteConnectAPIError):\n    \"\"\"Exception for authentication errors (403).\"\"\"\n    pass\n\nclass InputValidationError(KiteConnectAPIError):\n    \"\"\"Exception for input validation errors (400).\"\"\"\n    pass\n\nclass OrderException(KiteConnectAPIError):\n    \"\"\"Exception for order placement/modification errors.\"\"\"\n    pass\n\nclass NetworkError(Exception):\n    \"\"\"Exception for network-related issues.\"\"\"\n    pass\n\nclass GeneralError(KiteConnectAPIError):\n    \"\"\"Exception for other API errors (e.g., 5xx).\"\"\"\n    pass\n\n# --- API Client ---\nclass ZerodhaKiteClient:\n    \"\"\"Asynchronous client for interacting with the Zerodha Kite Connect v3 API.\"\"\"\n\n    def __init__(self):\n        self.api_key = os.getenv(\"ZERODHA_API_KEY\")\n        self.access_token = os.getenv(\"ZERODHA_ACCESS_TOKEN\")\n        self.base_url = os.getenv(\"ZERODHA_API_BASE_URL\", \"https://api.kite.trade\")\n        self.timeout = 60.0 # Default timeout for requests\n        self.api_version = \"3\" # Kite Connect API version\n\n        if not self.api_key or not self.access_token:\n            raise ValueError(\"ZERODHA_API_KEY and ZERODHA_ACCESS_TOKEN must be set in environment variables.\")\n\n        self.headers = {\n            \"X-Kite-Version\": self.api_version,\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form encoding\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=self.timeout\n        )\n        # Note: Proper rate limiting (3 requests/sec) requires a more sophisticated approach\n        # (e.g., using asyncio-throttle or aiolimiter). This client does not implement it.\n        logger.info(f\"ZerodhaKiteClient initialized for base URL: {self.base_url}\")\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite Connect API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Sending {method} request to {url} with data: {data}\")\n        try:\n            response = await self.client.request(method, endpoint, data=data)\n\n            logger.debug(f\"Received response: Status={response.status_code}, Body={response.text[:500]}...\")\n\n            # Check for specific Kite Connect error responses even on 200 OK\n            if response.status_code == 200:\n                response_data = response.json()\n                if response_data.get(\"status\") == \"error\":\n                    logger.error(f\"API returned error in 200 OK: {response_data}\")\n                    # Raise specific exceptions based on error_type if possible\n                    if response_data.get(\"error_type\") == \"InputException\":\n                        raise InputValidationError(response.status_code, response_data)\n                    elif response_data.get(\"error_type\") == \"OrderException\":\n                        raise OrderException(response.status_code, response_data)\n                    elif response_data.get(\"error_type\") == \"TokenException\":\n                         raise AuthenticationError(response.status_code, response_data)\n                    else:\n                        raise KiteConnectAPIError(response.status_code, response_data)\n                return response_data.get(\"data\", {}) # Successful responses are nested under 'data'\n\n            # Handle HTTP errors\n            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx\n\n            # Should not happen if raise_for_status works, but as a fallback\n            return response.json().get(\"data\", {}) \n\n        except httpx.HTTPStatusError as e:\n            status_code = e.response.status_code\n            try:\n                error_data = e.response.json()\n                logger.error(f\"HTTP Status Error {status_code}: {error_data}\")\n                if status_code == 400:\n                    raise InputValidationError(status_code, error_data) from e\n                elif status_code == 403:\n                    raise AuthenticationError(status_code, error_data) from e\n                # Add more specific error mappings if needed (e.g., 429 for rate limits)\n                elif status_code >= 500:\n                    raise GeneralError(status_code, error_data) from e\n                else:\n                    raise KiteConnectAPIError(status_code, error_data) from e\n            except Exception as json_e: # Handle cases where error response is not JSON\n                logger.error(f\"HTTP Status Error {status_code}, could not parse JSON response: {e.response.text}\")\n                error_data = {\"message\": e.response.text, \"status\": \"error\"}\n                if status_code == 403:\n                    raise AuthenticationError(status_code, error_data) from e\n                elif status_code >= 500:\n                    raise GeneralError(status_code, error_data) from e\n                else:\n                    raise KiteConnectAPIError(status_code, error_data) from e\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out: {e}\")\n            raise NetworkError(f\"Request timed out after {self.timeout} seconds\") from e\n        except httpx.NetworkError as e:\n            logger.error(f\"Network error occurred: {e}\")\n            raise NetworkError(f\"A network error occurred: {e}\") from e\n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during API request: {e}\")\n            raise GeneralError(500, {\"message\": f\"An unexpected error occurred: {str(e)}\", \"status\": \"error\"}) from e\n\n    async def place_order(self, params: PlaceOrderParams) -> PlaceOrderResponse:\n        \"\"\"Places an order using the Kite Connect API.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}\"\n        # Convert Pydantic model to dict, excluding None values and 'variety'\n        payload = params.dict(exclude_none=True, exclude={'variety'})\n\n        # Convert boolean/enum fields to strings expected by Kite API if necessary\n        # (httpx handles basic types, but check Kite docs if issues arise)\n        # Example: payload['transaction_type'] = payload['transaction_type'].value\n\n        logger.info(f\"Placing order: {payload}\")\n        response_data = await self._request(\"POST\", endpoint, data=payload)\n        logger.info(f\"Order placement successful: {response_data}\")\n        return PlaceOrderResponse(**response_data)\n\n    async def modify_order(self, params: ModifyOrderParams) -> ModifyOrderResponse:\n        \"\"\"Modifies a pending order using the Kite Connect API.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}/{params.order_id}\"\n        # Convert Pydantic model to dict, excluding None values and path params\n        payload = params.dict(exclude_none=True, exclude={'variety', 'order_id'})\n\n        logger.info(f\"Modifying order {params.order_id}: {payload}\")\n        response_data = await self._request(\"PUT\", endpoint, data=payload)\n        logger.info(f\"Order modification successful: {response_data}\")\n        return ModifyOrderResponse(**response_data)\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"ZerodhaKiteClient closed.\")\n"
    },
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\n# Import models and client\nfrom models import (\n    PlaceOrderParams, PlaceOrderResponse,\n    ModifyOrderParams, ModifyOrderResponse,\n    ErrorResponse,\n    VarietyEnum, ExchangeEnum, TransactionTypeEnum, OrderTypeEnum, ProductEnum, ValidityEnum\n)\nfrom client import (\n    ZerodhaKiteClient,\n    KiteConnectAPIError, AuthenticationError, InputValidationError,\n    OrderException, NetworkError, GeneralError\n)\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# --- Initialize MCP Server ---\nmcp = FastMCP(\n    service_name=\"ZerodhaKiteConnectOrders\",\n    description=\"Provides tools to manage trading orders (place, modify) using the Zerodha Kite Connect v3 API.\"\n)\n\n# --- Initialize API Client ---\n# Client initialization requires environment variables ZERODHA_API_KEY and ZERODHA_ACCESS_TOKEN\ntry:\n    kite_client = ZerodhaKiteClient()\nexcept ValueError as e:\n    logger.error(f\"Failed to initialize ZerodhaKiteClient: {e}\")\n    # Optionally, exit or prevent server start if client init fails\n    # raise SystemExit(f\"Configuration Error: {e}\")\n    kite_client = None # Set to None to handle gracefully in tools\n\n# --- Tool Definitions ---\n\n@mcp.tool()\nasync def place_order(\n    variety: VarietyEnum,\n    tradingsymbol: str,\n    exchange: ExchangeEnum,\n    transaction_type: TransactionTypeEnum,\n    order_type: OrderTypeEnum,\n    quantity: int,\n    product: ProductEnum,\n    price: Optional[float] = None,\n    trigger_price: Optional[float] = None,\n    disclosed_quantity: Optional[int] = None,\n    validity: ValidityEnum = ValidityEnum.DAY,\n    validity_ttl: Optional[int] = None,\n    iceberg_legs: Optional[int] = None,\n    iceberg_quantity: Optional[int] = None,\n    auction_number: Optional[str] = None,\n    tag: Optional[str] = None\n) -> Dict[str, Any]:\n    \"\"\"Places an order of a particular variety (regular, amo, co, iceberg, auction).\"\"\"\n    if not kite_client:\n        logger.error(\"place_order tool called but ZerodhaKiteClient is not initialized.\")\n        return ErrorResponse(status=\"error\", message=\"Zerodha client not configured.\").dict()\n\n    try:\n        params = PlaceOrderParams(\n            variety=variety,\n            tradingsymbol=tradingsymbol,\n            exchange=exchange,\n            transaction_type=transaction_type,\n            order_type=order_type,\n            quantity=quantity,\n            product=product,\n            price=price,\n            trigger_price=trigger_price,\n            disclosed_quantity=disclosed_quantity,\n            validity=validity,\n            validity_ttl=validity_ttl,\n            iceberg_legs=iceberg_legs,\n            iceberg_quantity=iceberg_quantity,\n            auction_number=auction_number,\n            tag=tag\n        )\n        logger.info(f\"Executing place_order with params: {params.dict(exclude_none=True)}\")\n        result = await kite_client.place_order(params)\n        logger.info(f\"place_order successful: {result.dict()}\")\n        return result.dict()\n\n    except (InputValidationError, OrderException, AuthenticationError, GeneralError, NetworkError) as e:\n        logger.error(f\"place_order failed: {type(e).__name__} - {e}\")\n        error_type = getattr(e, 'error_type', type(e).__name__)\n        message = getattr(e, 'message', str(e))\n        return ErrorResponse(status=\"error\", message=message, error_type=error_type).dict()\n    except Exception as e:\n        logger.exception(f\"An unexpected error occurred in place_order: {e}\")\n        return ErrorResponse(status=\"error\", message=f\"An unexpected error occurred: {str(e)}\", error_type=\"UnexpectedException\").dict()\n\n@mcp.tool()\nasync def modify_order(\n    variety: VarietyEnum,\n    order_id: str,\n    parent_order_id: Optional[str] = None,\n    order_type: Optional[OrderTypeEnum] = None,\n    quantity: Optional[int] = None,\n    price: Optional[float] = None,\n    trigger_price: Optional[float] = None,\n    disclosed_quantity: Optional[int] = None,\n    validity: Optional[ValidityEnum] = None\n) -> Dict[str, Any]:\n    \"\"\"Modifies attributes of a pending regular or CO order.\"\"\"\n    if not kite_client:\n        logger.error(\"modify_order tool called but ZerodhaKiteClient is not initialized.\")\n        return ErrorResponse(status=\"error\", message=\"Zerodha client not configured.\").dict()\n\n    # Basic validation for CO modification (only trigger_price allowed for CO)\n    if variety == VarietyEnum.CO and any([order_type, quantity, price is not None, disclosed_quantity is not None, validity]):\n         logger.warning(f\"Attempting to modify fields other than trigger_price for a CO order (order_id: {order_id}). Only trigger_price is allowed.\")\n         # Note: The API might reject this anyway, but adding a check here can be helpful.\n         # Consider raising an error or stripping disallowed fields depending on desired behavior.\n\n    # Basic validation for regular order validity modification (must be DAY)\n    if variety == VarietyEnum.REGULAR and validity and validity != ValidityEnum.DAY:\n        logger.error(f\"Invalid validity '{validity}' for modifying regular order {order_id}. Only 'DAY' is allowed.\")\n        return ErrorResponse(status=\"error\", message=\"Invalid validity for modification. Only 'DAY' is allowed for regular orders.\", error_type=\"InputValidationError\").dict()\n\n    try:\n        params = ModifyOrderParams(\n            variety=variety,\n            order_id=order_id,\n            parent_order_id=parent_order_id,\n            order_type=order_type,\n            quantity=quantity,\n            price=price,\n            trigger_price=trigger_price,\n            disclosed_quantity=disclosed_quantity,\n            validity=validity\n        )\n        logger.info(f\"Executing modify_order for order_id {order_id} with params: {params.dict(exclude_none=True)}\")\n        result = await kite_client.modify_order(params)\n        logger.info(f\"modify_order successful for order_id {order_id}: {result.dict()}\")\n        return result.dict()\n\n    except (InputValidationError, OrderException, AuthenticationError, GeneralError, NetworkError) as e:\n        logger.error(f\"modify_order failed for order_id {order_id}: {type(e).__name__} - {e}\")\n        error_type = getattr(e, 'error_type', type(e).__name__)\n        message = getattr(e, 'message', str(e))\n        return ErrorResponse(status=\"error\", message=message, error_type=error_type).dict()\n    except Exception as e:\n        logger.exception(f\"An unexpected error occurred in modify_order for order_id {order_id}: {e}\")\n        return ErrorResponse(status=\"error\", message=f\"An unexpected error occurred: {str(e)}\", error_type=\"UnexpectedException\").dict()\n\n# --- Graceful Shutdown ---\n@mcp.on_event(\"shutdown\")\nasync def shutdown_event():\n    if kite_client:\n        logger.info(\"Closing Zerodha Kite client...\")\n        await kite_client.close()\n    logger.info(\"MCP server shutdown complete.\")\n\n# --- Run Server ---\nif __name__ == \"__main__\":\n    # Example: Run with uvicorn programmatically (optional)\n    # import uvicorn\n    # uvicorn.run(mcp, host=\"0.0.0.0\", port=8000)\n\n    # Standard way to run is via CLI: uvicorn main:mcp --host 0.0.0.0 --port 8000 --reload\n    logger.info(\"Starting Zerodha Kite Connect Orders MCP Server.\")\n    logger.info(\"Run with: uvicorn main:mcp --host <host> --port <port> [--reload]\")\n    # The mcp.run() method is for development/testing, use Uvicorn for production.\n    # mcp.run() # Uncomment for simple testing, but Uvicorn is preferred.\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.2.0\npydantic>=1.10.0,<2.0.0\nhttpx>=0.23.0\npython-dotenv>=0.20.0\nuvicorn>=0.18.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Environment variables for Zerodha Kite Connect MCP Server\n\n# Your Zerodha Kite Connect API Key\nZERODHA_API_KEY=\"your_api_key\"\n\n# The access token obtained after successful login via Kite Connect flow\n# This token is typically valid for one day and needs to be regenerated.\nZERODHA_ACCESS_TOKEN=\"your_access_token\"\n\n# Base URL for the Kite Connect API (usually doesn't need changing)\n# ZERODHA_API_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Zerodha Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server built with FastMCP to interact with the Zerodha Kite Connect v3 API, specifically focusing on order management (placing and modifying orders).\n\n## Description\n\nThe server exposes tools that allow language models or other applications to:\n\n*   Place various types of trading orders (Regular, AMO, CO, Iceberg, Auction).\n*   Modify attributes of existing pending orders.\n\nIt handles communication with the Zerodha API, including authentication, request formatting, and error handling.\n\n## Features\n\n*   **Place Orders:** Supports placing orders with various parameters like symbol, exchange, quantity, price, order type, product type, validity, etc.\n*   **Modify Orders:** Allows modification of pending orders (e.g., changing price, quantity, trigger price).\n*   **Typed Interfaces:** Uses Pydantic models for clear and validated tool inputs and outputs.\n*   **Asynchronous:** Built with `asyncio` and `httpx` for non-blocking I/O.\n*   **Error Handling:** Maps Zerodha API errors to specific exceptions and provides informative error responses.\n*   **Environment Variable Configuration:** API keys and tokens are configured via environment variables.\n\n## Available Tools\n\n1.  **`place_order`**: Places an order of a particular variety.\n    *   **Description:** Places an order (regular, amo, co, iceberg, auction) with specified parameters.\n    *   **Inputs:** `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, `price` (optional), `trigger_price` (optional), `disclosed_quantity` (optional), `validity` (optional, default: DAY), `validity_ttl` (optional), `iceberg_legs` (optional), `iceberg_quantity` (optional), `auction_number` (optional), `tag` (optional).\n    *   **Returns:** A dictionary containing the `order_id` of the successfully placed order or an error response.\n\n2.  **`modify_order`**: Modifies attributes of a pending order.\n    *   **Description:** Modifies attributes (quantity, price, trigger price, order type, validity) of a pending regular order. For Cover Orders (CO), only `trigger_price` can be modified.\n    *   **Inputs:** `variety`, `order_id`, `parent_order_id` (optional), `order_type` (optional), `quantity` (optional), `price` (optional), `trigger_price` (optional), `disclosed_quantity` (optional), `validity` (optional, must be DAY for regular orders).\n    *   **Returns:** A dictionary containing the `order_id` of the successfully modified order or an error response.\n\n## Setup and Installation\n\n1.  **Clone the repository (if applicable):**\n    ```bash\n    git clone <repository_url>\n    cd <repository_directory>\n    ```\n\n2.  **Create a virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Zerodha API Key and a valid Access Token:\n        ```dotenv\n        ZERODHA_API_KEY=\"your_actual_api_key\"\n        ZERODHA_ACCESS_TOKEN=\"your_valid_access_token\"\n        # ZERODHA_API_BASE_URL=\"https://api.kite.trade\" # Optional: Uncomment to override default\n        ```\n    *   **Important:** The `ZERODHA_ACCESS_TOKEN` is short-lived (typically valid for a day) and needs to be obtained through the Kite Connect login flow. You will need to update this token regularly.\n\n## Running the Server\n\nUse Uvicorn to run the FastMCP application:\n\n```bash\n# Default: http://127.0.0.1:8000\nuvicorn main:mcp --host 127.0.0.1 --port 8000\n\n# Run with auto-reload for development\nuvicorn main:mcp --host 127.0.0.1 --port 8000 --reload\n```\n\nThe server will start, and you can interact with it using an MCP client or test endpoints (like `/tools` for discovery) via HTTP.\n\n## Authentication\n\nAuthentication with the Zerodha Kite Connect API is handled using the `api_key` and `access_token` provided in the `.env` file. These are sent in the `Authorization` header for every API request.\n\nEnsure your `access_token` is valid. If you receive `AuthenticationError` or `TokenException` errors, you likely need to regenerate the access token.\n\n## Error Handling\n\nThe server catches common errors:\n\n*   **HTTP Errors:** Handled by `httpx`.\n*   **API Errors:** Specific errors returned by the Kite Connect API (e.g., insufficient funds, invalid parameters, authentication issues) are parsed and returned as structured `ErrorResponse` objects.\n*   **Network Errors:** Timeouts or connection issues.\n*   **Validation Errors:** Issues with the input parameters provided to the tools.\n\nError responses include a `status`, `message`, and often an `error_type` corresponding to the Kite Connect error type.\n\n## Rate Limiting\n\nThe Zerodha Kite Connect API has rate limits (typically 3 requests per second). This client **does not** implement explicit rate limiting logic. If you anticipate high request volumes, you may need to add rate limiting using libraries like `asyncio-throttle` or `aiolimiter` in the `client.py` file to avoid hitting API limits (HTTP 429 errors).\n"
    }
  ]
}
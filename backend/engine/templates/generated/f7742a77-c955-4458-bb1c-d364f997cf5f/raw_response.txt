{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, Optional, List\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom models import (\n    PlaceOrderParams, ModifyOrderParams, CancelOrderParams,\n    GetOrderHistoryParams, GetOrderTradesParams, Order, Trade,\n    KiteApiErrorResponse\n)\nfrom client import KiteConnectClient, KiteConnectError\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnect\",\n    description=\"MCP server providing access to the Zerodha Kite Connect trading API (v3). Allows placing, modifying, and cancelling orders, retrieving order history and trades, fetching instrument data, and managing mutual fund orders.\"\n)\n\n# Initialize Kite Connect API Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables or .env file.\")\n    # Optionally raise an error or exit if credentials are required at startup\n    # raise ValueError(\"Kite Connect API credentials not found.\")\n    kite_client = None # Client will be unusable, tools will fail\nelse:\n    try:\n        kite_client = KiteConnectClient(api_key=api_key, access_token=access_token, base_url=base_url)\n        logger.info(\"KiteConnectClient initialized successfully.\")\n    except Exception as e:\n        logger.error(f\"Failed to initialize KiteConnectClient: {e}\")\n        kite_client = None\n\ndef handle_api_error(tool_name: str, error: Exception) -> KiteApiErrorResponse:\n    \"\"\"Handles errors raised by the KiteConnectClient.\"\"\"\n    logger.error(f\"Error in {tool_name}: {error}\", exc_info=True)\n    if isinstance(error, KiteConnectError):\n        return KiteApiErrorResponse(\n            error_type=error.error_type,\n            message=error.message,\n            status_code=error.status_code\n        )\n    else:\n        # General unexpected error\n        return KiteApiErrorResponse(\n            error_type=\"ServerError\",\n            message=f\"An unexpected error occurred: {str(error)}\"\n        )\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\"\"\"\n    if not kite_client:\n        return handle_api_error(\"place_order\", Exception(\"Kite client not initialized.\")).dict()\n    try:\n        logger.info(f\"Placing order with params: {params.dict(exclude_unset=True)}\")\n        # Exclude 'variety' from the payload as it's a path parameter\n        payload = params.dict(exclude={'variety'}, exclude_unset=True)\n        result = await kite_client.place_order(variety=params.variety, data=payload)\n        logger.info(f\"Order placed successfully: {result}\")\n        return result\n    except Exception as e:\n        return handle_api_error(\"place_order\", e).dict()\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modify attributes of a pending regular or cover order.\"\"\"\n    if not kite_client:\n        return handle_api_error(\"modify_order\", Exception(\"Kite client not initialized.\")).dict()\n    try:\n        logger.info(f\"Modifying order {params.order_id} ({params.variety}) with params: {params.dict(exclude={'variety', 'order_id'}, exclude_unset=True)}\")\n        # Exclude path parameters from payload\n        payload = params.dict(exclude={'variety', 'order_id'}, exclude_unset=True)\n        result = await kite_client.modify_order(variety=params.variety, order_id=params.order_id, data=payload)\n        logger.info(f\"Order modified successfully: {result}\")\n        return result\n    except Exception as e:\n        return handle_api_error(\"modify_order\", e).dict()\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"Cancel a pending regular or cover order.\"\"\"\n    if not kite_client:\n        return handle_api_error(\"cancel_order\", Exception(\"Kite client not initialized.\")).dict()\n    try:\n        logger.info(f\"Cancelling order {params.order_id} ({params.variety}) with params: {params.dict(exclude={'variety', 'order_id'}, exclude_unset=True)}\")\n        # Exclude path parameters from payload, pass parent_order_id if present\n        payload = {}\n        if params.parent_order_id:\n            payload['parent_order_id'] = params.parent_order_id\n\n        result = await kite_client.cancel_order(variety=params.variety, order_id=params.order_id, data=payload)\n        logger.info(f\"Order cancelled successfully: {result}\")\n        return result\n    except Exception as e:\n        return handle_api_error(\"cancel_order\", e).dict()\n\n@mcp.tool()\nasync def get_orders() -> List[Dict[str, Any]]:\n    \"\"\"Retrieve the list of all orders (open, pending, executed) for the current trading day.\"\"\"\n    if not kite_client:\n        # Returning an error object within the list to somewhat match expected structure\n        return [handle_api_error(\"get_orders\", Exception(\"Kite client not initialized.\")).dict()]\n    try:\n        logger.info(\"Fetching all orders for the day.\")\n        result = await kite_client.get_orders()\n        logger.info(f\"Fetched {len(result)} orders.\")\n        # Attempt to parse into Order models, but return raw dicts as per spec\n        # try:\n        #     return [Order(**order_data).dict() for order_data in result]\n        # except Exception as parse_error:\n        #     logger.warning(f\"Could not parse all orders into Order model: {parse_error}\")\n        return result # Return raw list of dicts\n    except Exception as e:\n        return [handle_api_error(\"get_orders\", e).dict()]\n\n@mcp.tool()\nasync def get_order_history(params: GetOrderHistoryParams) -> List[Dict[str, Any]]:\n    \"\"\"Retrieve the history of status changes for a given order.\"\"\"\n    if not kite_client:\n        return [handle_api_error(\"get_order_history\", Exception(\"Kite client not initialized.\")).dict()]\n    try:\n        logger.info(f\"Fetching order history for order_id: {params.order_id}\")\n        result = await kite_client.get_order_history(order_id=params.order_id)\n        logger.info(f\"Fetched {len(result)} history entries for order {params.order_id}.\")\n        # try:\n        #     return [Order(**order_data).dict() for order_data in result]\n        # except Exception as parse_error:\n        #     logger.warning(f\"Could not parse order history into Order model: {parse_error}\")\n        return result # Return raw list of dicts\n    except Exception as e:\n        return [handle_api_error(\"get_order_history\", e).dict()]\n\n@mcp.tool()\nasync def get_trades() -> List[Dict[str, Any]]:\n    \"\"\"Retrieve the list of all executed trades for the current trading day.\"\"\"\n    if not kite_client:\n        return [handle_api_error(\"get_trades\", Exception(\"Kite client not initialized.\")).dict()]\n    try:\n        logger.info(\"Fetching all trades for the day.\")\n        result = await kite_client.get_trades()\n        logger.info(f\"Fetched {len(result)} trades.\")\n        # try:\n        #     return [Trade(**trade_data).dict() for trade_data in result]\n        # except Exception as parse_error:\n        #     logger.warning(f\"Could not parse all trades into Trade model: {parse_error}\")\n        return result # Return raw list of dicts\n    except Exception as e:\n        return [handle_api_error(\"get_trades\", e).dict()]\n\n@mcp.tool()\nasync def get_order_trades(params: GetOrderTradesParams) -> List[Dict[str, Any]]:\n    \"\"\"Retrieve the trades generated by a specific order.\"\"\"\n    if not kite_client:\n        return [handle_api_error(\"get_order_trades\", Exception(\"Kite client not initialized.\")).dict()]\n    try:\n        logger.info(f\"Fetching trades for order_id: {params.order_id}\")\n        result = await kite_client.get_order_trades(order_id=params.order_id)\n        logger.info(f\"Fetched {len(result)} trades for order {params.order_id}.\")\n        # try:\n        #     return [Trade(**trade_data).dict() for trade_data in result]\n        # except Exception as parse_error:\n        #     logger.warning(f\"Could not parse order trades into Trade model: {parse_error}\")\n        return result # Return raw list of dicts\n    except Exception as e:\n        return [handle_api_error(\"get_order_trades\", e).dict()]\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    # Run the MCP server using uvicorn\n    # The MCP server exposes a FastAPI application at mcp.app\n    uvicorn.run(mcp.app, host=\"0.0.0.0\", port=8000)\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field\nfrom typing import Optional, List, Dict, Any, Literal\n\n# --- Input Models ---\n\nclass PlaceOrderParams(BaseModel):\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety (regular, amo, co, iceberg, auction). Determines the endpoint path.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'] = Field(..., description=\"Name of the exchange (NSE, BSE, NFO, CDS, BCD, MCX).\")\n    transaction_type: Literal['BUY', 'SELL'] = Field(..., description=\"BUY or SELL.\")\n    order_type: Literal['MARKET', 'LIMIT', 'SL', 'SL-M'] = Field(..., description=\"Order type (MARKET, LIMIT, SL, SL-M).\")\n    quantity: int = Field(..., description=\"Quantity to transact.\")\n    product: Literal['CNC', 'NRML', 'MIS', 'MTF'] = Field(..., description=\"Product type (CNC, NRML, MIS, MTF).\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (required for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (required for SL, SL-M orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity: Literal['DAY', 'IOC', 'TTL'] = Field('DAY', description=\"Order validity (DAY, IOC, TTL). Default is DAY.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10). Required for variety='iceberg'.\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs). Required for variety='iceberg'.\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction. Required for variety='auction'.\")\n    tag: Optional[str] = Field(None, description=\"An optional tag to apply to an order (alphanumeric, max 20 chars).\", max_length=20)\n\nclass ModifyOrderParams(BaseModel):\n    variety: Literal['regular', 'co'] = Field(..., description=\"Order variety (regular, co). Determines the endpoint path.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for modifying second leg of CO.\")\n    order_type: Optional[Literal['MARKET', 'LIMIT', 'SL', 'SL-M']] = Field(None, description=\"New order type (Only applicable for regular variety).\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (Only applicable for regular variety).\")\n    price: Optional[float] = Field(None, description=\"New price (applicable for LIMIT orders, CO).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (applicable for SL, SL-M, CO orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (Only applicable for regular variety).\")\n    validity: Optional[Literal['DAY', 'IOC']] = Field(None, description=\"New validity (DAY, IOC) (Only applicable for regular variety).\")\n\nclass CancelOrderParams(BaseModel):\n    variety: Literal['regular', 'co', 'amo', 'iceberg', 'auction'] = Field(..., description=\"Order variety (regular, co, amo, iceberg, auction). Determines the endpoint path.\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for cancelling second leg of CO.\")\n\nclass GetOrdersParams(BaseModel):\n    # No parameters needed for get_orders\n    pass\n\nclass GetOrderHistoryParams(BaseModel):\n    order_id: str = Field(..., description=\"The ID of the order to retrieve history for.\")\n\nclass GetTradesParams(BaseModel):\n    # No parameters needed for get_trades\n    pass\n\nclass GetOrderTradesParams(BaseModel):\n    order_id: str = Field(..., description=\"The ID of the order to retrieve trades for.\")\n\n# --- Response Models (Informational - Tools return Dict/List as per spec) ---\n# These models represent the expected structure but are not strictly enforced\n# in the tool return types based on the current implementation plan.\n\nclass Order(BaseModel):\n    order_id: Optional[str] = None\n    parent_order_id: Optional[str] = None\n    exchange_order_id: Optional[str] = None\n    placed_by: Optional[str] = None\n    variety: Optional[str] = None\n    status: Optional[str] = None\n    status_message: Optional[str] = None\n    status_message_raw: Optional[str] = None\n    order_timestamp: Optional[str] = None # Consider datetime\n    exchange_update_timestamp: Optional[str] = None # Consider datetime\n    exchange_timestamp: Optional[str] = None # Consider datetime\n    tradingsymbol: Optional[str] = None\n    instrument_token: Optional[int] = None\n    exchange: Optional[str] = None\n    transaction_type: Optional[str] = None\n    order_type: Optional[str] = None\n    product: Optional[str] = None\n    validity: Optional[str] = None\n    validity_ttl: Optional[int] = None\n    quantity: Optional[int] = None\n    disclosed_quantity: Optional[int] = None\n    price: Optional[float] = None\n    trigger_price: Optional[float] = None\n    average_price: Optional[float] = None\n    filled_quantity: Optional[int] = None\n    pending_quantity: Optional[int] = None\n    cancelled_quantity: Optional[int] = None\n    market_protection: Optional[float] = None\n    meta: Optional[Dict[str, Any]] = None\n    tag: Optional[str] = None\n    guid: Optional[str] = None\n\nclass Trade(BaseModel):\n    trade_id: Optional[str] = None\n    order_id: Optional[str] = None\n    exchange_order_id: Optional[str] = None\n    tradingsymbol: Optional[str] = None\n    instrument_token: Optional[int] = None\n    exchange: Optional[str] = None\n    product: Optional[str] = None\n    transaction_type: Optional[str] = None\n    order_type: Optional[str] = None\n    quantity: Optional[int] = None\n    average_price: Optional[float] = None\n    price: Optional[float] = None # Individual trade price\n    fill_timestamp: Optional[str] = None # Consider datetime\n    exchange_timestamp: Optional[str] = None # Consider datetime\n\n# --- Error Response Model ---\n\nclass KiteApiErrorResponse(BaseModel):\n    error_type: str = Field(..., description=\"The type of error encountered (e.g., AuthenticationError, InputValidationError, OrderException, NetworkError, ServerError).\")\n    message: str = Field(..., description=\"A descriptive error message.\")\n    status_code: Optional[int] = Field(None, description=\"The HTTP status code returned by the API, if available.\")\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nfrom typing import Dict, Any, List, Optional\nimport json\n\nlogger = logging.getLogger(__name__)\n\n# Custom Exception for Kite Connect specific errors\nclass KiteConnectError(Exception):\n    \"\"\"Represents an error returned by the Kite Connect API.\"\"\"\n    def __init__(self, message: str, error_type: str = \"GeneralError\", status_code: Optional[int] = None):\n        self.message = message\n        self.error_type = error_type\n        self.status_code = status_code\n        super().__init__(f\"[{error_type}/{status_code}] {message}\")\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Zerodha Kite Connect API (v3).\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\"):\n        \"\"\"\n        Initializes the KiteConnectClient.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after successful login.\n            base_url: The base URL for the Kite Connect API (default: https://api.kite.trade).\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url.rstrip('/')\n        self._headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form encoding\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self._headers,\n            timeout=30.0, # Default timeout for requests\n            limits=httpx.Limits(max_connections=100, max_keepalive_connections=20), # Default limits\n            event_hooks={'response': [self._log_response]}\n        )\n\n    async def _log_response(self, response: httpx.Response):\n        \"\"\"Hook to log response status before raising exceptions.\"\"\"\n        await response.aread()\n        logger.debug(f\"Request: {response.request.method} {response.request.url}\")\n        logger.debug(f\"Response Status: {response.status_code}\")\n        # Avoid logging potentially sensitive data in production by default\n        # logger.debug(f\"Response Body: {response.text}\")\n\n    async def _request(self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any] | List[Dict[str, Any]]:\n        \"\"\"Makes an asynchronous request to the Kite Connect API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            # Filter out None values from data payload\n            filtered_data = {k: v for k, v in data.items() if v is not None} if data else None\n\n            response = await self.client.request(\n                method=method,\n                url=url,\n                params=params, # For GET requests\n                data=filtered_data # For POST/PUT/DELETE (form-encoded)\n            )\n\n            # Check for specific Kite Connect error structure first\n            try:\n                response_data = response.json()\n                if response.status_code >= 400:\n                    error_type = response_data.get(\"error_type\", \"UnknownError\")\n                    message = response_data.get(\"message\", \"No error message provided.\")\n                    logger.error(f\"Kite API Error ({response.status_code}): {error_type} - {message} for {method} {url}\")\n                    raise KiteConnectError(message, error_type, response.status_code)\n\n                # Check if 'data' key exists and return its content, otherwise return the full response\n                # Common pattern in Kite API responses\n                return response_data.get(\"data\", response_data)\n\n            except json.JSONDecodeError:\n                # If response is not JSON, still check status code\n                if response.status_code >= 400:\n                    logger.error(f\"Kite API Error ({response.status_code}): Non-JSON response for {method} {url}. Body: {response.text[:500]}\")\n                    raise KiteConnectError(f\"API returned status {response.status_code} with non-JSON body: {response.text[:200]}\", \"NetworkError\", response.status_code)\n                else:\n                    # Handle successful non-JSON responses if any exist (unlikely for Kite v3)\n                    logger.warning(f\"Received non-JSON success response ({response.status_code}) for {method} {url}\")\n                    return {\"status\": \"success\", \"message\": \"Received non-JSON success response\", \"content\": response.text}\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out: {method} {url} - {e}\")\n            raise KiteConnectError(\"The request timed out.\", \"NetworkError\") from e\n        except httpx.RequestError as e:\n            logger.error(f\"Request error: {method} {url} - {e}\")\n            # E.g., DNS errors, connection refused\n            raise KiteConnectError(f\"Network request failed: {e}\", \"NetworkError\") from e\n        except KiteConnectError: # Re-raise specific Kite errors\n            raise\n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during the API request: {method} {url} - {e}\")\n            raise KiteConnectError(f\"An unexpected error occurred: {str(e)}\", \"ServerError\") from e\n\n    async def place_order(self, variety: str, data: Dict[str, Any]) -> Dict[str, str]:\n        \"\"\"Place an order.\"\"\"\n        endpoint = f\"/orders/{variety}\"\n        response = await self._request(\"POST\", endpoint, data=data)\n        if isinstance(response, dict) and 'order_id' in response:\n            return {\"order_id\": str(response['order_id'])}\n        logger.error(f\"Place order response did not contain 'order_id': {response}\")\n        raise KiteConnectError(\"Invalid response format from place_order\", \"ServerError\")\n\n    async def modify_order(self, variety: str, order_id: str, data: Dict[str, Any]) -> Dict[str, str]:\n        \"\"\"Modify an order.\"\"\"\n        endpoint = f\"/orders/{variety}/{order_id}\"\n        response = await self._request(\"PUT\", endpoint, data=data)\n        if isinstance(response, dict) and 'order_id' in response:\n            return {\"order_id\": str(response['order_id'])}\n        logger.error(f\"Modify order response did not contain 'order_id': {response}\")\n        raise KiteConnectError(\"Invalid response format from modify_order\", \"ServerError\")\n\n    async def cancel_order(self, variety: str, order_id: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, str]:\n        \"\"\"Cancel an order.\"\"\"\n        endpoint = f\"/orders/{variety}/{order_id}\"\n        response = await self._request(\"DELETE\", endpoint, data=data or {}) # DELETE might need form data for parent_order_id\n        if isinstance(response, dict) and 'order_id' in response:\n            return {\"order_id\": str(response['order_id'])}\n        logger.error(f\"Cancel order response did not contain 'order_id': {response}\")\n        raise KiteConnectError(\"Invalid response format from cancel_order\", \"ServerError\")\n\n    async def get_orders(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of orders.\"\"\"\n        endpoint = \"/orders\"\n        response = await self._request(\"GET\", endpoint)\n        if isinstance(response, list):\n            return response\n        logger.error(f\"Get orders response was not a list: {response}\")\n        raise KiteConnectError(\"Invalid response format from get_orders\", \"ServerError\")\n\n    async def get_order_history(self, order_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get history for a specific order.\"\"\"\n        endpoint = f\"/orders/{order_id}\"\n        response = await self._request(\"GET\", endpoint)\n        if isinstance(response, list):\n            return response\n        logger.error(f\"Get order history response was not a list: {response}\")\n        raise KiteConnectError(\"Invalid response format from get_order_history\", \"ServerError\")\n\n    async def get_trades(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of trades.\"\"\"\n        endpoint = \"/trades\"\n        response = await self._request(\"GET\", endpoint)\n        if isinstance(response, list):\n            return response\n        logger.error(f\"Get trades response was not a list: {response}\")\n        raise KiteConnectError(\"Invalid response format from get_trades\", \"ServerError\")\n\n    async def get_order_trades(self, order_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get trades for a specific order.\"\"\"\n        endpoint = f\"/orders/{order_id}/trades\"\n        response = await self._request(\"GET\", endpoint)\n        if isinstance(response, list):\n            return response\n        logger.error(f\"Get order trades response was not a list: {response}\")\n        raise KiteConnectError(\"Invalid response format from get_order_trades\", \"ServerError\")\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=1.9.0,<2.0.0\nhttpx[http2]>=0.23.0\npython-dotenv>=0.20.0\nuvicorn>=0.18.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Zerodha Kite Connect API Credentials and Configuration\n\n# Your Kite Connect API Key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# Your Kite Connect Access Token (obtained after login flow)\n# Note: Access tokens are typically short-lived and need to be refreshed.\n# For a production system, implement a proper token management strategy.\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# Base URL for the Kite Connect API (optional, defaults to https://api.kite.trade)\n# KITE_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect trading API (v3) using FastMCP.\n\nIt allows language models or other applications to perform trading-related actions like placing, modifying, and cancelling orders, as well as retrieving order and trade history through a standardized MCP interface.\n\n## Features\n\n*   Provides MCP tools for core Kite Connect functionalities:\n    *   `place_order`: Place regular, AMO, CO, Iceberg, or Auction orders.\n    *   `modify_order`: Modify pending regular or CO orders.\n    *   `cancel_order`: Cancel pending orders.\n    *   `get_orders`: Retrieve the list of orders for the day.\n    *   `get_order_history`: Get status changes for a specific order.\n    *   `get_trades`: Retrieve the list of executed trades for the day.\n    *   `get_order_trades`: Get trades associated with a specific order.\n*   Built with FastMCP for easy integration.\n*   Asynchronous API client using `httpx`.\n*   Typed inputs and outputs using Pydantic.\n*   Handles API errors and provides informative responses.\n*   Configurable via environment variables.\n\n## Prerequisites\n\n*   Python 3.8+\n*   Zerodha Kite Connect API Key and Access Token.\nYou can get these by creating a Kite Connect app on the [Zerodha Developers Console](https://developers.kite.trade/).\n*   Understanding that **access tokens are short-lived** and need to be regenerated (typically daily after login). This server assumes a valid access token is provided via environment variables. A production deployment would require a robust token generation/refresh mechanism.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd kiteconnect-mcp-server\n    ```\n\n2.  **Create a virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    Copy the example environment file:\n    ```bash\n    cp .env.example .env\n    ```\n    Edit the `.env` file and add your Kite Connect API Key and a valid Access Token:\n    ```dotenv\n    # .env\n    KITE_API_KEY=\"YOUR_API_KEY\"\n    KITE_ACCESS_TOKEN=\"YOUR_VALID_ACCESS_TOKEN\"\n    # KITE_BASE_URL=\"https://api.kite.trade\" # Optional\n    ```\n    **Important:** Ensure the `KITE_ACCESS_TOKEN` is fresh. You usually obtain this after completing the Kite Connect login flow.\n\n## Running the Server\n\nUse `uvicorn` to run the FastMCP application (which is a FastAPI app):\n\n```bash\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n*   `--reload`: Automatically restarts the server when code changes (useful for development).\n\nThe MCP server will be available at `http://localhost:8000`.\n\n## Available Tools\n\nThe server exposes the following tools via the MCP protocol:\n\n*   **`place_order(params: PlaceOrderParams) -> Dict[str, Any]`**\n    *   Description: Place an order of a particular variety.\n    *   Input: `PlaceOrderParams` model (includes variety, tradingsymbol, exchange, transaction\_type, order\_type, quantity, product, etc.)\n    *   Returns: Dictionary containing `order_id` on success, or an error dictionary.\n\n*   **`modify_order(params: ModifyOrderParams) -> Dict[str, Any]`**\n    *   Description: Modify attributes of a pending order.\n    *   Input: `ModifyOrderParams` model (includes variety, order\_id, and fields to modify like quantity, price, trigger\_price).\n    *   Returns: Dictionary containing `order_id` on success, or an error dictionary.\n\n*   **`cancel_order(params: CancelOrderParams) -> Dict[str, Any]`**\n    *   Description: Cancel a pending order.\n    *   Input: `CancelOrderParams` model (includes variety, order\_id, parent\_order\_id).\n    *   Returns: Dictionary containing `order_id` on success, or an error dictionary.\n\n*   **`get_orders() -> List[Dict[str, Any]]`**\n    *   Description: Retrieve all orders for the current trading day.\n    *   Input: None.\n    *   Returns: List of order dictionaries, or a list containing a single error dictionary.\n\n*   **`get_order_history(params: GetOrderHistoryParams) -> List[Dict[str, Any]]`**\n    *   Description: Retrieve the history for a specific order.\n    *   Input: `GetOrderHistoryParams` model (includes order\_id).\n    *   Returns: List of order state dictionaries, or a list containing a single error dictionary.\n\n*   **`get_trades() -> List[Dict[str, Any]]`**\n    *   Description: Retrieve all executed trades for the current trading day.\n    *   Input: None.\n    *   Returns: List of trade dictionaries, or a list containing a single error dictionary.\n\n*   **`get_order_trades(params: GetOrderTradesParams) -> List[Dict[str, Any]]`**\n    *   Description: Retrieve trades generated by a specific order.\n    *   Input: `GetOrderTradesParams` model (includes order\_id).\n    *   Returns: List of trade dictionaries, or a list containing a single error dictionary.\n\nRefer to `models.py` for detailed structure of the input parameter models and `client.py` / Kite Connect documentation for the structure of the returned dictionaries.\n\n## Error Handling\n\nThe API client (`client.py`) attempts to catch common HTTP errors and specific errors returned by the Kite Connect API. Errors are generally returned as a dictionary matching the `KiteApiErrorResponse` model:\n\n```json\n{\n  \"error_type\": \"AuthenticationError\",\n  \"message\": \"Invalid `api_key` or `access_token`.\",\n  \"status_code\": 403\n}\n```\n\nCommon `error_type` values include:\n\n*   `AuthenticationError`: Invalid credentials.\n*   `InputValidationError` / `InputException`: Invalid parameters sent.\n*   `OrderException`: Order placement/modification/cancellation issues (e.g., insufficient funds, RMS validation).\n*   `NetworkError`: Connection issues, timeouts.\n*   `RateLimitError`: Exceeded API rate limits.\n*   `GeneralError`: Other Kite API errors.\n*   `ServerError`: Unexpected errors within the MCP server or client.\n\n## Disclaimer\n\nTrading involves substantial risk. This software is provided \"as is\" without warranty of any kind. Use it at your own risk. The developers are not responsible for any financial losses incurred using this software.\n"
    }
  ]
}
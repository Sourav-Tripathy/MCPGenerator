{
  "files": [
    {
      "name": "main.py",
      "content": "import asyncio\nimport logging\nimport os\nfrom typing import Dict, Any\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import KiteConnectClient, KiteClientError\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnect\",\n    description=\"Provides tools to interact with the Zerodha Kite Connect trading API (v3/v4 via pykiteconnect), allowing users to manage orders (place, modify, cancel, retrieve), fetch trades, get instrument lists, manage mutual fund orders, and potentially stream market data.\"\n)\n\n# Initialize Kite Connect Client\nAPI_KEY = os.getenv(\"KITE_API_KEY\")\nACCESS_TOKEN = os.getenv(\"KITE_ACCESS_TOKEN\")\n\nif not API_KEY:\n    logger.warning(\"KITE_API_KEY environment variable not set.\")\nif not ACCESS_TOKEN:\n    logger.warning(\"KITE_ACCESS_TOKEN environment variable not set. Client will likely fail.\")\n\nkite_client = KiteConnectClient(api_key=API_KEY, access_token=ACCESS_TOKEN)\n\nasync def run_sync_in_executor(func, *args, **kwargs):\n    \"\"\"Runs a synchronous function in the default executor.\"\"\"\n    loop = asyncio.get_running_loop()\n    return await loop.run_in_executor(None, lambda: func(*args, **kwargs))\n\n@mcp.tool(description=\"Places an order of a specified variety (regular, amo, co, iceberg, auction).\")\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Places a trading order using the Kite Connect API.\n\n    Args:\n        params: An object containing all necessary parameters for placing an order.\n\n    Returns:\n        A dictionary containing the 'order_id' on success, or an 'error' key on failure.\n    \"\"\"\n    logger.info(f\"Received place_order request: {params.dict(exclude_none=True)}\")\n    try:\n        # pykiteconnect is synchronous, run it in an executor\n        result = await run_sync_in_executor(\n            kite_client.place_order,\n            variety=params.variety.value,\n            exchange=params.exchange.value,\n            tradingsymbol=params.tradingsymbol,\n            transaction_type=params.transaction_type.value,\n            quantity=params.quantity,\n            product=params.product.value,\n            order_type=params.order_type.value,\n            price=params.price,\n            validity=params.validity.value if params.validity else None,\n            disclosed_quantity=params.disclosed_quantity,\n            trigger_price=params.trigger_price,\n            tag=params.tag,\n            iceberg_legs=params.iceberg_legs,\n            iceberg_quantity=params.iceberg_quantity,\n            auction_number=params.auction_number,\n            validity_ttl=params.validity_ttl\n        )\n        logger.info(f\"Order placed successfully: {result}\")\n        return result\n    except KiteClientError as e:\n        logger.error(f\"Error placing order: {e}\")\n        return {\"error\": str(e), \"details\": e.details}\n    except Exception as e:\n        logger.exception(\"Unexpected error during place_order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool(description=\"Modifies attributes of a pending regular or cover order.\")\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Modifies an existing pending order.\n\n    Args:\n        params: An object containing the parameters for modifying the order.\n\n    Returns:\n        A dictionary containing the 'order_id' on success, or an 'error' key on failure.\n    \"\"\"\n    logger.info(f\"Received modify_order request: {params.dict(exclude_none=True)}\")\n    try:\n        # pykiteconnect is synchronous, run it in an executor\n        result = await run_sync_in_executor(\n            kite_client.modify_order,\n            variety=params.variety.value,\n            order_id=params.order_id,\n            parent_order_id=params.parent_order_id,\n            quantity=params.quantity,\n            price=params.price,\n            order_type=params.order_type.value if params.order_type else None,\n            trigger_price=params.trigger_price,\n            validity=params.validity.value if params.validity else None,\n            disclosed_quantity=params.disclosed_quantity\n        )\n        logger.info(f\"Order modified successfully: {result}\")\n        return result\n    except KiteClientError as e:\n        logger.error(f\"Error modifying order: {e}\")\n        return {\"error\": str(e), \"details\": e.details}\n    except Exception as e:\n        logger.exception(\"Unexpected error during modify_order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool(description=\"Cancels a pending regular or cover order.\")\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Cancels an existing pending order.\n\n    Args:\n        params: An object containing the parameters for cancelling the order.\n\n    Returns:\n        A dictionary containing the 'order_id' on success, or an 'error' key on failure.\n    \"\"\"\n    logger.info(f\"Received cancel_order request: {params.dict(exclude_none=True)}\")\n    try:\n        # pykiteconnect is synchronous, run it in an executor\n        result = await run_sync_in_executor(\n            kite_client.cancel_order,\n            variety=params.variety.value,\n            order_id=params.order_id,\n            parent_order_id=params.parent_order_id\n        )\n        logger.info(f\"Order cancelled successfully: {result}\")\n        return result\n    except KiteClientError as e:\n        logger.error(f\"Error cancelling order: {e}\")\n        return {\"error\": str(e), \"details\": e.details}\n    except Exception as e:\n        logger.exception(\"Unexpected error during cancel_order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n# Example of how to add other tools (implement client methods first)\n# @mcp.tool(description=\"Retrieves the list of orders.\")\n# async def get_orders() -> List[Dict[str, Any]]:\n#     logger.info(\"Received get_orders request\")\n#     try:\n#         orders = await run_sync_in_executor(kite_client.get_orders)\n#         logger.info(f\"Retrieved {len(orders)} orders.\")\n#         return orders\n#     except KiteClientError as e:\n#         logger.error(f\"Error getting orders: {e}\")\n#         return [{\"error\": str(e), \"details\": e.details}]\n#     except Exception as e:\n#         logger.exception(\"Unexpected error during get_orders\")\n#         return [{\"error\": f\"An unexpected error occurred: {str(e)}\"}]\n\n\nif __name__ == \"__main__\":\n    # Run the MCP server\n    # Use uvicorn to run: uvicorn main:mcp --host 0.0.0.0 --port 8000\n    logger.info(\"Starting KiteConnect MCP Server...\")\n    # The mcp.run() method is for development, use uvicorn in production\n    # mcp.run() # This might block in some environments, use uvicorn command instead\n    print(\"MCP Server defined. Run with: uvicorn main:mcp --host 0.0.0.0 --port 8000\")\n"
    },
    {
      "name": "models.py",
      "content": "from enum import Enum\nfrom typing import Optional, Dict, Any\nfrom pydantic import BaseModel, Field, validator\n\n# --- Enums based on Kite Connect API documentation ---\n\nclass Variety(str, Enum):\n    REGULAR = \"regular\"\n    AMO = \"amo\"\n    CO = \"co\"\n    ICEBERG = \"iceberg\"\n    AUCTION = \"auction\"\n\nclass Exchange(str, Enum):\n    NSE = \"NSE\"\n    BSE = \"BSE\"\n    NFO = \"NFO\"\n    CDS = \"CDS\"\n    MCX = \"MCX\"\n    BCD = \"BCD\"\n    BFO = \"BFO\"\n\nclass TransactionType(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n\nclass Product(str, Enum):\n    CNC = \"CNC\"  # Cash & Carry for equity\n    NRML = \"NRML\" # Normal for F&O, currency, commodity\n    MIS = \"MIS\"  # Margin Intraday Squareoff\n    MTF = \"MTF\"  # Margin Trading Facility\n\nclass OrderType(str, Enum):\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n    SL = \"SL\"    # Stoploss limit\n    SLM = \"SL-M\" # Stoploss market\n\nclass Validity(str, Enum):\n    DAY = \"DAY\"\n    IOC = \"IOC\"  # Immediate or Cancel\n    TTL = \"TTL\"  # Time to Live\n\n# --- Input Models for MCP Tools ---\n\nclass PlaceOrderParams(BaseModel):\n    variety: Variety = Field(..., description=\"Order variety (regular, amo, co, iceberg, auction).\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., INFY, NIFTY23JULIFUT).\")\n    exchange: Exchange = Field(..., description=\"Name of the exchange (e.g., NSE, NFO, BSE).\" )\n    transaction_type: TransactionType = Field(..., description=\"Transaction type: BUY or SELL.\")\n    quantity: int = Field(..., description=\"Quantity to transact.\", gt=0)\n    product: Product = Field(..., description=\"Product type (CNC, NRML, MIS, MTF).\")\n    order_type: OrderType = Field(..., description=\"Order type (MARKET, LIMIT, SL, SL-M).\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders. Required if order_type is LIMIT or SL.\", ge=0)\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders. Required if order_type is SL or SL-M.\", ge=0)\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\", ge=0)\n    validity: Optional[Validity] = Field(Validity.DAY, description=\"Order validity (DAY, IOC, TTL). Default is DAY.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders (1 to 1440). Required if validity is TTL.\", ge=1, le=1440)\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10). Required for variety='iceberg'.\", ge=2, le=10)\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs). Required for variety='iceberg'.\", ge=1)\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction. Required for variety='auction'.\")\n    tag: Optional[str] = Field(None, description=\"An optional tag (alphanumeric, max 20 chars) to identify the order.\", max_length=20)\n\n    @validator('price', always=True)\n    def check_price(cls, v, values):\n        order_type = values.get('order_type')\n        if order_type in [OrderType.LIMIT, OrderType.SL] and v is None:\n            raise ValueError('Price is required for LIMIT and SL order types')\n        if order_type not in [OrderType.LIMIT, OrderType.SL] and v is not None:\n             # Kite Connect API might ignore it, but better to be explicit\n             pass # Allow setting price even if not strictly needed, API might handle it\n        return v\n\n    @validator('trigger_price', always=True)\n    def check_trigger_price(cls, v, values):\n        order_type = values.get('order_type')\n        if order_type in [OrderType.SL, OrderType.SLM] and v is None:\n            raise ValueError('Trigger price is required for SL and SL-M order types')\n        if order_type not in [OrderType.SL, OrderType.SLM] and v is not None:\n            # Kite Connect API might ignore it\n            pass # Allow setting trigger_price even if not strictly needed\n        return v\n\n    @validator('validity_ttl', always=True)\n    def check_validity_ttl(cls, v, values):\n        validity = values.get('validity')\n        if validity == Validity.TTL and v is None:\n            raise ValueError('validity_ttl is required when validity is TTL')\n        if validity != Validity.TTL and v is not None:\n            raise ValueError('validity_ttl is only applicable when validity is TTL')\n        return v\n\n    @validator('iceberg_legs', always=True)\n    def check_iceberg_legs(cls, v, values):\n        variety = values.get('variety')\n        if variety == Variety.ICEBERG and v is None:\n            raise ValueError('iceberg_legs is required when variety is iceberg')\n        if variety != Variety.ICEBERG and v is not None:\n            raise ValueError('iceberg_legs is only applicable when variety is iceberg')\n        return v\n\n    @validator('iceberg_quantity', always=True)\n    def check_iceberg_quantity(cls, v, values):\n        variety = values.get('variety')\n        quantity = values.get('quantity')\n        iceberg_legs = values.get('iceberg_legs')\n\n        if variety == Variety.ICEBERG:\n            if v is None:\n                raise ValueError('iceberg_quantity is required when variety is iceberg')\n            if quantity is not None and iceberg_legs is not None and v * iceberg_legs != quantity:\n                 # Zerodha docs imply it should be quantity/legs, but API might just need quantity > iceberg_quantity\n                 # Let's enforce the stricter check for clarity, can be relaxed if needed.\n                 # raise ValueError('iceberg_quantity * iceberg_legs must equal total quantity')\n                 # Relaxed check: ensure iceberg_quantity is less than total quantity\n                 if v >= quantity:\n                     raise ValueError('iceberg_quantity must be less than the total quantity')\n            if quantity is not None and v is not None and quantity < v:\n                 raise ValueError('iceberg_quantity cannot be greater than total quantity')\n\n        if variety != Variety.ICEBERG and v is not None:\n            raise ValueError('iceberg_quantity is only applicable when variety is iceberg')\n        return v\n\n    @validator('auction_number', always=True)\n    def check_auction_number(cls, v, values):\n        variety = values.get('variety')\n        if variety == Variety.AUCTION and v is None:\n            raise ValueError('auction_number is required when variety is auction')\n        if variety != Variety.AUCTION and v is not None:\n            raise ValueError('auction_number is only applicable when variety is auction')\n        return v\n\nclass ModifyOrderParams(BaseModel):\n    variety: Variety = Field(..., description=\"Order variety (typically regular or co). Check API docs for others.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    parent_order_id: Optional[str] = Field(None, description=\"The parent order ID if modifying a second leg of a CO.\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (for regular orders).\", gt=0)\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders).\", ge=0)\n    order_type: Optional[OrderType] = Field(None, description=\"New order type (only for regular orders, e.g., LIMIT, SL). Cannot change to/from MARKET.\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, CO orders).\", ge=0)\n    validity: Optional[Validity] = Field(None, description=\"New validity (only for regular orders, DAY or IOC). Cannot change to TTL.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (for regular equity orders).\", ge=0)\n\n    @validator('validity')\n    def check_validity(cls, v):\n        if v == Validity.TTL:\n            raise ValueError(\"Cannot modify validity to TTL\")\n        return v\n\n    @validator('order_type')\n    def check_order_type(cls, v):\n        if v == OrderType.MARKET:\n             # Generally cannot modify TO market, or FROM market if already placed\n             # Let API handle specific rejection, but flag potential issue\n             pass\n        return v\n\nclass CancelOrderParams(BaseModel):\n    variety: Variety = Field(..., description=\"Order variety (regular, co, amo, iceberg, auction).\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel.\")\n    parent_order_id: Optional[str] = Field(None, description=\"The parent order ID if cancelling a second leg of a CO.\")\n\n# --- Return Models (Optional, can use Dict directly) ---\n\nclass OrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID.\")\n\nclass ErrorResponse(BaseModel):\n    error: str = Field(..., description=\"Description of the error.\")\n    details: Optional[Dict[str, Any]] = Field(None, description=\"Additional error details, if available.\")\n"
    },
    {
      "name": "client.py",
      "content": "import logging\nfrom typing import Optional, Dict, Any, List\nfrom kiteconnect import KiteConnect\nfrom kiteconnect import exceptions as kite_ex\n\nlogger = logging.getLogger(__name__)\n\n# Custom Exception for clarity in MCP layer\nclass KiteClientError(Exception):\n    def __init__(self, message: str, original_exception: Exception = None, details: Optional[Dict[str, Any]] = None):\n        self.message = message\n        self.original_exception = original_exception\n        self.details = details or {}\n        if isinstance(original_exception, kite_ex.KiteException):\n            # Add KiteException specific details if available\n            self.details['kite_code'] = getattr(original_exception, 'code', None)\n            self.details['kite_message'] = getattr(original_exception, 'message', None)\n        super().__init__(self.message)\n\nclass KiteConnectClient:\n    \"\"\"Client to interact with the Zerodha Kite Connect API using pykiteconnect.\"\"\"\n\n    def __init__(self, api_key: Optional[str], access_token: Optional[str]):\n        \"\"\"\n        Initializes the Kite Connect client.\n\n        Args:\n            api_key: The API key obtained from Zerodha Kite Developer.\n            access_token: The access token obtained after successful login flow.\n                      Note: This token is short-lived and needs periodic regeneration.\n                      MCP server needs a mechanism to refresh/update this token.\n        \"\"\"\n        if not api_key:\n            logger.error(\"Kite API Key is required for KiteConnectClient.\")\n            raise ValueError(\"Kite API Key not provided.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self._kite = KiteConnect(api_key=self.api_key)\n\n        if self.access_token:\n            try:\n                self._kite.set_access_token(self.access_token)\n                logger.info(\"KiteConnect client initialized and access token set.\")\n            except Exception as e:\n                logger.error(f\"Failed to initialize KiteConnect with provided access token: {e}\")\n                # Don't raise here, allow initialization but operations will fail until token is valid\n                self.access_token = None # Mark token as invalid\n        else:\n            logger.warning(\"KiteConnect client initialized without an access token. API calls will fail.\")\n\n    def _ensure_token(self):\n        \"\"\"Checks if the access token is set.\"\"\"\n        if not self.access_token or not self._kite.access_token:\n            logger.error(\"Kite API Access Token is not set or invalid.\")\n            raise KiteClientError(\"Kite API Access Token is missing or invalid.\",\n                                  original_exception=kite_ex.TokenException(\"Access token not set\"))\n\n    def _handle_api_error(self, error: Exception, operation: str) -> KiteClientError:\n        \"\"\"Maps KiteConnect exceptions to KiteClientError.\"\"\"\n        logger.error(f\"Kite API error during {operation}: {type(error).__name__} - {error}\", exc_info=False)\n\n        if isinstance(error, kite_ex.InputException):\n            return KiteClientError(f\"Invalid input for {operation}: {error.message}\", error)\n        elif isinstance(error, kite_ex.TokenException):\n            # Access token might have expired or is invalid\n            self.access_token = None # Clear potentially invalid token\n            self._kite.set_access_token(None)\n            return KiteClientError(f\"Authentication error (token invalid/expired?): {error.message}\", error)\n        elif isinstance(error, kite_ex.PermissionException):\n            return KiteClientError(f\"Permission denied for {operation}: {error.message}\", error)\n        elif isinstance(error, kite_ex.OrderException):\n            return KiteClientError(f\"Order placement/modification error: {error.message}\", error)\n        elif isinstance(error, kite_ex.NetworkException):\n            return KiteClientError(f\"Network error connecting to Kite API: {error.message}\", error)\n        elif isinstance(error, kite_ex.GeneralException):\n            return KiteClientError(f\"General Kite API error: {error.message}\", error)\n        elif isinstance(error, kite_ex.DataException):\n             return KiteClientError(f\"Kite Data error: {error.message}\", error)\n        else:\n            # Catch-all for unexpected errors\n            return KiteClientError(f\"An unexpected error occurred during {operation}: {str(error)}\", error)\n\n    def place_order(self, variety: str, exchange: str, tradingsymbol: str,\n                      transaction_type: str, quantity: int, product: str,\n                      order_type: str, price: Optional[float] = None,\n                      validity: Optional[str] = None, disclosed_quantity: Optional[int] = None,\n                      trigger_price: Optional[float] = None, tag: Optional[str] = None,\n                      iceberg_legs: Optional[int] = None, iceberg_quantity: Optional[int] = None,\n                      auction_number: Optional[str] = None, validity_ttl: Optional[int] = None) -> Dict[str, str]:\n        \"\"\"Places an order.\"\"\"\n        self._ensure_token()\n        try:\n            # Filter out None values as pykiteconnect expects absence of key, not None value\n            params = {\n                k: v for k, v in locals().items()\n                if k not in ['self', 'variety'] and v is not None\n            }\n            logger.debug(f\"Placing order with params: variety={variety}, other_params={params}\")\n            order_id = self._kite.place_order(variety=variety, **params)\n            logger.info(f\"Successfully placed order: {order_id}\")\n            return {\"order_id\": order_id}\n        except Exception as e:\n            raise self._handle_api_error(e, \"place_order\")\n\n    def modify_order(self, variety: str, order_id: str,\n                       parent_order_id: Optional[str] = None, quantity: Optional[int] = None,\n                       price: Optional[float] = None, order_type: Optional[str] = None,\n                       trigger_price: Optional[float] = None, validity: Optional[str] = None,\n                       disclosed_quantity: Optional[int] = None) -> Dict[str, str]:\n        \"\"\"Modifies a pending order.\"\"\"\n        self._ensure_token()\n        try:\n            params = {\n                k: v for k, v in locals().items()\n                if k not in ['self', 'variety', 'order_id'] and v is not None\n            }\n            logger.debug(f\"Modifying order: variety={variety}, order_id={order_id}, params={params}\")\n            order_id_resp = self._kite.modify_order(variety=variety, order_id=order_id, **params)\n            logger.info(f\"Successfully modified order {order_id}: {order_id_resp}\")\n            return {\"order_id\": order_id_resp}\n        except Exception as e:\n            raise self._handle_api_error(e, \"modify_order\")\n\n    def cancel_order(self, variety: str, order_id: str,\n                       parent_order_id: Optional[str] = None) -> Dict[str, str]:\n        \"\"\"Cancels a pending order.\"\"\"\n        self._ensure_token()\n        try:\n            params = {\n                k: v for k, v in locals().items()\n                if k not in ['self', 'variety', 'order_id'] and v is not None\n            }\n            logger.debug(f\"Cancelling order: variety={variety}, order_id={order_id}, params={params}\")\n            order_id_resp = self._kite.cancel_order(variety=variety, order_id=order_id, **params)\n            logger.info(f\"Successfully cancelled order {order_id}: {order_id_resp}\")\n            return {\"order_id\": order_id_resp}\n        except Exception as e:\n            raise self._handle_api_error(e, \"cancel_order\")\n\n    # --- Placeholder for other potential methods --- \n\n    # def get_orders(self) -> List[Dict[str, Any]]:\n    #     \"\"\"Retrieves the list of orders for the day.\"\"\"\n    #     self._ensure_token()\n    #     try:\n    #         logger.debug(\"Fetching orders\")\n    #         orders = self._kite.orders()\n    #         logger.info(f\"Successfully fetched {len(orders)} orders.\")\n    #         return orders\n    #     except Exception as e:\n    #         raise self._handle_api_error(e, \"get_orders\")\n\n    # def get_trades(self, order_id: Optional[str] = None) -> List[Dict[str, Any]]:\n    #     \"\"\"Retrieves the list of trades for the day or for a specific order.\"\"\"\n    #     self._ensure_token()\n    #     try:\n    #         if order_id:\n    #             logger.debug(f\"Fetching trades for order_id: {order_id}\")\n    #             trades = self._kite.order_trades(order_id=order_id)\n    #             logger.info(f\"Successfully fetched {len(trades)} trades for order {order_id}.\")\n    #         else:\n    #             logger.debug(\"Fetching all trades for the day\")\n    #             trades = self._kite.trades()\n    #             logger.info(f\"Successfully fetched {len(trades)} trades for the day.\")\n    #         return trades\n    #     except Exception as e:\n    #         raise self._handle_api_error(e, \"get_trades\")\n\n    # def get_instruments(self, exchange: Optional[str] = None) -> List[Dict[str, Any]]:\n    #     \"\"\"Retrieves the list of instruments.\"\"\"\n    #     # No token needed for this usually\n    #     try:\n    #         logger.debug(f\"Fetching instruments for exchange: {exchange or 'all'}\")\n    #         instruments = self._kite.instruments(exchange=exchange)\n    #         logger.info(f\"Successfully fetched {len(instruments)} instruments.\")\n    #         return instruments\n    #     except Exception as e:\n    #         raise self._handle_api_error(e, \"get_instruments\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=1.10,<2.0\n# OR if using Pydantic v2:\n# pydantic>=2.0\npython-dotenv>=1.0.0\n# Specify the correct version of pykiteconnect you intend to use\npykiteconnect>=3.9.0,<4.0\nuvicorn>=0.20.0\n# httpx is used by fastmcp and potentially pykiteconnect internally\nhttpx>=0.23.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Zerodha Kite Connect API Credentials\n# Obtain these from https://developers.kite.trade/\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# This is a short-lived token obtained after the login flow.\n# You MUST have a mechanism to generate/refresh this token and update this variable.\n# The MCP server reads this at startup. If it expires, the server needs restart or dynamic update.\nKITE_ACCESS_TOKEN=\"YOUR_INITIAL_ACCESS_TOKEN\"\n\n# Optional: Set log level for Uvicorn if needed\n# LOG_LEVEL=info\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect MCP Server\n\nThis project implements a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect trading API (v3/v4) using the `pykiteconnect` library and `FastMCP`.\n\nIt provides tools for managing trading orders:\n*   Placing new orders\n*   Modifying existing pending orders\n*   Cancelling existing pending orders\n\n## Features\n\n*   Exposes Kite Connect order management functions as MCP tools.\n*   Uses Pydantic for robust data validation.\n*   Handles Kite Connect API exceptions gracefully.\n*   Loads API credentials securely from environment variables.\n*   Asynchronous server implementation using FastMCP.\n\n## Prerequisites\n\n*   Python 3.8+\n*   A Zerodha Kite Connect API key and secret.\n*   A valid `access_token` obtained through the Kite Connect login flow.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <your-repo-url>\n    cd <your-repo-directory>\n    ```\n\n2.  **Create a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    Create a `.env` file in the project root directory by copying the example:\n    ```bash\n    cp .env.example .env\n    ```\n    Edit the `.env` file and add your Kite Connect API key and a valid access token:\n    ```env\n    KITE_API_KEY=\"YOUR_API_KEY\"\n    KITE_ACCESS_TOKEN=\"YOUR_VALID_ACCESS_TOKEN\"\n    ```\n    **Important:** The `KITE_ACCESS_TOKEN` is short-lived (typically valid for one day). You need a separate process or script to generate this token daily (using your API key and secret via the Kite Connect login flow) and update the `.env` file or environment variable before starting the MCP server.\n\n## Running the Server\n\nUse Uvicorn to run the FastMCP application:\n\n```bash\nuvicorn main:mcp --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port number.\n*   `--reload`: Automatically restarts the server when code changes (useful for development).\n\nThe server will start, and the MCP endpoint will be available at `http://localhost:8000/mcp`.\n\n## Available Tools\n\nThe following tools are exposed via the MCP server:\n\n### 1. `place_order`\n\n*   **Description:** Places an order of a specified variety.\n*   **Input Model:** `PlaceOrderParams`\n    *   `variety`: `Variety` (Enum: regular, amo, co, iceberg, auction) - **Required**\n    *   `tradingsymbol`: `str` - **Required**\n    *   `exchange`: `Exchange` (Enum: NSE, BSE, NFO, CDS, MCX, BCD, BFO) - **Required**\n    *   `transaction_type`: `TransactionType` (Enum: BUY, SELL) - **Required**\n    *   `quantity`: `int` (> 0) - **Required**\n    *   `product`: `Product` (Enum: CNC, NRML, MIS, MTF) - **Required**\n    *   `order_type`: `OrderType` (Enum: MARKET, LIMIT, SL, SL-M) - **Required**\n    *   `price`: `Optional[float]` (>= 0) - Required for LIMIT, SL orders.\n    *   `trigger_price`: `Optional[float]` (>= 0) - Required for SL, SL-M orders.\n    *   `disclosed_quantity`: `Optional[int]` (>= 0)\n    *   `validity`: `Optional[Validity]` (Enum: DAY, IOC, TTL) - Default: DAY\n    *   `validity_ttl`: `Optional[int]` (1-1440) - Required if validity is TTL.\n    *   `iceberg_legs`: `Optional[int]` (2-10) - Required if variety is iceberg.\n    *   `iceberg_quantity`: `Optional[int]` (>= 1) - Required if variety is iceberg.\n    *   `auction_number`: `Optional[str]` - Required if variety is auction.\n    *   `tag`: `Optional[str]` (max 20 chars)\n*   **Returns:** `Dict[str, str]` - e.g., `{\"order_id\": \"230720000000001\"}` on success, or `{\"error\": \"...\", \"details\": {...}}` on failure.\n\n### 2. `modify_order`\n\n*   **Description:** Modifies attributes of a pending regular or cover order.\n*   **Input Model:** `ModifyOrderParams`\n    *   `variety`: `Variety` (Enum: regular, co, etc.) - **Required**\n    *   `order_id`: `str` - **Required**\n    *   `parent_order_id`: `Optional[str]`\n    *   `quantity`: `Optional[int]` (> 0)\n    *   `price`: `Optional[float]` (>= 0)\n    *   `order_type`: `Optional[OrderType]` (Cannot change to/from MARKET)\n    *   `trigger_price`: `Optional[float]` (>= 0)\n    *   `validity`: `Optional[Validity]` (Enum: DAY, IOC - Cannot change to TTL)\n    *   `disclosed_quantity`: `Optional[int]` (>= 0)\n*   **Returns:** `Dict[str, str]` - e.g., `{\"order_id\": \"230720000000001\"}` on success, or `{\"error\": \"...\", \"details\": {...}}` on failure.\n\n### 3. `cancel_order`\n\n*   **Description:** Cancels a pending regular or cover order.\n*   **Input Model:** `CancelOrderParams`\n    *   `variety`: `Variety` (Enum: regular, co, amo, iceberg, auction) - **Required**\n    *   `order_id`: `str` - **Required**\n    *   `parent_order_id`: `Optional[str]`\n*   **Returns:** `Dict[str, str]` - e.g., `{\"order_id\": \"230720000000001\"}` on success, or `{\"error\": \"...\", \"details\": {...}}` on failure.\n\n## Error Handling\n\nThe server catches exceptions from the `pykiteconnect` library and returns a JSON response with an `error` key containing a descriptive message and optionally a `details` key with more specific information (like Kite API error codes).\n\nCommon errors include:\n*   `InputException`: Invalid parameters provided.\n*   `TokenException`: Invalid or expired `access_token`.\n*   `PermissionException`: API key doesn't have permission for the action.\n*   `OrderException`: Order placement/modification/cancellation failed (e.g., insufficient funds, validation errors).\n*   `NetworkException`: Could not connect to the Kite API servers.\n*   `GeneralException`: Other API-level errors.\n\n## Rate Limiting\n\nThe Kite Connect API has rate limits (e.g., 3 requests per second for order operations). This MCP server currently relies on `pykiteconnect`'s internal handling or expects the user to manage call frequency. Exceeding limits will result in errors from the API.\n\n## TODO / Potential Enhancements\n\n*   Implement dynamic `access_token` refresh mechanism.\n*   Add tools for other Kite Connect functionalities (fetching orders, trades, positions, holdings, instruments, historical data, MF orders, GTT orders).\n*   Implement WebSocket connection for live market data streaming (would require significant changes).\n*   Add explicit rate limiting within the MCP server.\n*   More sophisticated configuration management.\n*   Add unit and integration tests.\n"
    }
  ]
}
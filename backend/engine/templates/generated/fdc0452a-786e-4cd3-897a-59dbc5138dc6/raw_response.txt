{
  "files": [
    {
      "name": "main.py",
      "content": "import logging\nimport os\nfrom typing import Dict, Any\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import (KiteConnectClient, KiteConnectError, InputException,\n                    TokenException, PermissionException, NetworkException,\n                    GeneralException)\nfrom models import (PlaceOrderParams, ModifyOrderParams, CancelOrderParams,\n                    OrderIdResponse)\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO,\n                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectOrders\",\n    description=\"Provides tools to manage trading orders (place, modify, cancel) using the Kite Connect API v3.\"\n)\n\n# Initialize API Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n    # Optionally raise an error or exit\n    # raise ValueError(\"API Key and Access Token are required.\")\n    # For now, allow initialization but client calls will fail\n    api_client = None\nelse:\n    try:\n        api_client = KiteConnectClient(api_key=api_key, access_token=access_token, base_url=base_url)\n    except Exception as e:\n        logger.error(f\"Failed to initialize KiteConnectClient: {e}\")\n        api_client = None\n\ndef handle_api_error(tool_name: str, error: Exception) -> Dict[str, Any]:\n    \"\"\"Handles errors from the API client and returns a standardized error response.\"\"\"\n    logger.error(f\"Error in tool '{tool_name}': {type(error).__name__} - {error}\")\n    if isinstance(error, KiteConnectError):\n        return {\"error\": type(error).__name__, \"message\": str(error), \"status_code\": getattr(error, 'status_code', None)}\n    else:\n        return {\"error\": \"InternalServerError\", \"message\": f\"An unexpected error occurred: {error}\"}\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Places an order of a specified variety.\n\n    Args:\n        params: Parameters for placing the order.\n\n    Returns:\n        A dictionary containing the order_id upon success, or an error message.\n    \"\"\"\n    if not api_client:\n        return handle_api_error(\"place_order\", Exception(\"API Client not initialized. Check environment variables.\"))\n\n    logger.info(f\"Executing place_order with variety: {params.variety}\")\n    try:\n        result: OrderIdResponse = await api_client.place_order(params)\n        logger.info(f\"Successfully placed order: {result.order_id}\")\n        return result.dict()\n    except Exception as e:\n        return handle_api_error(\"place_order\", e)\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modifies attributes of an open or pending order.\n\n    Args:\n        params: Parameters for modifying the order.\n\n    Returns:\n        A dictionary containing the order_id upon success, or an error message.\n    \"\"\"\n    if not api_client:\n        return handle_api_error(\"modify_order\", Exception(\"API Client not initialized. Check environment variables.\"))\n\n    logger.info(f\"Executing modify_order for order_id: {params.order_id}, variety: {params.variety}\")\n    try:\n        result: OrderIdResponse = await api_client.modify_order(params)\n        logger.info(f\"Successfully modified order: {result.order_id}\")\n        return result.dict()\n    except Exception as e:\n        return handle_api_error(\"modify_order\", e)\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"Cancels an open or pending order.\n\n    Args:\n        params: Parameters for cancelling the order.\n\n    Returns:\n        A dictionary containing the order_id upon success, or an error message.\n    \"\"\"\n    if not api_client:\n        return handle_api_error(\"cancel_order\", Exception(\"API Client not initialized. Check environment variables.\"))\n\n    logger.info(f\"Executing cancel_order for order_id: {params.order_id}, variety: {params.variety}\")\n    try:\n        result: OrderIdResponse = await api_client.cancel_order(params)\n        logger.info(f\"Successfully cancelled order: {result.order_id}\")\n        return result.dict()\n    except Exception as e:\n        return handle_api_error(\"cancel_order\", e)\n\nif __name__ == \"__main__\":\n    # Example of how to run the server using uvicorn\n    # You would typically run this using: uvicorn main:mcp.app --reload\n    import uvicorn\n    logger.info(\"Starting KiteConnectOrders MCP Server\")\n    if not api_client:\n        logger.warning(\"API Client is not initialized. Tools will return errors. Ensure KITE_API_KEY and KITE_ACCESS_TOKEN are set.\")\n    uvicorn.run(mcp.app, host=\"0.0.0.0\", port=8000)\n"
    },
    {
      "name": "models.py",
      "content": "from typing import Optional, Literal, Dict, Any\nfrom pydantic import BaseModel, Field, validator\n\n# --- Custom Exceptions ---\nclass KiteConnectError(Exception):\n    \"\"\"Base exception class for Kite Connect client errors.\"\"\"\n    def __init__(self, message, status_code=None):\n        super().__init__(message)\n        self.status_code = status_code\n\nclass InputException(KiteConnectError):\n    \"\"\"Invalid input parameters.\"\"\"\n    pass\n\nclass TokenException(KiteConnectError):\n    \"\"\"Authentication failure (invalid API key or access token).\"\"\"\n    pass\n\nclass PermissionException(KiteConnectError):\n    \"\"\"Insufficient permissions for the action.\"\"\"\n    pass\n\nclass NetworkException(KiteConnectError):\n    \"\"\"Network connectivity issues with the API.\"\"\"\n    pass\n\nclass GeneralException(KiteConnectError):\n    \"\"\"General Kite Connect API errors (e.g., RMS rejections, insufficient funds, order state issues).\"\"\"\n    pass\n\nclass RateLimitException(KiteConnectError):\n    \"\"\"Rate limit exceeded.\"\"\"\n    pass\n\n# --- Input Models ---\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\"\"\"\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'] = Field(..., description=\"Name of the exchange.\")\n    transaction_type: Literal['BUY', 'SELL'] = Field(..., description=\"Transaction type.\")\n    order_type: Literal['MARKET', 'LIMIT', 'SL', 'SL-M'] = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: Literal['CNC', 'NRML', 'MIS', 'MTF'] = Field(..., description=\"Product type (margin product).\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (required for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (required for SL, SL-M orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity: Literal['DAY', 'IOC', 'TTL'] = Field('DAY', description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10).\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order.\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction (for auction variety).\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"An optional tag (alphanumeric, max 20 chars) to identify the order.\")\n\n    @validator('price', always=True)\n    def check_price_for_limit(cls, v, values):\n        if values.get('order_type') == 'LIMIT' and v is None:\n            raise ValueError('Price is required for LIMIT orders')\n        if values.get('order_type') != 'LIMIT' and v is not None:\n            # Kite might implicitly ignore it, but better to be explicit or validate based on API behavior\n            pass # Allow price for other types if API permits, otherwise raise ValueError\n        return v\n\n    @validator('trigger_price', always=True)\n    def check_trigger_price_for_sl(cls, v, values):\n        if values.get('order_type') in ('SL', 'SL-M') and v is None:\n            raise ValueError('Trigger price is required for SL and SL-M orders')\n        if values.get('order_type') not in ('SL', 'SL-M') and v is not None:\n             # Allow trigger_price for other types if API permits, otherwise raise ValueError\n            pass\n        return v\n\n    @validator('validity_ttl', always=True)\n    def check_validity_ttl(cls, v, values):\n        if values.get('validity') == 'TTL' and v is None:\n            raise ValueError('validity_ttl is required for TTL validity')\n        if values.get('validity') != 'TTL' and v is not None:\n            raise ValueError('validity_ttl is only applicable for TTL validity')\n        return v\n\n    @validator('iceberg_legs', 'iceberg_quantity', always=True)\n    def check_iceberg_params(cls, v, values, field):\n        is_iceberg = values.get('variety') == 'iceberg'\n        if is_iceberg and field.name == 'iceberg_legs' and (v is None or not (2 <= v <= 10)):\n            raise ValueError('iceberg_legs must be between 2 and 10 for iceberg orders')\n        if is_iceberg and field.name == 'iceberg_quantity' and v is None:\n            raise ValueError('iceberg_quantity is required for iceberg orders')\n        if not is_iceberg and v is not None:\n            raise ValueError(f'{field.name} is only applicable for iceberg variety')\n        return v\n\n    @validator('auction_number', always=True)\n    def check_auction_number(cls, v, values):\n        if values.get('variety') == 'auction' and v is None:\n            raise ValueError('auction_number is required for auction variety')\n        if values.get('variety') != 'auction' and v is not None:\n            raise ValueError('auction_number is only applicable for auction variety')\n        return v\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Parameters for modifying an order.\"\"\"\n    variety: Literal['regular', 'co', 'amo', 'iceberg'] = Field(..., description=\"Order variety to modify.\")\n    order_id: str = Field(..., description=\"The unique order ID to modify.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Parent order id for second leg CO modification.\")\n    order_type: Optional[Literal['MARKET', 'LIMIT', 'SL', 'SL-M']] = Field(None, description=\"New order type (Regular orders only).\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity (Regular orders only).\")\n    price: Optional[float] = Field(None, description=\"New price (Regular LIMIT, CO LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (Regular SL/SL-M, CO orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (Regular orders only).\")\n    validity: Optional[Literal['DAY', 'IOC', 'TTL']] = Field(None, description=\"New validity (Regular orders only).\")\n\n    @validator('order_type', 'quantity', 'disclosed_quantity', 'validity', always=True)\n    def check_regular_only_fields(cls, v, values, field):\n        # These fields are typically only modifiable for 'regular' variety according to docs/common practice\n        # Adjust validation based on exact API capabilities if needed\n        if values.get('variety') != 'regular' and v is not None:\n            # Log a warning or raise error if strict validation is desired\n            # print(f\"Warning: Field '{field.name}' might only be applicable for 'regular' variety.\")\n            pass # Allow modification attempt, let API handle validity\n        return v\n\n    @validator('parent_order_id', always=True)\n    def check_parent_order_id(cls, v, values):\n        if values.get('variety') == 'co' and v is None:\n            # Parent ID might be needed for second leg CO mods, depends on API specifics\n            pass # Assume optional unless API strictly requires it\n        if values.get('variety') != 'co' and v is not None:\n            raise ValueError(\"parent_order_id is only applicable for CO variety modifications\")\n        return v\n\nclass CancelOrderParams(BaseModel):\n    \"\"\"Parameters for cancelling an order.\"\"\"\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety to cancel.\")\n    order_id: str = Field(..., description=\"The unique order ID to cancel.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Parent order id for second leg CO cancellation.\")\n\n    @validator('parent_order_id', always=True)\n    def check_parent_order_id(cls, v, values):\n        if values.get('variety') != 'co' and v is not None:\n            raise ValueError(\"parent_order_id is only applicable for CO variety cancellations\")\n        return v\n\n# --- Output Models ---\n\nclass OrderIdResponseData(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID assigned by Kite Connect.\")\n\nclass OrderIdResponse(BaseModel):\n    \"\"\"Standard response containing the order ID.\"\"\"\n    # Kite API often wraps the response in {'status': 'success', 'data': {...}}\n    # This model directly represents the 'data' part for successful operations.\n    order_id: str = Field(..., description=\"The unique order ID assigned or affected.\")\n\nclass KiteApiResponse(BaseModel):\n    \"\"\"Generic structure for Kite API responses.\"\"\"\n    status: str\n    data: Optional[Dict[str, Any]] = None\n    message: Optional[str] = None\n    error_type: Optional[str] = None\n"
    },
    {
      "name": "client.py",
      "content": "import logging\nfrom typing import Dict, Any, Optional\nimport httpx\nfrom pydantic import ValidationError\n\nfrom models import (\n    PlaceOrderParams, ModifyOrderParams, CancelOrderParams, OrderIdResponse,\n    KiteApiResponse, KiteConnectError, InputException, TokenException,\n    PermissionException, NetworkException, GeneralException, RateLimitException\n)\n\nlogger = logging.getLogger(__name__)\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with Kite Connect API v3 order endpoints.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        \"\"\"Initializes the Kite Connect client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after successful login.\n            base_url: The base URL for the Kite Connect API.\n            timeout: Default request timeout in seconds.\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API Key and Access Token cannot be empty.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self._timeout = timeout\n        self._headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            # Content-Type is set per request based on method\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self._headers,\n            timeout=self._timeout\n        )\n        logger.info(f\"KiteConnectClient initialized for base URL: {self.base_url}\")\n\n    async def _request(\n        self,\n        method: str,\n        endpoint: str,\n        params: Optional[Dict[str, Any]] = None,\n        data: Optional[Dict[str, Any]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite Connect API.\n\n        Args:\n            method: HTTP method (GET, POST, PUT, DELETE).\n            endpoint: API endpoint path (e.g., '/orders').\n            params: URL query parameters.\n            data: Request body data (for POST, PUT), sent as form-encoded.\n\n        Returns:\n            The parsed JSON response data upon success.\n\n        Raises:\n            NetworkException: For connection errors or timeouts.\n            RateLimitException: If rate limit (429) is hit.\n            TokenException: For authentication errors (403).\n            InputException: For client-side validation errors (400).\n            PermissionException: For permission denied errors (403).\n            GeneralException: For other API-specific errors (non-2xx status codes).\n            KiteConnectError: For unexpected errors during request/response handling.\n        \"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        headers = self._headers.copy()\n        request_kwargs = {\n            \"method\": method,\n            \"url\": url,\n            \"params\": params,\n            \"headers\": headers\n        }\n\n        # Kite API expects form data for POST/PUT\n        if data:\n            # Filter out None values from data payload\n            filtered_data = {k: v for k, v in data.items() if v is not None}\n            request_kwargs[\"data\"] = filtered_data\n            headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        else:\n            # Ensure Content-Type is not set if there's no body data\n            if \"Content-Type\" in headers:\n                del headers[\"Content-Type\"]\n\n        logger.debug(f\"Request: {method} {url} Params: {params} Data: {data}\")\n\n        try:\n            response = await self.client.request(**request_kwargs)\n            logger.debug(f\"Response Status: {response.status_code} Body: {response.text[:500]}\") # Log truncated body\n\n            # Handle different status codes\n            if response.status_code == 429:\n                raise RateLimitException(\"Rate limit exceeded.\", status_code=429)\n            if response.status_code == 403:\n                # Could be TokenException or PermissionException\n                # Check response body for specifics if available\n                try:\n                    resp_json = response.json()\n                    error_type = resp_json.get(\"error_type\")\n                    message = resp_json.get(\"message\", \"Forbidden.\")\n                    if error_type == \"TokenException\":\n                        raise TokenException(message, status_code=403)\n                    elif error_type == \"PermissionException\":\n                        raise PermissionException(message, status_code=403)\n                    else:\n                        raise TokenException(f\"Authentication/Authorization error: {message}\", status_code=403)\n                except (ValueError, KeyError):\n                    raise TokenException(\"Authentication/Authorization failed (403).\", status_code=403)\n\n            # Check for other client/server errors indicated by status code\n            response.raise_for_status()  # Raises HTTPStatusError for 4xx/5xx\n\n            # Parse successful response\n            response_json = response.json()\n            parsed_response = KiteApiResponse.parse_obj(response_json)\n\n            if parsed_response.status == \"success\":\n                return parsed_response.data or {} # Return data or empty dict if data is null\n            else:\n                # Handle errors reported in the JSON body even with 2xx status (if API does that)\n                error_type = parsed_response.error_type or \"GeneralException\"\n                message = parsed_response.message or \"Unknown API error\"\n                self._raise_specific_exception(error_type, message, response.status_code)\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out: {e}\")\n            raise NetworkException(f\"Request timed out after {self._timeout} seconds.\") from e\n        except httpx.RequestError as e:\n            logger.error(f\"Network request error: {e}\")\n            raise NetworkException(f\"Network error connecting to Kite API: {e}\") from e\n        except httpx.HTTPStatusError as e:\n            logger.error(f\"HTTP error: {e.status_code} - {e.response.text}\")\n            try:\n                resp_json = e.response.json()\n                error_type = resp_json.get(\"error_type\", \"GeneralException\")\n                message = resp_json.get(\"message\", f\"HTTP error {e.status_code}\")\n                self._raise_specific_exception(error_type, message, e.status_code)\n            except ValueError:\n                # If response is not JSON\n                self._raise_specific_exception(\"GeneralException\", f\"HTTP error {e.status_code}: {e.response.text}\", e.status_code)\n        except ValidationError as e:\n            logger.error(f\"Failed to parse API response: {e}\")\n            raise KiteConnectError(f\"Invalid API response format: {e}\") from e\n        except KiteConnectError: # Re-raise known exceptions\n            raise\n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during the API request: {e}\")\n            raise KiteConnectError(f\"An unexpected error occurred: {e}\") from e\n\n        # Should not be reached if error handling is correct\n        raise KiteConnectError(\"Reached unexpected end of _request method.\")\n\n    def _raise_specific_exception(self, error_type: str, message: str, status_code: Optional[int]):\n        \"\"\"Raises a specific exception based on the error type string.\"\"\"\n        exception_map = {\n            \"InputException\": InputException,\n            \"TokenException\": TokenException,\n            \"PermissionException\": PermissionException,\n            \"NetworkException\": NetworkException, # Less likely from API, more from client side\n            \"GeneralException\": GeneralException,\n            \"OrderException\": GeneralException, # Map specific API errors if needed\n            \"FundsException\": GeneralException,\n            \"RMSException\": GeneralException,\n            # Add more specific mappings as identified\n        }\n        exception_class = exception_map.get(error_type, GeneralException)\n        raise exception_class(message, status_code=status_code)\n\n    async def place_order(self, params: PlaceOrderParams) -> OrderIdResponse:\n        \"\"\"Places an order.\n\n        Args:\n            params: PlaceOrderParams object containing order details.\n\n        Returns:\n            OrderIdResponse containing the order ID.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Pydantic model converts to dict, httpx handles form encoding\n        data = params.dict(exclude={'variety'}) # Variety is in the path\n        logger.info(f\"Placing order: {data}\")\n        response_data = await self._request(\"POST\", endpoint, data=data)\n        try:\n            return OrderIdResponse.parse_obj(response_data)\n        except ValidationError as e:\n            logger.error(f\"Failed to parse place_order response: {response_data}, Error: {e}\")\n            raise KiteConnectError(f\"Invalid response format for place_order: {e}\") from e\n\n    async def modify_order(self, params: ModifyOrderParams) -> OrderIdResponse:\n        \"\"\"Modifies an existing order.\n\n        Args:\n            params: ModifyOrderParams object containing modification details.\n\n        Returns:\n            OrderIdResponse containing the order ID.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        data = params.dict(exclude={'variety', 'order_id'}) # Path parameters excluded\n        logger.info(f\"Modifying order {params.order_id}: {data}\")\n        response_data = await self._request(\"PUT\", endpoint, data=data)\n        try:\n            # Modify response also returns {'order_id': '...'}\n            return OrderIdResponse.parse_obj(response_data)\n        except ValidationError as e:\n            logger.error(f\"Failed to parse modify_order response: {response_data}, Error: {e}\")\n            raise KiteConnectError(f\"Invalid response format for modify_order: {e}\") from e\n\n    async def cancel_order(self, params: CancelOrderParams) -> OrderIdResponse:\n        \"\"\"Cancels an existing order.\n\n        Args:\n            params: CancelOrderParams object containing cancellation details.\n\n        Returns:\n            OrderIdResponse containing the order ID.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # DELETE requests might need parameters in query or body depending on API spec.\n        # Kite API DELETE for orders uses path params and potentially parent_order_id in query/body.\n        # Assuming parent_order_id goes in query params if needed, but it's usually not required for DELETE.\n        query_params = {}\n        if params.parent_order_id:\n             # Check Kite Docs: Does DELETE take parent_order_id? If so, where? Assuming query for now.\n             # query_params['parent_order_id'] = params.parent_order_id\n             # Or maybe it should be in data? Unlikely for DELETE.\n             logger.warning(\"parent_order_id specified for cancel_order, but its placement (query/body) is ambiguous based on standard REST/Kite docs. Ignoring for now.\")\n\n        logger.info(f\"Cancelling order {params.order_id} (variety: {params.variety})\")\n        response_data = await self._request(\"DELETE\", endpoint, params=query_params)\n        try:\n            # Cancel response also returns {'order_id': '...'}\n            return OrderIdResponse.parse_obj(response_data)\n        except ValidationError as e:\n            logger.error(f\"Failed to parse cancel_order response: {response_data}, Error: {e}\")\n            raise KiteConnectError(f\"Invalid response format for cancel_order: {e}\") from e\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=1.9.0,<2.0.0\nhttpx>=0.23.0\npython-dotenv>=0.19.0\nuvicorn>=0.17.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer Console: https://developers.kite.trade/\n\n# Your unique API key\nKITE_API_KEY=\n\n# The access token obtained after a successful login flow (valid for one day)\n# You will need to generate this daily or use a mechanism to refresh it.\nKITE_ACCESS_TOKEN=\n\n# Base URL for the Kite Connect API (usually does not need changing)\nKITE_BASE_URL=https://api.kite.trade\n"
    },
    {
      "name": "README.md",
      "content": "# KiteConnect Orders MCP Server\n\nThis project implements a Model Context Protocol (MCP) server for interacting with the order management endpoints of the Zerodha Kite Connect API v3. It allows language models or other applications to place, modify, and cancel trading orders programmatically via a standardized MCP interface.\n\nThis MCP focuses specifically on the order-related actions and does not cover other Kite Connect functionalities like fetching positions, holdings, market data, etc.\n\n## Features\n\n*   **Place Orders:** Place new orders of various types (regular, AMO, CO, Iceberg, Auction).\n*   **Modify Orders:** Modify pending orders (quantity, price, trigger price, etc.).\n*   **Cancel Orders:** Cancel pending orders.\n*   **Typed Inputs:** Uses Pydantic models for clear and validated input parameters.\n*   **Error Handling:** Maps Kite Connect API errors to specific exceptions and provides informative error messages.\n*   **Asynchronous:** Built with `asyncio` and `httpx` for non-blocking I/O.\n\n## Setup\n\n1.  **Clone the Repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a Virtual Environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install Dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect API credentials:\n        *   `KITE_API_KEY`: Your application's API key.\n        *   `KITE_ACCESS_TOKEN`: A valid access token obtained through the Kite Connect login flow. **Note:** Access tokens are typically valid for only one day. You need a mechanism to generate/refresh this token regularly.\n        *   `KITE_BASE_URL`: (Optional) Defaults to `https://api.kite.trade`.\n\n## Running the Server\n\nUse Uvicorn to run the FastMCP application:\n\n```bash\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n*   `--reload`: Automatically restarts the server when code changes are detected (useful for development).\n\nThe MCP server will be available at `http://localhost:8000` (or the specified host/port).\n\n## Available Tools\n\nThe MCP server exposes the following tools:\n\n1.  **`place_order`**\n    *   **Description:** Places an order of a specified variety (regular, amo, co, iceberg, auction). Returns the `order_id` upon successful placement.\n    *   **Input Model:** `PlaceOrderParams` (see `models.py` for fields: `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, `price`, `trigger_price`, etc.)\n    *   **Returns:** `OrderIdResponse` (`{\"order_id\": \"string\"}`) on success, or an error dictionary (`{\"error\": \"ErrorType\", \"message\": \"...\"}`).\n\n2.  **`modify_order`**\n    *   **Description:** Modifies attributes of an open or pending order. Applicable parameters depend on the order variety.\n    *   **Input Model:** `ModifyOrderParams` (see `models.py` for fields: `variety`, `order_id`, `parent_order_id`, `order_type`, `quantity`, `price`, `trigger_price`, etc.)\n    *   **Returns:** `OrderIdResponse` (`{\"order_id\": \"string\"}`) on success, or an error dictionary.\n\n3.  **`cancel_order`**\n    *   **Description:** Cancels an open or pending order.\n    *   **Input Model:** `CancelOrderParams` (see `models.py` for fields: `variety`, `order_id`, `parent_order_id`)\n    *   **Returns:** `OrderIdResponse` (`{\"order_id\": \"string\"}`) on success, or an error dictionary.\n\n## Error Handling\n\nThe server attempts to catch errors from the Kite Connect API and return them in a structured format. Common error types include:\n\n*   `InputException`: Invalid parameters provided in the request.\n*   `TokenException`: Invalid or expired `api_key` or `access_token`.\n*   `PermissionException`: The API key doesn't have permission for the requested action.\n*   `NetworkException`: Could not connect to the Kite API servers or the request timed out.\n*   `GeneralException`: Other API-level errors (e.g., insufficient funds, RMS rejections, order already executed/cancelled).\n*   `RateLimitException`: Exceeded the allowed number of API requests per second.\n*   `InternalServerError`: An unexpected error occurred within the MCP server itself.\n\nThe error response typically looks like:\n`{\"error\": \"ErrorTypeName\", \"message\": \"Detailed error message from API or server\", \"status_code\": <HTTP_Status_Code>}`\n"
    }
  ]
}
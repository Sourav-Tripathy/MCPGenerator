{
  "files": [
    {
      "name": "main.py",
      "content": "import logging\nimport os\nfrom typing import Dict, Any\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import KiteConnectClient, KiteConnectError\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectOrders\",\n    description=\"MCP server for interacting with the Kite Connect Orders API (v3). Allows placing, modifying, cancelling, and retrieving orders and trades.\"\n)\n\n# Initialize Kite Connect Client\nAPI_KEY = os.getenv(\"KITE_API_KEY\")\nACCESS_TOKEN = os.getenv(\"KITE_ACCESS_TOKEN\")\nBASE_URL = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not API_KEY or not ACCESS_TOKEN:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables or .env file.\")\n    exit(1)\n\nkite_client = KiteConnectClient(api_key=API_KEY, access_token=ACCESS_TOKEN, base_url=BASE_URL)\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Place an order of a particular variety (regular, amo, co, iceberg, auction).\n\n    Args:\n        params: Parameters for placing the order.\n\n    Returns:\n        Dictionary containing the status and the order_id of the placed order.\n        Example: {'status': 'success', 'data': {'order_id': '151220000000000'}}\n        On error, returns: {'error': 'Error message'}\n    \"\"\"\n    logger.info(f\"Received place_order request: {params.dict(exclude_none=True)}\")\n    try:\n        result = await kite_client.place_order(params)\n        logger.info(f\"place_order successful: {result}\")\n        return result\n    except KiteConnectError as e:\n        logger.error(f\"Error placing order: {e}\")\n        return {\"error\": str(e)}\n    except Exception as e:\n        logger.exception(\"Unexpected error during place_order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Modify an open or pending order. Parameters depend on the order variety.\n\n    Args:\n        params: Parameters for modifying the order.\n\n    Returns:\n        Dictionary containing the status and the order_id of the modified order.\n        Example: {'status': 'success', 'data': {'order_id': '151220000000000'}}\n        On error, returns: {'error': 'Error message'}\n    \"\"\"\n    logger.info(f\"Received modify_order request: {params.dict(exclude_none=True)}\")\n    try:\n        result = await kite_client.modify_order(params)\n        logger.info(f\"modify_order successful: {result}\")\n        return result\n    except KiteConnectError as e:\n        logger.error(f\"Error modifying order: {e}\")\n        return {\"error\": str(e)}\n    except Exception as e:\n        logger.exception(\"Unexpected error during modify_order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Cancel an open or pending order.\n\n    Args:\n        params: Parameters for cancelling the order.\n\n    Returns:\n        Dictionary containing the status and the order_id of the cancelled order.\n        Example: {'status': 'success', 'data': {'order_id': '151220000000000'}}\n        On error, returns: {'error': 'Error message'}\n    \"\"\"\n    logger.info(f\"Received cancel_order request: {params.dict(exclude_none=True)}\")\n    try:\n        result = await kite_client.cancel_order(params)\n        logger.info(f\"cancel_order successful: {result}\")\n        return result\n    except KiteConnectError as e:\n        logger.error(f\"Error cancelling order: {e}\")\n        return {\"error\": str(e)}\n    except Exception as e:\n        logger.exception(\"Unexpected error during cancel_order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\nif __name__ == \"__main__\":\n    # For local development, run using uvicorn:\n    # uvicorn main:mcp.app --reload --port 8000\n    # The MCP server will be accessible according to FastMCP defaults.\n    # This block is mainly for informational purposes as FastMCP handles its own entry point.\n    logger.info(\"Starting KiteConnectOrders MCP Server.\")\n    logger.info(\"Run with: uvicorn main:mcp.app --host 0.0.0.0 --port 8000\")\n    # To run programmatically (though 'mcp.run()' is simpler for basic cases):\n    # import uvicorn\n    # uvicorn.run(mcp.app, host=\"0.0.0.0\", port=8000)\n    pass # FastMCP's standard execution handles the server run.\n"
    },
    {
      "name": "models.py",
      "content": "from typing import Optional, Literal, Dict, Any\nfrom pydantic import BaseModel, Field, validator\n\n# Define common types\nVarietyType = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nExchangeType = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange\")\n    transaction_type: TransactionType = Field(..., description=\"Transaction type\")\n    order_type: OrderType = Field(..., description=\"Order type\")\n    quantity: int = Field(..., description=\"Quantity to transact\", gt=0)\n    product: ProductType = Field(..., description=\"Product type\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders\", ge=0)\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders\", ge=0)\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades)\", ge=0)\n    validity: ValidityType = Field(..., description=\"Order validity\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders\", ge=1)\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10)\", ge=2, le=10)\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order\", ge=1)\n    auction_number: Optional[str] = Field(None, description=\"Unique identifier for a particular auction\")\n    tag: Optional[str] = Field(None, description=\"Optional tag for the order (max 20 chars)\", max_length=20)\n\n    @validator('price', always=True)\n    def check_price_for_limit(cls, v, values):\n        if values.get('order_type') == 'LIMIT' and v is None:\n            raise ValueError('Price is required for LIMIT orders')\n        if values.get('order_type') != 'LIMIT' and v is not None:\n            # Kite API might ignore it, but better to be explicit\n            # raise ValueError('Price is only applicable for LIMIT orders')\n            pass # Allow sending price even if not LIMIT, API might handle it\n        return v\n\n    @validator('trigger_price', always=True)\n    def check_trigger_price(cls, v, values):\n        if values.get('order_type') in ['SL', 'SL-M'] and v is None:\n            raise ValueError('Trigger price is required for SL and SL-M orders')\n        if values.get('order_type') not in ['SL', 'SL-M'] and v is not None:\n            # raise ValueError('Trigger price is only applicable for SL and SL-M orders')\n            pass # Allow sending trigger_price, API might handle it (e.g., for CO)\n        return v\n\n    @validator('validity_ttl', always=True)\n    def check_validity_ttl(cls, v, values):\n        if values.get('validity') == 'TTL' and v is None:\n            raise ValueError('validity_ttl is required for TTL validity')\n        if values.get('validity') != 'TTL' and v is not None:\n            raise ValueError('validity_ttl is only applicable for TTL validity')\n        return v\n\n    @validator('iceberg_legs', 'iceberg_quantity', always=True)\n    def check_iceberg_params(cls, v, values, field):\n        if values.get('variety') == 'iceberg':\n            if field.name == 'iceberg_legs' and v is None:\n                raise ValueError('iceberg_legs is required for iceberg orders')\n            if field.name == 'iceberg_quantity' and v is None:\n                raise ValueError('iceberg_quantity is required for iceberg orders')\n        elif v is not None:\n            raise ValueError(f'{field.name} is only applicable for iceberg orders')\n        return v\n\n    @validator('auction_number', always=True)\n    def check_auction_number(cls, v, values):\n        if values.get('variety') == 'auction' and v is None:\n            raise ValueError('auction_number is required for auction orders')\n        if values.get('variety') != 'auction' and v is not None:\n            raise ValueError('auction_number is only applicable for auction orders')\n        return v\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Parameters for modifying an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety\")\n    order_id: str = Field(..., description=\"The ID of the order to modify\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for second leg CO modification\")\n    # Fields below are optional and depend on variety/context\n    order_type: Optional[OrderType] = Field(None, description=\"New order type (regular variety)\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (regular variety)\", gt=0)\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT/CO orders)\", ge=0)\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL/SL-M/CO orders)\", ge=0)\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (regular variety)\", ge=0)\n    validity: Optional[ValidityType] = Field(None, description=\"New validity (regular variety)\")\n\n    @validator('parent_order_id', always=True)\n    def check_parent_order_id(cls, v, values):\n        # Basic check, actual requirement might depend on API state/context\n        if values.get('variety') == 'co' and v is None:\n            # This might only be needed for modifying the *second leg* of a CO\n            # Adding a warning or allowing it might be better than strict validation here\n            pass\n        return v\n\nclass CancelOrderParams(BaseModel):\n    \"\"\"Parameters for cancelling an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for second leg CO cancellation\")\n\n    @validator('parent_order_id', always=True)\n    def check_parent_order_id(cls, v, values):\n        # Basic check, actual requirement might depend on API state/context\n        if values.get('variety') == 'co' and v is None:\n            # This might only be needed for cancelling the *second leg* of a CO\n            pass\n        return v\n\nclass KiteResponse(BaseModel):\n    \"\"\"Standard response structure from Kite Connect API calls.\"\"\"\n    status: str\n    data: Optional[Dict[str, Any]] = None\n    message: Optional[str] = None\n    error_type: Optional[str] = None\n"
    },
    {
      "name": "client.py",
      "content": "import logging\nfrom typing import Dict, Any, Optional\n\nimport httpx\nfrom pydantic import ValidationError as PydanticValidationError\n\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams\n\nlogger = logging.getLogger(__name__)\n\n# Custom Exceptions\nclass KiteConnectError(Exception):\n    \"\"\"Base exception for Kite Connect client errors.\"\"\"\n    def __init__(self, message: str, status_code: Optional[int] = None):\n        self.message = message\n        self.status_code = status_code\n        super().__init__(message)\n\n    def __str__(self):\n        if self.status_code:\n            return f\"[HTTP {self.status_code}] {self.message}\"\n        return self.message\n\nclass AuthenticationError(KiteConnectError):\n    \"\"\"Authentication failed (401/403).\"\"\"\n    pass\n\nclass ValidationError(KiteConnectError):\n    \"\"\"Input validation failed (400).\"\"\"\n    pass\n\nclass OrderNotFoundError(KiteConnectError):\n    \"\"\"Order not found (often 404, but depends on API).\"\"\"\n    pass\n\nclass InvalidOrderStateError(KiteConnectError):\n    \"\"\"Order cannot be modified/cancelled in its current state.\"\"\"\n    pass\n\nclass InsufficientFundsError(KiteConnectError):\n    \"\"\"Insufficient funds for the order.\"\"\"\n    pass\n\nclass NetworkError(KiteConnectError):\n    \"\"\"Network communication error.\"\"\"\n    pass\n\nclass RateLimitError(KiteConnectError):\n    \"\"\"Rate limit exceeded (429).\"\"\"\n    pass\n\nclass ExchangeError(KiteConnectError):\n    \"\"\"Error reported by the exchange.\"\"\"\n    pass\n\nclass GeneralError(KiteConnectError):\n    \"\"\"General API error (5xx or unexpected).\"\"\"\n    pass\n\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect Orders API (v3).\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        \"\"\"\n        Initializes the Kite Connect client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after login.\n            base_url: The base URL for the Kite Connect API (default: https://api.kite.trade).\n            timeout: Request timeout in seconds.\n        \"\"\"\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form encoding\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=timeout\n        )\n        # Note: Kite API has rate limits (e.g., 10 req/sec). Implement throttling/backoff if needed.\n        logger.info(f\"KiteConnectClient initialized for base URL: {self.base_url}\")\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite Connect API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Sending {method} request to {url}\")\n        logger.debug(f\"Params: {params}\")\n        logger.debug(f\"Data: {data}\")\n\n        try:\n            response = await self.client.request(method, endpoint, data=data, params=params)\n            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx\n            return response.json()\n        except httpx.HTTPStatusError as e:\n            status_code = e.response.status_code\n            try:\n                error_data = e.response.json()\n                message = error_data.get(\"message\", \"Unknown API error\")\n                error_type = error_data.get(\"error_type\", \"UnknownError\")\n                logger.error(f\"Kite API Error ({status_code} - {error_type}): {message}\")\n\n                if status_code == 400:\n                    # Could be validation, insufficient funds, bad state etc.\n                    if \"funds\" in message.lower():\n                        raise InsufficientFundsError(message, status_code) from e\n                    if \"validation\" in message.lower() or error_type == \"InputException\":\n                         raise ValidationError(message, status_code) from e\n                    # Add more specific checks based on Kite error messages if needed\n                    raise ValidationError(f\"{error_type}: {message}\", status_code) from e # Default to validation for 400\n                elif status_code in [401, 403]:\n                    raise AuthenticationError(message, status_code) from e\n                elif status_code == 404:\n                    # 404 might mean order not found or invalid endpoint\n                    raise OrderNotFoundError(message, status_code) from e\n                elif status_code == 429:\n                    raise RateLimitError(message, status_code) from e\n                elif status_code == 500:\n                     raise GeneralError(f\"Internal Server Error: {message}\", status_code) from e\n                elif status_code == 502:\n                     raise ExchangeError(f\"Exchange Error/Gateway Timeout: {message}\", status_code) from e\n                elif status_code == 503:\n                     raise ExchangeError(f\"Service Unavailable (Maintenance?): {message}\", status_code) from e\n                else:\n                    raise GeneralError(f\"Unhandled API Error ({error_type}): {message}\", status_code) from e\n            except (ValueError, KeyError):\n                # If response is not JSON or lacks expected keys\n                message = e.response.text or f\"HTTP error {status_code}\"\n                logger.error(f\"Kite API Error ({status_code}): {message}\")\n                if status_code in [401, 403]: raise AuthenticationError(message, status_code) from e\n                if status_code == 429: raise RateLimitError(message, status_code) from e\n                raise GeneralError(message, status_code) from e\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out: {e}\")\n            raise NetworkError(f\"Request timed out after {self.client.timeout} seconds\", None) from e\n        except httpx.RequestError as e:\n            # Covers network connection errors, DNS errors, etc.\n            logger.error(f\"Network error during request: {e}\")\n            raise NetworkError(f\"Network error: {str(e)} contacting {e.request.url}\", None) from e\n        except PydanticValidationError as e:\n             logger.error(f\"Request/Response validation error: {e}\")\n             raise ValidationError(f\"Data validation error: {e}\", None) from e\n        except Exception as e:\n            logger.exception(\"An unexpected error occurred during API request\")\n            raise GeneralError(f\"An unexpected error occurred: {str(e)}\", None) from e\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, Any]:\n        \"\"\"Places an order.\"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Convert model to dict, excluding None values and the 'variety' field itself\n        data = params.dict(exclude={'variety'}, exclude_none=True)\n        logger.info(f\"Placing order: endpoint={endpoint}, data={data}\")\n        return await self._request(\"POST\", endpoint, data=data)\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, Any]:\n        \"\"\"Modifies an existing order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Convert model to dict, excluding None values and path params ('variety', 'order_id')\n        data = params.dict(exclude={'variety', 'order_id'}, exclude_none=True)\n        logger.info(f\"Modifying order: endpoint={endpoint}, data={data}\")\n        return await self._request(\"PUT\", endpoint, data=data)\n\n    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, Any]:\n        \"\"\"Cancels an existing order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # parent_order_id goes into query params if present\n        query_params = {}\n        if params.parent_order_id:\n            query_params['parent_order_id'] = params.parent_order_id\n\n        logger.info(f\"Cancelling order: endpoint={endpoint}, params={query_params}\")\n        return await self._request(\"DELETE\", endpoint, params=query_params)\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.2.0,<0.3.0\nhttpx>=0.25.0,<0.28.0\npydantic>=1.10.0,<2.0.0\npython-dotenv>=1.0.0,<2.0.0\nuvicorn>=0.23.0,<0.25.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Copy this file to .env and fill in your actual credentials.\n\n# Your Kite Connect application's API key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# The access token obtained after a successful Kite Connect login flow\n# This token is typically short-lived (valid for one day)\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# Optional: Base URL for the Kite Connect API\n# KITE_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect Orders API (v3). It allows language models or other clients to place, modify, and cancel trading orders through a standardized MCP interface.\n\n## Features\n\n*   Exposes Kite Connect order management functions as MCP tools.\n*   Uses `FastMCP` for the server implementation.\n*   Asynchronous API client built with `httpx`.\n*   Input validation using `Pydantic` models.\n*   Handles common Kite Connect API errors.\n*   Configurable via environment variables.\n\n## Prerequisites\n\n*   Python 3.8+\n*   Zerodha Kite Connect API Key and Secret.\n*   A valid `access_token` obtained through the Kite Connect login flow (this token is typically valid for one trading day).\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create and activate a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure environment variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect `API_KEY` and a valid `ACCESS_TOKEN`.\n        ```dotenv\n        KITE_API_KEY=\"YOUR_API_KEY\"\n        KITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n        # KITE_BASE_URL=\"https://api.kite.trade\" # Optional: uncomment to override default\n        ```\n    *   **Important:** The `ACCESS_TOKEN` needs to be generated daily through the Kite Connect login flow.\n\n## Running the Server\n\nUse `uvicorn` to run the MCP server:\n\n```bash\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--reload`: Enables auto-reloading during development.\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n\nThe MCP server will be available at `http://localhost:8000` (or the specified host/port).\n\n## Available MCP Tools\n\nThe following tools are exposed by this MCP server:\n\n1.  **`place_order`**\n    *   **Description:** Place an order of a particular variety (regular, amo, co, iceberg, auction).\n    *   **Input Model:** `PlaceOrderParams` (see `models.py` for details)\n        *   `variety`: 'regular', 'amo', 'co', 'iceberg', 'auction'\n        *   `tradingsymbol`: e.g., \"INFY\", \"NIFTY23AUGFUT\"\n        *   `exchange`: 'NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'\n        *   `transaction_type`: 'BUY', 'SELL'\n        *   `order_type`: 'MARKET', 'LIMIT', 'SL', 'SL-M'\n        *   `quantity`: Integer > 0\n        *   `product`: 'CNC', 'NRML', 'MIS', 'MTF'\n        *   `price`: Float (Required for LIMIT orders)\n        *   `trigger_price`: Float (Required for SL, SL-M orders)\n        *   `validity`: 'DAY', 'IOC', 'TTL'\n        *   `disclosed_quantity`: Optional[int]\n        *   `validity_ttl`: Optional[int] (Required for TTL validity)\n        *   `iceberg_legs`: Optional[int] (Required for iceberg variety)\n        *   `iceberg_quantity`: Optional[int] (Required for iceberg variety)\n        *   `auction_number`: Optional[str] (Required for auction variety)\n        *   `tag`: Optional[str] (max 20 chars)\n    *   **Returns:** `Dict[str, Any]` containing the API response, typically `{'status': 'success', 'data': {'order_id': '...'}}` or `{'error': '...'}`.\n\n2.  **`modify_order`**\n    *   **Description:** Modify an open or pending order.\n    *   **Input Model:** `ModifyOrderParams` (see `models.py` for details)\n        *   `variety`: 'regular', 'amo', 'co', 'iceberg', 'auction'\n        *   `order_id`: The ID of the order to modify.\n        *   `parent_order_id`: Optional[str] (Required for second leg CO modification)\n        *   `order_type`: Optional[OrderType]\n        *   `quantity`: Optional[int]\n        *   `price`: Optional[float]\n        *   `trigger_price`: Optional[float]\n        *   `disclosed_quantity`: Optional[int]\n        *   `validity`: Optional[ValidityType]\n    *   **Returns:** `Dict[str, Any]` containing the API response, typically `{'status': 'success', 'data': {'order_id': '...'}}` or `{'error': '...'}`.\n\n3.  **`cancel_order`**\n    *   **Description:** Cancel an open or pending order.\n    *   **Input Model:** `CancelOrderParams` (see `models.py` for details)\n        *   `variety`: 'regular', 'amo', 'co', 'iceberg', 'auction'\n        *   `order_id`: The ID of the order to cancel.\n        *   `parent_order_id`: Optional[str] (Required for second leg CO cancellation)\n    *   **Returns:** `Dict[str, Any]` containing the API response, typically `{'status': 'success', 'data': {'order_id': '...'}}` or `{'error': '...'}`.\n\n## Error Handling\n\nThe client attempts to map common HTTP status codes and Kite API error messages to specific exceptions (`AuthenticationError`, `ValidationError`, `RateLimitError`, `InsufficientFundsError`, `OrderNotFoundError`, `NetworkError`, `ExchangeError`, `GeneralError`). These are caught by the MCP tools, logged, and returned as an error dictionary: `{\"error\": \"Error message\"}`.\n\n## Rate Limits\n\nThe Kite Connect API enforces rate limits (e.g., 10 requests per second for order placement/modification). This client implementation does *not* automatically handle rate limiting (e.g., with retries or throttling). If you expect high request volumes, you may need to add rate-limiting logic to the client or the calling application.\n"
    }
  ]
}
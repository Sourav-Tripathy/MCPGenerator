{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom models import (PlaceOrderParams, ModifyOrderParams, CancelOrderParams, \n                    KiteApiError, OrderIDResponse)\nfrom client import KiteConnectClient, KiteClientError\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectTrading\",\n    description=\"MCP service providing tools to interact with the Kite Connect V3 trading API, focusing on order management. Allows placing, modifying, cancelling orders.\"\n)\n\n# Initialize API Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n    # Consider raising an exception or exiting if credentials are required at startup\n    # raise ValueError(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set\")\n    # For now, we allow it to proceed but client calls will likely fail\n\nkite_client = KiteConnectClient(api_key=api_key, access_token=access_token, base_url=base_url)\n\n@mcp.tool(returns=OrderIDResponse)\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Places an order of a specified variety (regular, amo, co, iceberg, auction) \n    with the given parameters.\n    \"\"\"\n    logger.info(f\"Received place_order request: {params}\")\n    try:\n        result = await kite_client.place_order(params)\n        logger.info(f\"Order placed successfully: {result}\")\n        return result\n    except KiteClientError as e:\n        logger.error(f\"Error placing order: {e}\", exc_info=True)\n        # Return a structured error compatible with potential client expectations\n        return KiteApiError(error_type=e.error_type, message=str(e)).dict()\n    except Exception as e:\n        logger.error(f\"Unexpected error placing order: {e}\", exc_info=True)\n        return KiteApiError(error_type=\"GeneralException\", message=f\"An unexpected error occurred: {str(e)}\").dict()\n\n@mcp.tool(returns=OrderIDResponse)\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modifies specific attributes of an open or pending order.\n    \"\"\"\n    logger.info(f\"Received modify_order request: {params}\")\n    try:\n        result = await kite_client.modify_order(params)\n        logger.info(f\"Order modified successfully: {result}\")\n        return result\n    except KiteClientError as e:\n        logger.error(f\"Error modifying order: {e}\", exc_info=True)\n        return KiteApiError(error_type=e.error_type, message=str(e)).dict()\n    except Exception as e:\n        logger.error(f\"Unexpected error modifying order: {e}\", exc_info=True)\n        return KiteApiError(error_type=\"GeneralException\", message=f\"An unexpected error occurred: {str(e)}\").dict()\n\n@mcp.tool(returns=OrderIDResponse)\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"Cancels an open or pending order.\n    \"\"\"\n    logger.info(f\"Received cancel_order request: {params}\")\n    try:\n        result = await kite_client.cancel_order(params)\n        logger.info(f\"Order cancelled successfully: {result}\")\n        return result\n    except KiteClientError as e:\n        logger.error(f\"Error cancelling order: {e}\", exc_info=True)\n        return KiteApiError(error_type=e.error_type, message=str(e)).dict()\n    except Exception as e:\n        logger.error(f\"Unexpected error cancelling order: {e}\", exc_info=True)\n        return KiteApiError(error_type=\"GeneralException\", message=f\"An unexpected error occurred: {str(e)}\").dict()\n\nif __name__ == \"__main__\":\n    import uvicorn\n    # Run the MCP server using uvicorn\n    # Example: uvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n    # The FastMCP object itself provides an app attribute compatible with ASGI servers\n    logger.info(\"Starting KiteConnectTrading MCP server...\")\n    # Note: Running directly like this is mainly for development.\n    # Use a proper ASGI server like uvicorn or hypercorn in production.\n    # mcp.run() # This is a simplified run method, using uvicorn directly is more standard\n    uvicorn.run(mcp.app, host=\"0.0.0.0\", port=8000)\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field, validator\nfrom typing import Optional, Dict\nfrom enum import Enum\n\n# --- Enums based on Kite Connect API documentation --- \n\nclass VarietyEnum(str, Enum):\n    REGULAR = \"regular\"\n    AMO = \"amo\"\n    CO = \"co\"\n    ICEBERG = \"iceberg\"\n    AUCTION = \"auction\"\n\nclass ExchangeEnum(str, Enum):\n    NSE = \"NSE\"\n    BSE = \"BSE\"\n    NFO = \"NFO\"\n    MCX = \"MCX\"\n    CDS = \"CDS\"\n    BFO = \"BFO\"\n    BCD = \"BCD\"\n\nclass TransactionTypeEnum(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n\nclass OrderTypeEnum(str, Enum):\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n    SL = \"SL\"\n    SLM = \"SL-M\"\n\nclass ProductEnum(str, Enum):\n    CNC = \"CNC\"\n    NRML = \"NRML\"\n    MIS = \"MIS\"\n    MTF = \"MTF\"\n\nclass ValidityEnum(str, Enum):\n    DAY = \"DAY\"\n    IOC = \"IOC\"\n    TTL = \"TTL\"\n\n# --- Input Models for Tools --- \n\nclass PlaceOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety (regular, amo, co, iceberg, auction)\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., INFY, NIFTY23JUL)\")\n    exchange: ExchangeEnum = Field(..., description=\"Name of the exchange (e.g., NSE, BSE, NFO)\")\n    transaction_type: TransactionTypeEnum = Field(..., description=\"BUY or SELL\")\n    order_type: OrderTypeEnum = Field(..., description=\"Order type (MARKET, LIMIT, SL, SL-M)\")\n    quantity: int = Field(..., description=\"Quantity to transact\", gt=0)\n    product: ProductEnum = Field(..., description=\"Product type (CNC, NRML, MIS, MTF)\")\n    validity: ValidityEnum = Field(..., description=\"Order validity (DAY, IOC, TTL)\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders\", ge=0)\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders\", ge=0)\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity)\", ge=0)\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders (1 to 1440)\", ge=1, le=1440)\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order (2-10)\", ge=2, le=10)\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg (must be >= 1)\", ge=1)\n    auction_number: Optional[str] = Field(None, description=\"Unique identifier for a specific auction\")\n    tag: Optional[str] = Field(None, description=\"Optional tag for the order (alphanumeric, max 20 chars)\", max_length=20)\n\n    @validator('price')\n    def price_required_for_limit(cls, v, values):\n        if values.get('order_type') == OrderTypeEnum.LIMIT and v is None:\n            raise ValueError('Price is required for LIMIT orders')\n        if values.get('order_type') != OrderTypeEnum.LIMIT and v is not None:\n            # Kite might ignore it, but better to be explicit\n            # raise ValueError('Price should only be provided for LIMIT orders')\n            pass # Allow price for other types if API ignores it\n        return v\n\n    @validator('trigger_price')\n    def trigger_price_required_for_sl(cls, v, values):\n        if values.get('order_type') in [OrderTypeEnum.SL, OrderTypeEnum.SLM] and v is None:\n            raise ValueError('Trigger price is required for SL and SL-M orders')\n        if values.get('order_type') not in [OrderTypeEnum.SL, OrderTypeEnum.SLM] and v is not None:\n            # raise ValueError('Trigger price should only be provided for SL and SL-M orders')\n            pass # Allow trigger_price for other types if API ignores it\n        return v\n\n    @validator('validity_ttl')\n    def validity_ttl_required_for_ttl(cls, v, values):\n        if values.get('validity') == ValidityEnum.TTL and v is None:\n            raise ValueError('validity_ttl is required for TTL validity')\n        if values.get('validity') != ValidityEnum.TTL and v is not None:\n            raise ValueError('validity_ttl should only be provided for TTL validity')\n        return v\n\n    @validator('iceberg_legs', 'iceberg_quantity')\n    def iceberg_params_for_iceberg_variety(cls, v, field, values):\n        if values.get('variety') == VarietyEnum.ICEBERG and v is None:\n            raise ValueError(f'{field.name} is required for iceberg variety')\n        if values.get('variety') != VarietyEnum.ICEBERG and v is not None:\n            raise ValueError(f'{field.name} should only be provided for iceberg variety')\n        return v\n\n    @validator('auction_number')\n    def auction_number_for_auction_variety(cls, v, values):\n        if values.get('variety') == VarietyEnum.AUCTION and v is None:\n            raise ValueError('auction_number is required for auction variety')\n        if values.get('variety') != VarietyEnum.AUCTION and v is not None:\n            raise ValueError('auction_number should only be provided for auction variety')\n        return v\n\nclass ModifyOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety (regular, co)\") # Note: AMO, Iceberg, Auction cannot be modified via API\n    order_id: str = Field(..., description=\"The ID of the order to modify\")\n    parent_order_id: Optional[str] = Field(None, description=\"Parent order ID if modifying a second-leg CO order\")\n    order_type: Optional[OrderTypeEnum] = Field(None, description=\"New order type (Regular orders only)\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (Regular orders only)\", gt=0)\n    price: Optional[float] = Field(None, description=\"New price (LIMIT orders)\", ge=0)\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (SL, SL-M, CO orders)\", ge=0)\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (Regular orders only)\", ge=0)\n    validity: Optional[ValidityEnum] = Field(None, description=\"New validity (Regular orders only, cannot change to/from IOC)\")\n\n    @validator('variety')\n    def check_modifiable_variety(cls, v):\n        # As per Kite docs, only regular and CO orders can be modified via API\n        if v not in [VarietyEnum.REGULAR, VarietyEnum.CO]:\n            raise ValueError(f\"Modification is not supported for variety '{v.value}'. Only 'regular' and 'co' are allowed.\")\n        return v\n\n    @validator('validity')\n    def check_validity_modification(cls, v, values):\n        # Assuming original validity is not available here, but API prevents IOC changes\n        if v == ValidityEnum.IOC:\n            raise ValueError(\"Cannot change validity to IOC.\")\n        # Also cannot change from IOC, but we can't check that here\n        return v\n\n    @validator('parent_order_id')\n    def parent_order_id_for_co(cls, v, values):\n        # Parent order ID is typically needed when modifying the second leg (SL/TP) of a CO order\n        # The API might require it conditionally, but validation here is complex without knowing which leg is being modified.\n        # We allow it optionally.\n        return v\n\nclass CancelOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety (regular, co, amo, iceberg, auction)\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel\")\n    parent_order_id: Optional[str] = Field(None, description=\"Parent order ID if cancelling a second-leg CO order\")\n\n# --- Response / Error Models --- \n\nclass OrderIDResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID assigned by the exchange/broker.\")\n\nclass KiteApiError(BaseModel):\n    error_type: str = Field(..., description=\"The type of error encountered.\")\n    message: str = Field(..., description=\"A descriptive error message.\")\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nfrom typing import Dict, Any, Optional\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams\n\nlogger = logging.getLogger(__name__)\n\nclass KiteClientError(Exception):\n    \"\"\"Custom exception for Kite Connect client errors.\"\"\"\n    def __init__(self, message: str, status_code: Optional[int] = None, error_type: str = \"ClientError\"):\n        super().__init__(message)\n        self.status_code = status_code\n        self.error_type = error_type\n\n    def __str__(self):\n        if self.status_code:\n            return f\"[{self.error_type} / {self.status_code}] {super().__str__()}\"\n        else:\n            return f\"[{self.error_type}] {super().__str__()}\"\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect V3 API.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\"):\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite API uses form encoding\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=30.0 # Set a reasonable timeout\n        )\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Sending request: {method} {url} Data: {data}\")\n        try:\n            response = await self.client.request(method, endpoint, data=data)\n            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx responses\n            \n            json_response = response.json()\n            logger.debug(f\"Received response: {response.status_code} Body: {json_response}\")\n\n            # Kite API specific success/error check within the response body\n            if json_response.get(\"status\") == \"error\":\n                error_type = json_response.get(\"error_type\", \"UnknownApiError\")\n                message = json_response.get(\"message\", \"Unknown API error occurred.\")\n                logger.error(f\"Kite API returned error: {error_type} - {message}\")\n                raise KiteClientError(message, status_code=response.status_code, error_type=error_type)\n            \n            return json_response.get(\"data\", {}) # Successful responses are nested under 'data'\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out: {method} {url}\", exc_info=True)\n            raise KiteClientError(f\"Request timed out: {str(e)}\", error_type=\"TimeoutError\") from e\n        except httpx.RequestError as e:\n            logger.error(f\"Request error: {method} {url} - {e}\", exc_info=True)\n            # E.g., DNS errors, connection refused\n            raise KiteClientError(f\"Network request error: {str(e)}\", error_type=\"NetworkError\") from e\n        except httpx.HTTPStatusError as e:\n            logger.error(f\"HTTP error: {e.response.status_code} for {method} {url}\", exc_info=True)\n            try:\n                # Try to parse error details from Kite's response body\n                error_data = e.response.json()\n                error_type = error_data.get(\"error_type\", f\"HTTP{e.response.status_code}\")\n                message = error_data.get(\"message\", f\"HTTP error {e.response.status_code}\")\n            except Exception:\n                # Fallback if response is not JSON or doesn't match expected format\n                error_type = f\"HTTP{e.response.status_code}\"\n                message = f\"HTTP error {e.response.status_code}: {e.response.text[:200]}\" # Limit error text length\n            \n            # Map common HTTP status codes to error types\n            if e.response.status_code == 400:\n                error_type = \"InputException\" # Or use Kite's specific type if available\n            elif e.response.status_code == 403:\n                # Could be TokenException, UserException, PermissionException, TwoFAException, etc.\n                error_type = error_data.get(\"error_type\", \"ForbiddenError\") \n            elif e.response.status_code == 404:\n                error_type = \"DataException\" # Or specific like OrderNotFound\n            elif e.response.status_code == 429:\n                error_type = \"NetworkException\" # Kite uses this for RateLimitError\n            elif e.response.status_code == 500:\n                error_type = \"GeneralException\" # Kite's general server error\n            elif e.response.status_code == 502 or e.response.status_code == 503 or e.response.status_code == 504:\n                 error_type = \"NetworkException\" # Kite's network/gateway errors\n\n            raise KiteClientError(message, status_code=e.response.status_code, error_type=error_type) from e\n        except Exception as e:\n            logger.error(f\"Unexpected error during request: {method} {url}\", exc_info=True)\n            raise KiteClientError(f\"An unexpected error occurred: {str(e)}\", error_type=\"GeneralException\") from e\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, str]:\n        \"\"\"Places an order using the Kite API.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}\"\n        # Convert model to dict, excluding None values and the 'variety' field itself\n        # Use model_dump for Pydantic v2+, dict() for v1\n        try: \n            payload = params.model_dump(exclude={'variety'}, exclude_none=True)\n        except AttributeError: # Fallback for Pydantic v1\n            payload = params.dict(exclude={'variety'}, exclude_none=True)\n\n        # Convert enum values to strings for the API\n        for key, value in payload.items():\n            if isinstance(value, Enum):\n                payload[key] = value.value\n\n        logger.info(f\"Placing order: {endpoint} with payload: {payload}\")\n        response_data = await self._request(\"POST\", endpoint, data=payload)\n        \n        if \"order_id\" not in response_data:\n             logger.error(f\"'order_id' not found in successful place order response: {response_data}\")\n             raise KiteClientError(\"Order placement succeeded but 'order_id' was missing in the response.\", error_type=\"ApiResponseError\")\n        \n        return {\"order_id\": response_data[\"order_id\"]}\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, str]:\n        \"\"\"Modifies an existing order using the Kite API.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}/{params.order_id}\"\n        try:\n            payload = params.model_dump(exclude={'variety', 'order_id'}, exclude_none=True)\n        except AttributeError: # Fallback for Pydantic v1\n            payload = params.dict(exclude={'variety', 'order_id'}, exclude_none=True)\n\n        # Convert enum values to strings\n        for key, value in payload.items():\n            if isinstance(value, Enum):\n                payload[key] = value.value\n\n        logger.info(f\"Modifying order: {endpoint} with payload: {payload}\")\n        response_data = await self._request(\"PUT\", endpoint, data=payload)\n\n        if \"order_id\" not in response_data:\n             logger.error(f\"'order_id' not found in successful modify order response: {response_data}\")\n             raise KiteClientError(\"Order modification succeeded but 'order_id' was missing in the response.\", error_type=\"ApiResponseError\")\n\n        return {\"order_id\": response_data[\"order_id\"]}\n\n    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, str]:\n        \"\"\"Cancels an existing order using the Kite API.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}/{params.order_id}\"\n        try:\n            payload = params.model_dump(exclude={'variety', 'order_id'}, exclude_none=True)\n        except AttributeError: # Fallback for Pydantic v1\n             payload = params.dict(exclude={'variety', 'order_id'}, exclude_none=True)\n\n        logger.info(f\"Cancelling order: {endpoint} with payload: {payload}\")\n        response_data = await self._request(\"DELETE\", endpoint, data=payload)\n\n        if \"order_id\" not in response_data:\n             logger.error(f\"'order_id' not found in successful cancel order response: {response_data}\")\n             raise KiteClientError(\"Order cancellation succeeded but 'order_id' was missing in the response.\", error_type=\"ApiResponseError\")\n\n        return {\"order_id\": response_data[\"order_id\"]}\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.2.0\npydantic>=2.0.0,<3.0.0\nhttpx>=0.25.0,<0.28.0\npython-dotenv>=1.0.0,<2.0.0\nuvicorn>=0.23.0,<0.28.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Environment variables for KiteConnectTrading MCP Server\n\n# Your Kite Connect API Key\nKITE_API_KEY=\n\n# Your Kite Connect API Secret (primarily used for the login flow to get access_token)\n# KITE_API_SECRET=\n\n# The access token obtained after a successful Kite Connect login flow\n# This token is typically valid for one day\nKITE_ACCESS_TOKEN=\n\n# Base URL for the Kite Connect API (optional, defaults to https://api.kite.trade)\n# KITE_BASE_URL=https://api.kite.trade\n"
    },
    {
      "name": "README.md",
      "content": "# KiteConnectTrading MCP Server\n\nThis repository contains a Model Context Protocol (MCP) server implementation for interacting with the Zerodha Kite Connect V3 trading API. It provides tools focused on order management: placing, modifying, and cancelling orders.\n\nThis server is built using [FastMCP](https://github.com/cognosis-ai/fastmcp).\n\n## Features\n\n*   **Place Orders:** Submit new orders of various types (regular, AMO, CO, iceberg, auction).\n*   **Modify Orders:** Change parameters of existing pending orders (regular, CO).\n*   **Cancel Orders:** Cancel existing pending orders.\n*   **Typed Inputs:** Uses Pydantic models for robust input validation.\n*   **Asynchronous:** Built with `asyncio` and `httpx` for non-blocking API calls.\n*   **Error Handling:** Captures and reports common Kite API errors.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect API credentials:\n        *   `KITE_API_KEY`: Your Kite application's API key.\n        *   `KITE_ACCESS_TOKEN`: A valid access token. \n            *   **Important:** You need to obtain this token separately using the Kite Connect login flow (e.g., using the official `kiteconnect-python` library or your own implementation). Access tokens are typically short-lived (valid for a day).\n        *   `KITE_BASE_URL` (Optional): Defaults to `https://api.kite.trade`.\n\n## Running the Server\n\nUse an ASGI server like Uvicorn to run the application:\n\n```bash\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n*   `--reload`: Automatically restarts the server when code changes (for development).\n\nThe MCP server will be available at `http://localhost:8000`.\n\n## Environment Variables\n\n*   `KITE_API_KEY` (Required): Your Kite Connect API Key.\n*   `KITE_ACCESS_TOKEN` (Required): The access token obtained via the Kite Connect login flow.\n*   `KITE_BASE_URL` (Optional): The base URL for the Kite API. Defaults to `https://api.kite.trade`.\n\n## API Tools\n\nThe following tools are exposed by this MCP server:\n\n1.  **`place_order`**\n    *   **Description:** Places an order of a specified variety (regular, amo, co, iceberg, auction) with the given parameters.\n    *   **Input Model:** `PlaceOrderParams` (see `models.py` for fields like `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, `validity`, `price`, `trigger_price`, etc.)\n    *   **Returns:** `OrderIDResponse` (e.g., `{\"order_id\": \"230725000000001\"}`) or `KiteApiError` on failure.\n\n2.  **`modify_order`**\n    *   **Description:** Modifies specific attributes of an open or pending order (only 'regular' and 'co' varieties supported by Kite API for modification).\n    *   **Input Model:** `ModifyOrderParams` (see `models.py` for fields like `variety`, `order_id`, `quantity`, `price`, `trigger_price`, etc.)\n    *   **Returns:** `OrderIDResponse` (e.g., `{\"order_id\": \"230725000000001\"}`) or `KiteApiError` on failure.\n\n3.  **`cancel_order`**\n    *   **Description:** Cancels an open or pending order.\n    *   **Input Model:** `CancelOrderParams` (see `models.py` for fields like `variety`, `order_id`, `parent_order_id`)\n    *   **Returns:** `OrderIDResponse` (e.g., `{\"order_id\": \"230725000000001\"}`) or `KiteApiError` on failure.\n\n## Error Handling\n\nThe tools will return a `KiteApiError` dictionary if the Kite API client encounters an error (e.g., invalid input, authentication failure, network issues, insufficient funds, rate limits). The error dictionary includes an `error_type` (like `InputException`, `TokenException`, `NetworkException`, `OrderException`) and a descriptive `message`.\n"
    }
  ]
}
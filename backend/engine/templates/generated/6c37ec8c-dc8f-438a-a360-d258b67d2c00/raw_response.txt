{
  "files": [
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field\nfrom typing import Optional, List, Dict, Literal, Any\n\n# --- Input Models ---\n\nclass PlaceOrderParams(BaseModel):\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"The variety of the order.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'] = Field(..., description=\"Name of the exchange.\")\n    transaction_type: Literal['BUY', 'SELL'] = Field(..., description=\"Transaction type.\")\n    order_type: Literal['MARKET', 'LIMIT', 'SL', 'SL-M'] = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., description=\"Quantity to transact.\")\n    product: Literal['CNC', 'NRML', 'MIS', 'MTF'] = Field(..., description=\"Product code.\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders.\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity: Literal['DAY', 'IOC', 'TTL'] = Field(..., description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10). Required if variety is 'iceberg'.\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs). Required if variety is 'iceberg'.\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction. Required if variety is 'auction'.\")\n    tag: Optional[str] = Field(None, description=\"An optional tag for the order (alphanumeric, max 20 chars).\")\n\nclass ModifyOrderParams(BaseModel):\n    variety: Literal['regular', 'co'] = Field(..., description=\"The variety of the order to modify. Note: Docs only explicitly mention params for 'regular' and 'co'. Other varieties might not be modifiable or require different params.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    order_type: Optional[Literal['MARKET', 'LIMIT', 'SL', 'SL-M']] = Field(None, description=\"New order type (for regular variety).\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (for regular variety).\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders, applicable to regular and CO).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, LIMIT CO orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (for regular variety).\")\n    validity: Optional[Literal['DAY', 'IOC', 'TTL']] = Field(None, description=\"New validity (for regular variety).\")\n\nclass CancelOrderParams(BaseModel):\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"The variety of the order to cancel.\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Conditional: The order ID of the parent order (required for cancelling second-leg CO orders).\")\n\nclass GetOrdersParams(BaseModel):\n    # No parameters needed for retrieving all orders\n    pass\n\nclass GetOrderHistoryParams(BaseModel):\n    order_id: str = Field(..., description=\"The ID of the order to retrieve history for.\")\n\n# --- Return Type Placeholders ---\n# Define basic structures for return types based on descriptions.\n# The actual Kite API response structure might be more complex.\n\nclass OrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The ID of the order affected.\")\n\n# Placeholder for a single order structure returned by get_orders\nclass Order(BaseModel):\n    # Add fields based on actual Kite API response for an order\n    # Example fields:\n    order_id: Optional[str] = None\n    status: Optional[str] = None\n    tradingsymbol: Optional[str] = None\n    exchange: Optional[str] = None\n    transaction_type: Optional[str] = None\n    order_type: Optional[str] = None\n    quantity: Optional[int] = None\n    filled_quantity: Optional[int] = None\n    average_price: Optional[float] = None\n    # ... other fields\n    class Config:\n        extra = 'allow' # Allow extra fields from API response\n\n# Placeholder for a single order history entry returned by get_order_history\nclass OrderHistoryEntry(BaseModel):\n    # Add fields based on actual Kite API response for order history\n    # Example fields:\n    order_id: Optional[str] = None\n    status: Optional[str] = None\n    status_message: Optional[str] = None\n    order_timestamp: Optional[str] = None\n    # ... other fields\n    class Config:\n        extra = 'allow' # Allow extra fields from API response\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nimport os\nfrom typing import Dict, Any, List, Optional\nfrom models import (\n    PlaceOrderParams, ModifyOrderParams, CancelOrderParams,\n    GetOrderHistoryParams, Order, OrderHistoryEntry, OrderResponse\n)\n\nlogger = logging.getLogger(__name__)\n\nKITE_API_VERSION = \"3\"\n\nclass KiteConnectError(Exception):\n    \"\"\"Custom exception for Kite Connect API errors.\"\"\"\n    def __init__(self, status_code: int, error_type: str, message: str):\n        self.status_code = status_code\n        self.error_type = error_type\n        self.message = message\n        super().__init__(f\"Kite API Error ({status_code} - {error_type}): {message}\")\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect v3 API.\"\"\"\n\n    def __init__(self):\n        self.api_key = os.getenv(\"KITE_API_KEY\")\n        self.access_token = os.getenv(\"KITE_ACCESS_TOKEN\")\n        self.base_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\n        if not self.api_key or not self.access_token:\n            raise ValueError(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n\n        self.headers = {\n            \"X-Kite-Version\": KITE_API_VERSION,\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form encoding\n        }\n        # Note: Rate limits are 3 requests/second per user per app.\n        # Implementing client-side throttling is complex and not included here.\n        # Ensure your usage pattern respects these limits.\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=30.0 # Set a reasonable timeout\n        )\n\n    async def _request(self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.info(f\"Sending {method} request to {url}\")\n        logger.debug(f\"Headers: {self.headers}\")\n        if data:\n            # Filter out None values before sending\n            filtered_data = {k: v for k, v in data.items() if v is not None}\n            logger.debug(f\"Payload (form data): {filtered_data}\")\n        else:\n            filtered_data = None\n            logger.debug(\"No payload.\")\n\n        try:\n            response = await self.client.request(method, endpoint, params=params, data=filtered_data)\n            logger.info(f\"Received response with status code: {response.status_code}\")\n            logger.debug(f\"Response content: {response.text}\")\n\n            # Check for non-JSON or empty responses before parsing\n            if not response.text:\n                 if 200 <= response.status_code < 300:\n                     logger.warning(f\"Received empty response body with status {response.status_code} for {method} {endpoint}\")\n                     # Handle cases like DELETE success which might return 200 OK with no body\n                     # This behavior might need adjustment based on actual API responses\n                     return {\"status\": \"success\", \"data\": {}} # Assume success if status is 2xx\n                 else:\n                     raise KiteConnectError(response.status_code, \"EmptyResponse\", \"Received empty response from API\")\n\n            response_json = response.json()\n\n            # Raise exceptions for HTTP errors (4xx, 5xx)\n            response.raise_for_status()\n\n            # Check Kite specific error structure (if applicable, based on observed API behavior)\n            if response_json.get(\"status\") == \"error\":\n                error_type = response_json.get(\"error_type\", \"UnknownError\")\n                message = response_json.get(\"message\", \"No error message provided.\")\n                logger.error(f\"Kite API Error: Type={error_type}, Message={message}\")\n                raise KiteConnectError(response.status_code, error_type, message)\n\n            return response_json\n\n        except httpx.HTTPStatusError as e:\n            logger.error(f\"HTTP error occurred: {e.response.status_code} - {e.response.text}\")\n            # Try to parse error details from Kite's response format\n            try:\n                error_data = e.response.json()\n                error_type = error_data.get(\"error_type\", f\"HTTP{e.response.status_code}\")\n                message = error_data.get(\"message\", e.response.text)\n                raise KiteConnectError(e.response.status_code, error_type, message) from e\n            except Exception:\n                 # If parsing fails, raise a generic error\n                 raise KiteConnectError(e.response.status_code, f\"HTTP{e.response.status_code}\", e.response.text) from e\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out: {e}\")\n            raise KiteConnectError(408, \"Timeout\", \"The request to Kite API timed out.\") from e\n        except httpx.RequestError as e:\n            logger.error(f\"An error occurred while requesting {e.request.url!r}: {e}\")\n            raise KiteConnectError(500, \"RequestError\", f\"Failed to connect or send request to Kite API: {e}\") from e\n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during API request: {e}\") # Use exception for stack trace\n            raise KiteConnectError(500, \"UnexpectedError\", f\"An unexpected error occurred: {e}\") from e\n\n    async def place_order(self, params: PlaceOrderParams) -> OrderResponse:\n        \"\"\"Places an order.\"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Convert Pydantic model to dict, excluding 'variety' as it's in the path\n        # Use exclude_unset=True to only send provided optional fields\n        data = params.model_dump(exclude={'variety'}, exclude_unset=True)\n        response_data = await self._request(\"POST\", endpoint, data=data)\n        # Assuming the response structure is {'status': 'success', 'data': {'order_id': '...'}}\n        if response_data.get(\"status\") == \"success\" and \"order_id\" in response_data.get(\"data\", {}):\n            return OrderResponse(**response_data[\"data\"])\n        else:\n            logger.error(f\"Place order failed or returned unexpected format: {response_data}\")\n            raise KiteConnectError(500, \"InvalidResponse\", f\"Unexpected response format from place_order: {response_data}\")\n\n    async def modify_order(self, params: ModifyOrderParams) -> OrderResponse:\n        \"\"\"Modifies an existing order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Convert Pydantic model to dict, excluding path params and unset optional fields\n        data = params.model_dump(exclude={'variety', 'order_id'}, exclude_unset=True)\n        response_data = await self._request(\"PUT\", endpoint, data=data)\n        if response_data.get(\"status\") == \"success\" and \"order_id\" in response_data.get(\"data\", {}):\n            return OrderResponse(**response_data[\"data\"])\n        else:\n            logger.error(f\"Modify order failed or returned unexpected format: {response_data}\")\n            raise KiteConnectError(500, \"InvalidResponse\", f\"Unexpected response format from modify_order: {response_data}\")\n\n    async def cancel_order(self, params: CancelOrderParams) -> OrderResponse:\n        \"\"\"Cancels an existing order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Pass parent_order_id if provided (as form data for DELETE)\n        data = {}\n        if params.parent_order_id:\n            data['parent_order_id'] = params.parent_order_id\n        \n        response_data = await self._request(\"DELETE\", endpoint, data=data if data else None)\n        # Successful DELETE might return {'status': 'success', 'data': {'order_id': '...'}}\n        # Or potentially just 200 OK with minimal/no body - _request handles basic 2xx empty body case\n        if response_data.get(\"status\") == \"success\" and \"order_id\" in response_data.get(\"data\", {}):\n             # Use the original order_id for the response model if API returns it\n            return OrderResponse(order_id=response_data[\"data\"].get(\"order_id\", params.order_id))\n        elif response_data.get(\"status\") == \"success\": # Handle case where data might be empty but status is success\n             logger.warning(f\"Cancel order returned success status but no order_id in data for {params.order_id}\")\n             return OrderResponse(order_id=params.order_id) # Return the ID we tried to cancel\n        else:\n            logger.error(f\"Cancel order failed or returned unexpected format: {response_data}\")\n            raise KiteConnectError(500, \"InvalidResponse\", f\"Unexpected response format from cancel_order: {response_data}\")\n\n    async def get_orders(self) -> List[Order]:\n        \"\"\"Retrieves the list of orders for the day.\"\"\"\n        endpoint = \"/orders\"\n        response_data = await self._request(\"GET\", endpoint)\n        # Assuming response is {'status': 'success', 'data': [...]}\n        if response_data.get(\"status\") == \"success\" and isinstance(response_data.get(\"data\"), list):\n            # Parse each item in the list using the Order model\n            # Use parse_obj_as for robust parsing of list of models\n            from pydantic import parse_obj_as\n            try:\n                return parse_obj_as(List[Order], response_data[\"data\"])\n            except Exception as e:\n                 logger.error(f\"Failed to parse list of orders: {e}\")\n                 raise KiteConnectError(500, \"ParsingError\", f\"Could not parse order list: {e}\")\n        else:\n            logger.error(f\"Get orders failed or returned unexpected format: {response_data}\")\n            raise KiteConnectError(500, \"InvalidResponse\", f\"Unexpected response format from get_orders: {response_data}\")\n\n    async def get_order_history(self, params: GetOrderHistoryParams) -> List[OrderHistoryEntry]:\n        \"\"\"Retrieves the history for a specific order.\"\"\"\n        endpoint = f\"/orders/{params.order_id}\"\n        response_data = await self._request(\"GET\", endpoint)\n        # Assuming response is {'status': 'success', 'data': [...]}\n        if response_data.get(\"status\") == \"success\" and isinstance(response_data.get(\"data\"), list):\n            from pydantic import parse_obj_as\n            try:\n                return parse_obj_as(List[OrderHistoryEntry], response_data[\"data\"])\n            except Exception as e:\n                 logger.error(f\"Failed to parse order history: {e}\")\n                 raise KiteConnectError(500, \"ParsingError\", f\"Could not parse order history list: {e}\")\n        else:\n            logger.error(f\"Get order history failed or returned unexpected format: {response_data}\")\n            raise KiteConnectError(500, \"InvalidResponse\", f\"Unexpected response format from get_order_history: {response_data}\")\n"
    },
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, List\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\n# Import models and client\nfrom models import (\n    PlaceOrderParams, ModifyOrderParams, CancelOrderParams,\n    GetOrdersParams, GetOrderHistoryParams,\n    OrderResponse, Order, OrderHistoryEntry\n)\nfrom client import KiteConnectClient, KiteConnectError\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectOrders\",\n    description=\"Provides tools to manage trading orders (place, modify, cancel, retrieve) using the Kite Connect v3 API.\"\n)\n\n# Initialize API Client\n# Client initialization might raise ValueError if keys are missing\ntry:\n    kite_client = KiteConnectClient()\nexcept ValueError as e:\n    logger.error(f\"Failed to initialize KiteConnectClient: {e}\")\n    # Optionally exit or prevent server start if client can't be initialized\n    raise SystemExit(f\"Configuration Error: {e}\")\n\n# --- Define MCP Tools ---\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Places an order of a specified variety (regular, amo, co, iceberg, auction).\"\"\"\n    logger.info(f\"Received place_order request: {params.model_dump(exclude_unset=True)}\")\n    try:\n        result: OrderResponse = await kite_client.place_order(params)\n        logger.info(f\"Successfully placed order: {result.order_id}\")\n        # Return the dictionary representation of the Pydantic model\n        return result.model_dump()\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error during place_order: {e}\")\n        return {\"error\": str(e), \"error_type\": e.error_type, \"status_code\": e.status_code}\n    except Exception as e:\n        logger.exception(\"Unexpected error during place_order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modifies attributes of an open or pending order.\"\"\"\n    logger.info(f\"Received modify_order request for order_id {params.order_id}: {params.model_dump(exclude={'order_id', 'variety'}, exclude_unset=True)}\")\n    try:\n        result: OrderResponse = await kite_client.modify_order(params)\n        logger.info(f\"Successfully modified order: {result.order_id}\")\n        return result.model_dump()\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error during modify_order: {e}\")\n        return {\"error\": str(e), \"error_type\": e.error_type, \"status_code\": e.status_code}\n    except Exception as e:\n        logger.exception(\"Unexpected error during modify_order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"Cancels an open or pending order.\"\"\"\n    logger.info(f\"Received cancel_order request for order_id {params.order_id}\")\n    try:\n        result: OrderResponse = await kite_client.cancel_order(params)\n        logger.info(f\"Successfully cancelled order: {result.order_id}\")\n        return result.model_dump()\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error during cancel_order: {e}\")\n        return {\"error\": str(e), \"error_type\": e.error_type, \"status_code\": e.status_code}\n    except Exception as e:\n        logger.exception(\"Unexpected error during cancel_order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def get_orders(params: GetOrdersParams) -> Dict[str, Any]:\n    \"\"\"Retrieves the list of all orders (open, pending, executed) for the current trading day.\"\"\"\n    logger.info(\"Received get_orders request\")\n    try:\n        orders: List[Order] = await kite_client.get_orders()\n        logger.info(f\"Successfully retrieved {len(orders)} orders.\")\n        # Convert list of Pydantic models to list of dicts\n        return {\"orders\": [order.model_dump() for order in orders]}\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error during get_orders: {e}\")\n        return {\"error\": str(e), \"error_type\": e.error_type, \"status_code\": e.status_code}\n    except Exception as e:\n        logger.exception(\"Unexpected error during get_orders\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def get_order_history(params: GetOrderHistoryParams) -> Dict[str, Any]:\n    \"\"\"Retrieves the history of a specific order, showing its state transitions.\"\"\"\n    logger.info(f\"Received get_order_history request for order_id {params.order_id}\")\n    try:\n        history: List[OrderHistoryEntry] = await kite_client.get_order_history(params)\n        logger.info(f\"Successfully retrieved {len(history)} history entries for order {params.order_id}.\")\n        # Convert list of Pydantic models to list of dicts\n        return {\"history\": [entry.model_dump() for entry in history]}\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error during get_order_history: {e}\")\n        return {\"error\": str(e), \"error_type\": e.error_type, \"status_code\": e.status_code}\n    except Exception as e:\n        logger.exception(\"Unexpected error during get_order_history\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n# --- Run the MCP Server ---\nif __name__ == \"__main__\":\n    # You would typically run this using uvicorn:\n    # uvicorn main:mcp.app --reload --host 0.0.0.0 --port 8000\n    # The mcp.run() method is for simpler, direct execution if needed (might not support reload)\n    # For production, use a proper ASGI server like uvicorn or hypercorn.\n    logger.info(\"Starting KiteConnectOrders MCP Server...\")\n    # mcp.run() # Use this for simple testing if needed\n    print(\"Run the server using: uvicorn main:mcp.app --reload\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\nhttpx>=0.25.0,<0.28.0\npydantic>=2.0.0,<3.0.0\npython-dotenv>=1.0.0,<2.0.0\nuvicorn>=0.23.0,<0.28.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Environment variables for Kite Connect Orders MCP Server\n\n# Obtain your API key and generate an access token from the Kite Developer Console\n# See: https://kite.trade/docs/connect/v3/user/\n\nKITE_API_KEY=\"YOUR_KITE_API_KEY\"\nKITE_ACCESS_TOKEN=\"YOUR_GENERATED_ACCESS_TOKEN\"\n\n# Optional: Override the base URL if needed (e.g., for testing environments)\n# KITE_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server built with FastMCP to interact with the Kite Connect v3 API, specifically focusing on order management functionalities.\n\nIt allows language models or other clients compatible with MCP to place, modify, cancel, and retrieve trading orders via the Kite platform.\n\n## Features\n\nThis MCP server exposes the following tools:\n\n*   **`place_order`**: Places a new trading order (regular, AMO, CO, Iceberg, Auction).\n*   **`modify_order`**: Modifies attributes (like price, quantity) of an open or pending order (regular, CO).\n*   **`cancel_order`**: Cancels an open or pending order.\n*   **`get_orders`**: Retrieves the list of all orders placed during the current trading day.\n*   **`get_order_history`**: Retrieves the detailed state transition history for a specific order.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create and activate a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect API Key and a valid Access Token:\n        ```env\n        KITE_API_KEY=\"YOUR_KITE_API_KEY\"\n        KITE_ACCESS_TOKEN=\"YOUR_GENERATED_ACCESS_TOKEN\"\n        ```\n    *   **Important:** You need to obtain an `api_key` from Zerodha Kite Connect and generate an `access_token` using their login flow. The `access_token` is typically valid for one trading day. Refer to the [Kite Connect HTTP API documentation](https://kite.trade/docs/connect/v3/user/) for details on obtaining credentials.\n\n## Running the Server\n\nUse an ASGI server like Uvicorn to run the application:\n\n```bash\nuvicorn main:mcp.app --reload --host 0.0.0.0 --port 8000\n```\n\n*   `--reload`: Enables auto-reloading when code changes (useful for development).\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n\nThe server will start, and you can interact with it using an MCP client.\n\n## API Documentation\n\nOnce the server is running, FastAPI automatically generates interactive API documentation.\n\n*   **Swagger UI:** [http://localhost:8000/docs](http://localhost:8000/docs)\n*   **ReDoc:** [http://localhost:8000/redoc](http://localhost:8000/redoc)\n\nThese interfaces allow you to explore the available tools, view their schemas (input parameters and expected responses), and even test them directly from your browser.\n\n## Tool Details\n\nRefer to the API documentation (`/docs`) for detailed information on each tool's parameters and expected data structures.\n\nThe implementation uses Pydantic models (`models.py`) for strict data validation based on the Kite Connect API documentation.\n\n## Error Handling\n\nThe server attempts to catch common errors:\n\n*   **HTTP Errors:** Errors during communication with the Kite API (e.g., 4xx client errors, 5xx server errors).\n*   **Kite API Errors:** Specific errors returned by the Kite API (e.g., insufficient funds, validation errors, order rejections, invalid state for modification/cancellation). These are wrapped in a `KiteConnectError` exception and returned as JSON with `error`, `error_type`, and `status_code` fields.\n*   **Configuration Errors:** Missing API keys or access tokens.\n*   **Unexpected Errors:** Other runtime errors during processing.\n\nError responses are returned in a JSON format like:\n`{\"error\": \"Error message\", \"error_type\": \"KiteErrorType\", \"status_code\": 400}`\n\n## Rate Limits\n\nThe Kite Connect API imposes rate limits (typically 3 requests per second per user per app). This implementation **does not** include client-side rate limiting. Ensure that your usage patterns respect these limits to avoid being blocked by the API.\n\n## Disclaimer\n\nTrading involves substantial risk. This software is provided \"as is\" without warranty of any kind. Use it at your own risk and ensure thorough testing before deploying in a live trading environment.\n"
    }
  ]
}
{
  "files": [
    {
      "name": "main.py",
      "content": "import logging\nimport os\nfrom typing import Any, Dict\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import KiteConnectAPIError, ZerodhaKiteConnectClient\nfrom models import (\n    CancelOrderParams,\n    GetOrderHistoryParams,\n    GetOrderTradesParams,\n    ModifyRegularOrderParams,\n    PlaceOrderParams,\n)\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"ZerodhaKiteConnect\",\n    description=\"MCP server for interacting with the Zerodha Kite Connect v3 Orders API. Allows placing, modifying, cancelling, and retrieving orders and trades.\",\n)\n\n# Initialize API Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\n        \"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\"\n    )\n    # Consider exiting or raising a configuration error\n    # For now, we allow initialization but client calls will fail.\n    api_client = None\nelse:\n    try:\n        api_client = ZerodhaKiteConnectClient(\n            api_key=api_key, access_token=access_token, base_url=base_url\n        )\n        logger.info(\"ZerodhaKiteConnectClient initialized successfully.\")\n    except Exception as e:\n        logger.exception(\"Failed to initialize ZerodhaKiteConnectClient\")\n        api_client = None\n\n\ndef handle_api_error(tool_name: str, error: Exception) -> Dict[str, Any]:\n    \"\"\"Handles errors during API calls and returns a standardized error dict.\"\"\"\n    logger.error(f\"Error in {tool_name}: {error}\", exc_info=True)\n    if isinstance(error, KiteConnectAPIError):\n        return {\n            \"error\": f\"Kite API Error: {error.message}\",\n            \"status_code\": error.code,\n            \"details\": str(error),\n        }\n    elif hasattr(error, \"response\") and error.response is not None:\n        try:\n            details = error.response.json()\n        except Exception:\n            details = error.response.text\n        return {\n            \"error\": f\"HTTP Error: {error.response.status_code}\",\n            \"details\": details,\n        }\n    else:\n        return {\"error\": f\"An unexpected error occurred: {str(error)}\"}\n\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\"\"\"\n    if not api_client:\n        return {\"error\": \"API client not initialized. Check environment variables.\"}\n    try:\n        logger.info(f\"Placing order with params: {params.model_dump_json()}\")\n        result = await api_client.place_order(params)\n        logger.info(f\"Order placed successfully: {result}\")\n        return result\n    except Exception as e:\n        return handle_api_error(\"place_order\", e)\n\n\n@mcp.tool()\nasync def modify_order(params: ModifyRegularOrderParams) -> Dict[str, Any]:\n    \"\"\"Modify attributes of an open or pending regular or CO order.\"\"\"\n    if not api_client:\n        return {\"error\": \"API client not initialized. Check environment variables.\"}\n    try:\n        logger.info(f\"Modifying order with params: {params.model_dump_json()}\")\n        result = await api_client.modify_order(params)\n        logger.info(f\"Order modified successfully: {result}\")\n        return result\n    except Exception as e:\n        return handle_api_error(\"modify_order\", e)\n\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"Cancel an open or pending order.\"\"\"\n    if not api_client:\n        return {\"error\": \"API client not initialized. Check environment variables.\"}\n    try:\n        logger.info(f\"Cancelling order with params: {params.model_dump_json()}\")\n        result = await api_client.cancel_order(params)\n        logger.info(f\"Order cancelled successfully: {result}\")\n        return result\n    except Exception as e:\n        return handle_api_error(\"cancel_order\", e)\n\n\n@mcp.tool()\nasync def get_orders() -> Dict[str, Any]:\n    \"\"\"Retrieve the list of all orders for the current trading day.\"\"\"\n    if not api_client:\n        return {\"error\": \"API client not initialized. Check environment variables.\"}\n    try:\n        logger.info(\"Retrieving all orders.\")\n        result = await api_client.get_orders()\n        logger.info(f\"Retrieved {len(result.get('data', []))} orders.\")\n        return result\n    except Exception as e:\n        return handle_api_error(\"get_orders\", e)\n\n\n@mcp.tool()\nasync def get_order_history(params: GetOrderHistoryParams) -> Dict[str, Any]:\n    \"\"\"Retrieve the history (state transitions) of a given order.\"\"\"\n    if not api_client:\n        return {\"error\": \"API client not initialized. Check environment variables.\"}\n    try:\n        logger.info(f\"Retrieving order history for order_id: {params.order_id}\")\n        result = await api_client.get_order_history(params.order_id)\n        logger.info(\n            f\"Retrieved history for order {params.order_id}: {len(result.get('data', []))} states.\"\n        )\n        return result\n    except Exception as e:\n        return handle_api_error(\"get_order_history\", e)\n\n\n@mcp.tool()\nasync def get_trades() -> Dict[str, Any]:\n    \"\"\"Retrieve the list of all executed trades for the current trading day.\"\"\"\n    if not api_client:\n        return {\"error\": \"API client not initialized. Check environment variables.\"}\n    try:\n        logger.info(\"Retrieving all trades.\")\n        result = await api_client.get_trades()\n        logger.info(f\"Retrieved {len(result.get('data', []))} trades.\")\n        return result\n    except Exception as e:\n        return handle_api_error(\"get_trades\", e)\n\n\n@mcp.tool()\nasync def get_order_trades(params: GetOrderTradesParams) -> Dict[str, Any]:\n    \"\"\"Retrieve the trades generated by a specific order.\"\"\"\n    if not api_client:\n        return {\"error\": \"API client not initialized. Check environment variables.\"}\n    try:\n        logger.info(f\"Retrieving trades for order_id: {params.order_id}\")\n        result = await api_client.get_order_trades(params.order_id)\n        logger.info(\n            f\"Retrieved trades for order {params.order_id}: {len(result.get('data', []))} trades.\"\n        )\n        return result\n    except Exception as e:\n        return handle_api_error(\"get_order_trades\", e)\n\n\nif __name__ == \"__main__\":\n    if not api_client:\n        logger.critical(\n            \"API Client could not be initialized. MCP server cannot start without valid API credentials.\"\n        )\n    else:\n        logger.info(\"Starting ZerodhaKiteConnect MCP server...\")\n        # Note: FastMCP().run() uses uvicorn.run() which might need host/port config\n        # depending on deployment needs. Default is 127.0.0.1:8000\n        mcp.run() # Add host=\"0.0.0.0\", port=8001 etc. if needed\n"
    },
    {
      "name": "models.py",
      "content": "from typing import Any, Dict, List, Literal, Optional\n\nfrom pydantic import BaseModel, Field, field_validator\n\n# Literal types for Zerodha API parameters\nVarietyType = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nExchangeType = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\nModifyVarietyType = Literal['regular', 'co'] # Modify only supports these\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange.\")\n    transaction_type: TransactionType = Field(..., description=\"Transaction type.\")\n    order_type: OrderType = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: ProductType = Field(..., description=\"Product type.\")\n    validity: ValidityType = Field(..., description=\"Order validity.\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders.\")\n    trigger_price: Optional[float] = Field(None, description=\"Trigger price for SL/SL-M orders.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity.\")\n    iceberg_legs: Optional[int] = Field(None, ge=2, le=10, description=\"Total legs for iceberg order (2-10).\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg.\")\n    auction_number: Optional[str] = Field(None, description=\"Unique identifier for auction orders.\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"Optional order tag (alphanumeric, max 20 chars).\")\n\n    @field_validator('price')\n    def check_price_for_limit(cls, v, values):\n        data = values.data\n        if data.get('order_type') == 'LIMIT' and v is None:\n            raise ValueError('Price is required for LIMIT orders')\n        if data.get('order_type') == 'MARKET' and v is not None:\n             # Kite API ignores price for MARKET orders, but good to be explicit\n             # raise ValueError('Price should not be provided for MARKET orders')\n             pass # Allow it, API might handle it gracefully\n        return v\n\n    @field_validator('trigger_price')\n    def check_trigger_price(cls, v, values):\n        data = values.data\n        if data.get('order_type') in ['SL', 'SL-M'] and v is None:\n            raise ValueError('Trigger price is required for SL and SL-M orders')\n        return v\n\n    @field_validator('validity_ttl')\n    def check_validity_ttl(cls, v, values):\n        data = values.data\n        if data.get('validity') == 'TTL' and v is None:\n            raise ValueError('validity_ttl is required for TTL validity')\n        if data.get('validity') != 'TTL' and v is not None:\n            raise ValueError('validity_ttl is only applicable for TTL validity')\n        return v\n\n    @field_validator('iceberg_legs', 'iceberg_quantity')\n    def check_iceberg_params(cls, v, info):\n        values = info.data\n        field_name = info.field_name\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError(f'{field_name} is required for iceberg orders')\n        if values.get('variety') != 'iceberg' and v is not None:\n            raise ValueError(f'{field_name} is only applicable for iceberg orders')\n        return v\n\n    @field_validator('auction_number')\n    def check_auction_number(cls, v, values):\n        data = values.data\n        if data.get('variety') == 'auction' and v is None:\n            raise ValueError('auction_number is required for auction orders')\n        if data.get('variety') != 'auction' and v is not None:\n            raise ValueError('auction_number is only applicable for auction orders')\n        return v\n\nclass ModifyRegularOrderParams(BaseModel):\n    \"\"\"Parameters for modifying a regular or CO order.\"\"\"\n    variety: ModifyVarietyType = Field(..., description=\"Order variety ('regular' or 'co').\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    # Fields applicable only for 'regular' variety modification\n    order_type: Optional[OrderType] = Field(None, description=\"New order type (regular only).\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity (regular only).\")\n    validity: Optional[ValidityType] = Field(None, description=\"New order validity (regular only).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (regular only).\")\n    # Fields applicable for both 'regular' and 'co' modification\n    price: Optional[float] = Field(None, description=\"New price (LIMIT/SL orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (SL/SL-M/CO orders).\")\n\n    @field_validator('order_type', 'quantity', 'validity', 'disclosed_quantity')\n    def check_regular_only_fields(cls, v, info):\n        values = info.data\n        field_name = info.field_name\n        if values.get('variety') == 'co' and v is not None:\n            raise ValueError(f'{field_name} cannot be modified for CO orders.')\n        return v\n\nclass CancelOrderParams(BaseModel):\n    \"\"\"Parameters for cancelling an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety.\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel.\")\n\nclass GetOrdersParams(BaseModel):\n    \"\"\"Parameters for retrieving all orders (no specific params needed).\"\"\"\n    pass # No parameters required for this endpoint\n\nclass GetOrderHistoryParams(BaseModel):\n    \"\"\"Parameters for retrieving the history of a specific order.\"\"\"\n    order_id: str = Field(..., description=\"The ID of the order whose history is to be retrieved.\")\n\nclass GetTradesParams(BaseModel):\n    \"\"\"Parameters for retrieving all trades (no specific params needed).\"\"\"\n    pass # No parameters required for this endpoint\n\nclass GetOrderTradesParams(BaseModel):\n    \"\"\"Parameters for retrieving trades for a specific order.\"\"\"\n    order_id: str = Field(..., description=\"The ID of the order whose trades are to be retrieved.\")\n\n# Generic response models (optional, but good practice)\nclass KiteResponseData(BaseModel):\n    order_id: Optional[str] = None\n    # Add other potential fields if needed\n\nclass KiteResponse(BaseModel):\n    status: str\n    data: Optional[Any] = None # Can be Dict, List[Dict], etc.\n    message: Optional[str] = None\n    error_type: Optional[str] = None\n"
    },
    {
      "name": "client.py",
      "content": "import asyncio\nimport logging\nfrom typing import Any, Dict, Optional\n\nimport httpx\nfrom pydantic import ValidationError\n\nfrom models import (\n    CancelOrderParams,\n    ModifyRegularOrderParams,\n    PlaceOrderParams,\n)\n\nlogger = logging.getLogger(__name__)\n\n# Define custom exceptions\nclass KiteConnectAPIError(Exception):\n    \"\"\"Represents an error returned by the Kite Connect API.\"\"\"\n\n    def __init__(self, message: str, code: Optional[int] = None):\n        self.message = message\n        self.code = code\n        super().__init__(f\"[{code}] {message}\" if code else message)\n\n\nclass ZerodhaKiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Zerodha Kite Connect v3 Orders API.\"\"\"\n\n    DEFAULT_TIMEOUT = 30.0  # seconds\n    KITE_API_VERSION = \"3\"\n\n    def __init__(\n        self,\n        api_key: str,\n        access_token: str,\n        base_url: str = \"https://api.kite.trade\",\n        timeout: float = DEFAULT_TIMEOUT,\n    ):\n        \"\"\"Initializes the Zerodha Kite Connect client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after successful login.\n            base_url: The base URL for the Kite Connect API.\n            timeout: Default request timeout in seconds.\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.timeout = timeout\n\n        headers = {\n            \"X-Kite-Version\": self.KITE_API_VERSION,\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            # Content-Type is set per request based on method\n        }\n\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url, headers=headers, timeout=self.timeout\n        )\n        # Note: httpx doesn't have built-in rate limiting. For high-frequency trading,\n        # consider libraries like 'aiolimiter' or custom middleware.\n        # Kite Connect limits: Orders (3/s), Modify/Cancel (3/s), Reads (10/s)\n\n    async def _request(\n        self,\n        method: str,\n        endpoint: str,\n        params: Optional[Dict[str, Any]] = None,\n        data: Optional[Dict[str, Any]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite Connect API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        headers = self.client.headers.copy()\n\n        # Kite API expects POST/PUT data as form-encoded, not JSON\n        content_type = (\n            \"application/x-www-form-urlencoded\"\n            if method in [\"POST\", \"PUT\"]\n            else \"application/json\"\n        )\n        headers[\"Content-Type\"] = content_type\n\n        # Filter out None values from data payload\n        if data:\n            processed_data = {k: v for k, v in data.items() if v is not None}\n        else:\n            processed_data = None\n\n        logger.debug(f\"Request: {method} {url} Params: {params} Data: {processed_data}\")\n\n        try:\n            response = await self.client.request(\n                method,\n                endpoint, # Use relative endpoint with base_url in client\n                params=params,\n                data=processed_data, # Pass form data here for POST/PUT\n                headers=headers,\n            )\n\n            logger.debug(\n                f\"Response Status: {response.status_code} Content: {response.text[:500]}...\"\n            )\n            response.raise_for_status()  # Raises HTTPStatusError for 4xx/5xx\n            json_response = response.json()\n\n            # Check for API-level errors within the JSON response\n            if json_response.get(\"status\") == \"error\":\n                logger.error(\n                    f\"Kite API Error: {json_response.get('message')} (Type: {json_response.get('error_type')})\"\n                )\n                raise KiteConnectAPIError(\n                    message=json_response.get(\"message\", \"Unknown API error\"),\n                    code=response.status_code, # Use HTTP status code if specific code not available\n                )\n\n            return json_response\n\n        except httpx.HTTPStatusError as e:\n            logger.error(\n                f\"HTTP Error: {e.response.status_code} for {e.request.url}. Response: {e.response.text}\"\n            )\n            # Try to parse error details from response\n            try:\n                error_data = e.response.json()\n                message = error_data.get(\"message\", e.response.text)\n                raise KiteConnectAPIError(message=message, code=e.response.status_code) from e\n            except Exception:\n                 # If response is not JSON or parsing fails\n                 raise KiteConnectAPIError(message=e.response.text, code=e.response.status_code) from e\n\n        except httpx.RequestError as e:\n            logger.error(f\"Request Error for {e.request.url}: {e}\")\n            raise KiteConnectAPIError(f\"Request failed: {e}\") from e\n        except ValidationError as e:\n             logger.error(f\"Pydantic Validation Error: {e}\")\n             raise KiteConnectAPIError(f\"Internal data validation error: {e}\", code=400) from e\n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during API request: {e}\")\n            raise KiteConnectAPIError(f\"An unexpected error occurred: {e}\") from e\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, Any]:\n        \"\"\"Place an order.\"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Exclude 'variety' from the data payload as it's in the path\n        data = params.model_dump(exclude={'variety'}, exclude_unset=True)\n        return await self._request(\"POST\", endpoint, data=data)\n\n    async def modify_order(self, params: ModifyRegularOrderParams) -> Dict[str, Any]:\n        \"\"\"Modify an existing order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Exclude 'variety' and 'order_id' from the data payload\n        data = params.model_dump(exclude={'variety', 'order_id'}, exclude_unset=True)\n        return await self._request(\"PUT\", endpoint, data=data)\n\n    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, Any]:\n        \"\"\"Cancel an order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # No data payload for DELETE, params are in the path\n        return await self._request(\"DELETE\", endpoint)\n\n    async def get_orders(self) -> Dict[str, Any]:\n        \"\"\"Retrieve the list of all orders.\"\"\"\n        endpoint = \"/orders\"\n        return await self._request(\"GET\", endpoint)\n\n    async def get_order_history(self, order_id: str) -> Dict[str, Any]:\n        \"\"\"Retrieve the history of a specific order.\"\"\"\n        endpoint = f\"/orders/{order_id}\"\n        return await self._request(\"GET\", endpoint)\n\n    async def get_trades(self) -> Dict[str, Any]:\n        \"\"\"Retrieve the list of all trades.\"\"\"\n        endpoint = \"/trades\"\n        return await self._request(\"GET\", endpoint)\n\n    async def get_order_trades(self, order_id: str) -> Dict[str, Any]:\n        \"\"\"Retrieve trades for a specific order.\"\"\"\n        # Correct endpoint according to Kite Connect documentation\n        endpoint = f\"/orders/{order_id}/trades\"\n        return await self._request(\"GET\", endpoint)\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"ZerodhaKiteConnectClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=2.0.0\nhttpx>=0.25.0\npython-dotenv>=1.0.0\nuvicorn>=0.23.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Zerodha Kite Connect API Credentials\n# Obtain these from https://developers.kite.trade/\n\n# Your Kite Connect API Key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# Your ACCESS TOKEN obtained after successful login flow (short-lived)\n# See Kite Connect documentation for generating access tokens\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# Base URL for the Kite Connect API (usually no need to change)\nKITE_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Zerodha Kite Connect MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect v3 Orders API using FastMCP. It allows language models or other applications to manage trading orders (place, modify, cancel) and retrieve order/trade information through a standardized MCP interface.\n\n## Features\n\n*   Place various types of orders (regular, AMO, CO, Iceberg, Auction).\n*   Modify existing pending orders (regular, CO).\n*   Cancel pending orders.\n*   Retrieve all orders for the day.\n*   Retrieve the history (state transitions) of a specific order.\n*   Retrieve all executed trades for the day.\n*   Retrieve trades associated with a specific order.\n*   Asynchronous API client built with `httpx`.\n*   Input validation using Pydantic models.\n*   Environment variable-based configuration for API credentials.\n*   Basic error handling for API and network issues.\n\n## Prerequisites\n\n*   Python 3.8+\n*   A Zerodha Kite Connect API Key and Secret.\n*   A valid `access_token` generated through the Kite Connect login flow. **Note:** Access tokens are short-lived and need to be regenerated periodically (typically daily). This server assumes a valid token is provided via environment variables; it does not handle the token generation flow itself.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository_url>\n    cd <repository_directory>\n    ```\n\n2.  **Create and activate a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    Create a `.env` file in the project root directory by copying the example file:\n    ```bash\n    cp .env.example .env\n    ```\n    Edit the `.env` file and replace the placeholder values with your actual Kite Connect API Key and a valid Access Token:\n    ```dotenv\n    # Zerodha Kite Connect API Credentials\n    KITE_API_KEY=\"YOUR_ACTUAL_API_KEY\"\n    KITE_ACCESS_TOKEN=\"YOUR_VALID_ACCESS_TOKEN\"\n    KITE_BASE_URL=\"https://api.kite.trade\"\n    ```\n    **Important:** Keep your `.env` file secure and do not commit it to version control.\n\n## Running the Server\n\nStart the MCP server using Uvicorn (which is called by `mcp.run()`):\n\n```bash\npython main.py\n```\n\nThe server will start, typically listening on `http://127.0.0.1:8000` by default. You can configure the host and port in the `mcp.run()` call within `main.py` if needed.\n\n## Available Tools (MCP Endpoints)\n\nThe server exposes the following tools callable via the MCP protocol:\n\n1.  **`place_order(params: PlaceOrderParams)`**\n    *   Description: Place an order of a particular variety.\n    *   Input: `PlaceOrderParams` model (see `models.py` for fields like `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, `validity`, etc.).\n    *   Returns: Dictionary with order ID on success, or error details.\n\n2.  **`modify_order(params: ModifyRegularOrderParams)`**\n    *   Description: Modify attributes of an open/pending regular or CO order.\n    *   Input: `ModifyRegularOrderParams` model (see `models.py` for fields like `variety`, `order_id`, `quantity`, `price`, `trigger_price`, etc.).\n    *   Returns: Dictionary with order ID on success, or error details.\n\n3.  **`cancel_order(params: CancelOrderParams)`**\n    *   Description: Cancel an open or pending order.\n    *   Input: `CancelOrderParams` model (`variety`, `order_id`).\n    *   Returns: Dictionary with order ID on success, or error details.\n\n4.  **`get_orders()`**\n    *   Description: Retrieve the list of all orders for the day.\n    *   Input: None.\n    *   Returns: Dictionary containing a list of order details, or error details.\n\n5.  **`get_order_history(params: GetOrderHistoryParams)`**\n    *   Description: Retrieve the history (state transitions) of a given order.\n    *   Input: `GetOrderHistoryParams` model (`order_id`).\n    *   Returns: Dictionary containing a list of order states, or error details.\n\n6.  **`get_trades()`**\n    *   Description: Retrieve the list of all executed trades for the day.\n    *   Input: None.\n    *   Returns: Dictionary containing a list of trade details, or error details.\n\n7.  **`get_order_trades(params: GetOrderTradesParams)`**\n    *   Description: Retrieve the trades generated by a specific order.\n    *   Input: `GetOrderTradesParams` model (`order_id`).\n    *   Returns: Dictionary containing a list of trade details for the order, or error details.\n\n## Error Handling\n\nThe API client (`client.py`) includes error handling for:\n*   HTTP errors (4xx, 5xx)\n*   Network request errors\n*   Kite Connect API specific errors (returned in the response body)\n*   Pydantic validation errors\n\nErrors are logged, and the MCP tools return a dictionary with an `\"error\"` key and details when issues occur.\n\n## Rate Limiting\n\nZerodha Kite Connect imposes rate limits on API requests (e.g., 3 requests/second for order placement/modification/cancellation, 10 requests/second for data retrieval). This implementation uses `httpx` but **does not** have built-in automatic rate limiting handling. For applications requiring high request volumes, consider implementing rate limiting using libraries like `aiolimiter` or adding delays between requests.\n\n## Disclaimer\n\nTrading involves substantial risk. This software is provided \"as is\" without warranty of any kind. Use it at your own risk and ensure you understand the implications of automated trading before deploying it.\n"
    }
  ]
}
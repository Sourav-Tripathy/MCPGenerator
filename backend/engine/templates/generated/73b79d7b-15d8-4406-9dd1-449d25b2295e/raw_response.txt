{
  "files": [
    {
      "name": "main.py",
      "content": "import logging\nimport os\nfrom typing import Dict, Optional\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import KiteConnectClient, KiteApiException\nfrom models import PlaceOrderParams, ModifyOrderParams\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# --- Configuration ---\nSERVICE_NAME = \"ZerodhaKiteConnectOrders\"\nDESCRIPTION = \"Provides tools to manage trading orders (place, modify) using the Zerodha Kite Connect v3 API.\"\n\nKITE_API_KEY = os.getenv(\"KITE_API_KEY\")\nKITE_ACCESS_TOKEN = os.getenv(\"KITE_ACCESS_TOKEN\")\nKITE_BASE_URL = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not KITE_API_KEY or not KITE_ACCESS_TOKEN:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables or .env file.\")\n    exit(1)\n\n# --- Initialize MCP and API Client ---\nmcp = FastMCP(SERVICE_NAME, description=DESCRIPTION)\nkite_client = KiteConnectClient(\n    api_key=KITE_API_KEY,\n    access_token=KITE_ACCESS_TOKEN,\n    base_url=KITE_BASE_URL\n)\n\n# --- Define MCP Tools ---\n\n@mcp.tool()\nasync def place_order(\n    variety: str,\n    tradingsymbol: str,\n    exchange: str,\n    transaction_type: str,\n    order_type: str,\n    quantity: int,\n    product: str,\n    validity: str,\n    price: Optional[float] = None,\n    trigger_price: Optional[float] = None,\n    disclosed_quantity: Optional[int] = None,\n    validity_ttl: Optional[int] = None,\n    iceberg_legs: Optional[int] = None,\n    iceberg_quantity: Optional[int] = None,\n    auction_number: Optional[str] = None,\n    tag: Optional[str] = None\n) -> Dict[str, str]:\n    \"\"\"Places an order of a specified variety (regular, amo, co, iceberg, auction).\n\n    Args:\n        variety: Order variety (regular, amo, co, iceberg, auction). This will be part of the URL path.\n        tradingsymbol: Tradingsymbol of the instrument (e.g., 'INFY', 'NIFTY23JUL18000CE').\n        exchange: Name of the exchange (e.g., NSE, BSE, NFO, CDS, BCD, MCX).\n        transaction_type: Transaction type: 'BUY' or 'SELL'.\n        order_type: Order type: 'MARKET', 'LIMIT', 'SL', 'SL-M'.\n        quantity: Quantity to transact.\n        product: Product type: 'CNC', 'NRML', 'MIS', 'MTF'.\n        validity: Order validity: 'DAY', 'IOC', 'TTL'.\n        price: The price for LIMIT orders.\n        trigger_price: The trigger price for SL, SL-M orders. Also used for CO.\n        disclosed_quantity: Quantity to disclose publicly (for equity trades).\n        validity_ttl: Order life span in minutes for TTL validity orders.\n        iceberg_legs: Total number of legs for iceberg order type (2-10). Required for variety='iceberg'.\n        iceberg_quantity: Split quantity for each iceberg leg (quantity/iceberg_legs). Required for variety='iceberg'.\n        auction_number: Unique identifier for a specific auction. Required for variety='auction'.\n        tag: Optional tag for the order (alphanumeric, max 20 chars).\n\n    Returns:\n        A dictionary containing the 'order_id' of the placed order upon success.\n    \"\"\"\n    logger.info(f\"Received place_order request for {tradingsymbol}\")\n    try:\n        params = PlaceOrderParams(\n            variety=variety,\n            tradingsymbol=tradingsymbol,\n            exchange=exchange,\n            transaction_type=transaction_type,\n            order_type=order_type,\n            quantity=quantity,\n            product=product,\n            validity=validity,\n            price=price,\n            trigger_price=trigger_price,\n            disclosed_quantity=disclosed_quantity,\n            validity_ttl=validity_ttl,\n            iceberg_legs=iceberg_legs,\n            iceberg_quantity=iceberg_quantity,\n            auction_number=auction_number,\n            tag=tag\n        )\n        result = await kite_client.place_order(params)\n        logger.info(f\"Successfully placed order {result.get('order_id')}\")\n        return result\n    except KiteApiException as e:\n        logger.error(f\"Kite API error during place_order: {e}\")\n        # Propagate API specific errors for better client handling\n        raise\n    except Exception as e:\n        logger.exception(f\"Unexpected error during place_order: {e}\")\n        # Raise a generic exception for unexpected errors\n        raise RuntimeError(f\"An unexpected error occurred: {e}\")\n\n@mcp.tool()\nasync def modify_order(\n    variety: str,\n    order_id: str,\n    parent_order_id: Optional[str] = None,\n    order_type: Optional[str] = None,\n    quantity: Optional[int] = None,\n    price: Optional[float] = None,\n    trigger_price: Optional[float] = None,\n    disclosed_quantity: Optional[int] = None,\n    validity: Optional[str] = None\n) -> Dict[str, str]:\n    \"\"\"Modifies attributes of a pending regular or cover order.\n\n    Args:\n        variety: Variety of the order to modify (e.g., 'regular', 'co'). Path parameter.\n        order_id: The ID of the order to modify. Path parameter.\n        parent_order_id: ID of the parent order (required for modifying second-leg CO orders).\n        order_type: New order type (e.g., 'LIMIT', 'MARKET').\n        quantity: New quantity.\n        price: New price (for LIMIT orders).\n        trigger_price: New trigger price (for SL, SL-M, CO orders).\n        disclosed_quantity: New disclosed quantity.\n        validity: New validity ('DAY', 'IOC').\n\n    Returns:\n        A dictionary containing the 'order_id' of the modified order upon success.\n    \"\"\"\n    logger.info(f\"Received modify_order request for order_id {order_id}\")\n    try:\n        params = ModifyOrderParams(\n            variety=variety,\n            order_id=order_id,\n            parent_order_id=parent_order_id,\n            order_type=order_type,\n            quantity=quantity,\n            price=price,\n            trigger_price=trigger_price,\n            disclosed_quantity=disclosed_quantity,\n            validity=validity\n        )\n        result = await kite_client.modify_order(params)\n        logger.info(f\"Successfully modified order {result.get('order_id')}\")\n        return result\n    except KiteApiException as e:\n        logger.error(f\"Kite API error during modify_order: {e}\")\n        raise\n    except Exception as e:\n        logger.exception(f\"Unexpected error during modify_order: {e}\")\n        raise RuntimeError(f\"An unexpected error occurred: {e}\")\n\n# --- Run MCP Server ---\nif __name__ == \"__main__\":\n    logger.info(f\"Starting {SERVICE_NAME} MCP Server...\")\n    mcp.run()\n"
    },
    {
      "name": "models.py",
      "content": "from typing import Optional, Dict, Any\nfrom pydantic import BaseModel, Field, validator\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\n\n    Corresponds to the input model for the 'place_order' tool.\n    \"\"\"\n    variety: str = Field(..., description=\"Order variety (regular, amo, co, iceberg, auction). This will be part of the URL path.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., 'INFY', 'NIFTY23JUL18000CE').\")\n    exchange: str = Field(..., description=\"Name of the exchange (e.g., NSE, BSE, NFO, CDS, BCD, MCX).\")\n    transaction_type: str = Field(..., description=\"Transaction type: 'BUY' or 'SELL'.\")\n    order_type: str = Field(..., description=\"Order type: 'MARKET', 'LIMIT', 'SL', 'SL-M'.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: str = Field(..., description=\"Product type: 'CNC', 'NRML', 'MIS', 'MTF'.\")\n    validity: str = Field(..., description=\"Order validity: 'DAY', 'IOC', 'TTL'.\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders.\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders. Also used for CO.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10). Required for variety='iceberg'.\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg (quantity/iceberg_legs). Required for variety='iceberg'.\")\n    auction_number: Optional[str] = Field(None, description=\"Unique identifier for a specific auction. Required for variety='auction'.\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"Optional tag for the order (alphanumeric, max 20 chars).\")\n\n    @validator('transaction_type')\n    def transaction_type_must_be_buy_or_sell(cls, v):\n        if v.upper() not in ['BUY', 'SELL']:\n            raise ValueError('transaction_type must be BUY or SELL')\n        return v.upper()\n\n    @validator('order_type')\n    def order_type_must_be_valid(cls, v):\n        if v.upper() not in ['MARKET', 'LIMIT', 'SL', 'SL-M']:\n            raise ValueError('order_type must be MARKET, LIMIT, SL, or SL-M')\n        return v.upper()\n\n    @validator('validity')\n    def validity_must_be_valid(cls, v):\n        if v.upper() not in ['DAY', 'IOC', 'TTL']:\n            raise ValueError('validity must be DAY, IOC, or TTL')\n        return v.upper()\n\n    @validator('product')\n    def product_must_be_valid(cls, v):\n        if v.upper() not in ['CNC', 'NRML', 'MIS', 'MTF']:\n            raise ValueError('product must be CNC, NRML, MIS, or MTF')\n        return v.upper()\n\n    @validator('price')\n    def price_required_for_limit(cls, v, values):\n        if values.get('order_type') == 'LIMIT' and v is None:\n            raise ValueError('price is required for LIMIT orders')\n        if values.get('order_type') != 'LIMIT' and v is not None:\n             # Kite API might ignore it, but better to be explicit\n             pass # Allow price for non-limit, though it might be ignored by API\n        return v\n\n    @validator('trigger_price')\n    def trigger_price_required_for_sl(cls, v, values):\n        order_type = values.get('order_type')\n        variety = values.get('variety')\n        if order_type in ['SL', 'SL-M'] and v is None:\n            raise ValueError('trigger_price is required for SL/SL-M orders')\n        if variety == 'co' and v is None:\n            raise ValueError('trigger_price is required for CO orders')\n        return v\n\n    @validator('validity_ttl')\n    def validity_ttl_required_for_ttl(cls, v, values):\n        if values.get('validity') == 'TTL' and v is None:\n            raise ValueError('validity_ttl is required for TTL validity')\n        return v\n\n    @validator('iceberg_legs')\n    def iceberg_legs_required_for_iceberg(cls, v, values):\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError('iceberg_legs is required for iceberg variety')\n        if v is not None and not (2 <= v <= 10):\n             raise ValueError('iceberg_legs must be between 2 and 10')\n        return v\n\n    @validator('iceberg_quantity')\n    def iceberg_quantity_required_for_iceberg(cls, v, values):\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError('iceberg_quantity is required for iceberg variety')\n        # Add check: iceberg_quantity * iceberg_legs == quantity ? Maybe too strict, API handles this.\n        return v\n\n    @validator('auction_number')\n    def auction_number_required_for_auction(cls, v, values):\n        if values.get('variety') == 'auction' and v is None:\n            raise ValueError('auction_number is required for auction variety')\n        return v\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Parameters for modifying an order.\n\n    Corresponds to the input model for the 'modify_order' tool.\n    \"\"\"\n    variety: str = Field(..., description=\"Variety of the order to modify (e.g., 'regular', 'co'). Path parameter.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify. Path parameter.\")\n    parent_order_id: Optional[str] = Field(None, description=\"ID of the parent order (required for modifying second-leg CO orders).\")\n    order_type: Optional[str] = Field(None, description=\"New order type (e.g., 'LIMIT', 'MARKET').\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity.\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, CO orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity.\")\n    validity: Optional[str] = Field(None, description=\"New validity ('DAY', 'IOC').\")\n\n    @validator('order_type')\n    def order_type_must_be_valid(cls, v):\n        if v is not None and v.upper() not in ['MARKET', 'LIMIT', 'SL', 'SL-M']:\n            raise ValueError('order_type must be MARKET, LIMIT, SL, or SL-M')\n        return v.upper() if v else None\n\n    @validator('validity')\n    def validity_must_be_valid(cls, v):\n        if v is not None and v.upper() not in ['DAY', 'IOC']:\n            raise ValueError('validity must be DAY or IOC')\n        return v.upper() if v else None\n\n    @validator('price')\n    def price_check_with_order_type(cls, v, values):\n        # If order_type is being changed to LIMIT, price might become required\n        # If order_type is being changed away from LIMIT, price might become irrelevant\n        # API likely handles this, so basic validation is sufficient here.\n        if values.get('order_type') == 'LIMIT' and v is None:\n            # This might be okay if the original order was LIMIT and price isn't changing\n            # Let the API handle this specific validation case during modification\n            pass\n        return v\n\n    @validator('trigger_price')\n    def trigger_price_check_with_order_type(cls, v, values):\n        # Similar logic as price - API validation is more robust for modifications\n        order_type = values.get('order_type')\n        if order_type in ['SL', 'SL-M'] and v is None:\n            # Might be okay if not changing trigger_price\n            pass\n        return v\n\n# Although the plan specifies Dict[str, str], a model provides better structure if needed later.\nclass OrderResponse(BaseModel):\n    order_id: str\n"
    },
    {
      "name": "client.py",
      "content": "import logging\nfrom typing import Dict, Any, Optional\n\nimport httpx\n\nfrom models import PlaceOrderParams, ModifyOrderParams\n\nlogger = logging.getLogger(__name__)\n\nclass KiteApiException(Exception):\n    \"\"\"Custom exception for Kite Connect API errors.\"\"\"\n    def __init__(self, status_code: int, error_type: str, message: str):\n        self.status_code = status_code\n        self.error_type = error_type\n        self.message = message\n        super().__init__(f\"[{status_code}|{error_type}] {message}\")\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Zerodha Kite Connect v3 API.\n\n    Handles authentication, request formatting, and error handling.\n    \"\"\"\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.timeout = timeout\n        self._client: Optional[httpx.AsyncClient] = None\n\n    async def _get_client(self) -> httpx.AsyncClient:\n        \"\"\"Initializes and returns the httpx.AsyncClient instance.\"\"\"\n        if self._client is None or self._client.is_closed:\n            headers = {\n                \"X-Kite-Version\": \"3\",\n                \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n                # Content-Type is set by httpx based on 'data' or 'json'\n            }\n            self._client = httpx.AsyncClient(\n                base_url=self.base_url,\n                headers=headers,\n                timeout=self.timeout\n            )\n            logger.info(\"Initialized KiteConnectClient httpx client.\")\n        return self._client\n\n    async def close(self):\n        \"\"\"Closes the underlying httpx client.\"\"\"\n        if self._client and not self._client.is_closed:\n            await self._client.aclose()\n            logger.info(\"Closed KiteConnectClient httpx client.\")\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous request to the Kite Connect API.\"\"\"\n        client = await self._get_client()\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Making {method} request to {url} with data: {data}\")\n\n        try:\n            response = await client.request(method, endpoint, data=data)\n            logger.debug(f\"Received response: Status={response.status_code}, Body={response.text[:500]}\") # Log truncated body\n\n            # Check for specific Kite API error responses\n            if response.status_code >= 400:\n                try:\n                    error_data = response.json()\n                    error_type = error_data.get(\"error_type\", \"UnknownError\")\n                    message = error_data.get(\"message\", \"No error message provided.\")\n                    raise KiteApiException(response.status_code, error_type, message)\n                except (ValueError, KeyError):\n                    # If response is not JSON or doesn't match expected error format\n                    raise KiteApiException(response.status_code, \"UnknownApiError\", response.text)\n\n            # Check for non-JSON success responses (shouldn't happen for orders, but good practice)\n            try:\n                response_data = response.json()\n                if response_data.get(\"status\") == \"error\":\n                     error_type = response_data.get(\"error_type\", \"UnknownError\")\n                     message = response_data.get(\"message\", \"Unknown error from API.\")\n                     raise KiteApiException(response.status_code, error_type, message)\n\n                return response_data.get(\"data\", {}) # Orders API returns data field\n            except ValueError:\n                 raise KiteApiException(response.status_code, \"InvalidResponseFormat\", \"API response was not valid JSON.\")\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out: {e}\")\n            raise KiteApiException(504, \"TimeoutError\", f\"Request timed out after {self.timeout} seconds.\")\n        except httpx.RequestError as e:\n            logger.error(f\"HTTP request error: {e}\")\n            raise KiteApiException(500, \"NetworkError\", f\"An error occurred during the request: {e}\")\n        except KiteApiException: # Re-raise specific API errors\n            raise\n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during the API request: {e}\")\n            raise KiteApiException(500, \"InternalClientError\", f\"An unexpected client error occurred: {e}\")\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, str]:\n        \"\"\"Places an order using the Kite Connect API.\n\n        Args:\n            params: PlaceOrderParams containing order details.\n\n        Returns:\n            A dictionary containing the 'order_id'.\n\n        Raises:\n            KiteApiException: If the API returns an error.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Prepare form data, excluding None values and the path parameter 'variety'\n        form_data = {\n            k: v for k, v in params.dict().items()\n            if k != 'variety' and v is not None\n        }\n        logger.info(f\"Placing order: endpoint={endpoint}, data={form_data}\")\n        response_data = await self._request(\"POST\", endpoint, data=form_data)\n\n        if \"order_id\" not in response_data:\n             logger.error(f\"'order_id' not found in response: {response_data}\")\n             raise KiteApiException(500, \"MalformedResponse\", f\"'order_id' missing from successful place order response: {response_data}\")\n\n        return {\"order_id\": str(response_data[\"order_id\"]) # Ensure it's a string\n}\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, str]:\n        \"\"\"Modifies a pending order using the Kite Connect API.\n\n        Args:\n            params: ModifyOrderParams containing modification details.\n\n        Returns:\n            A dictionary containing the 'order_id'.\n\n        Raises:\n            KiteApiException: If the API returns an error.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Prepare form data, excluding None values and path parameters\n        form_data = {\n            k: v for k, v in params.dict().items()\n            if k not in ['variety', 'order_id'] and v is not None\n        }\n        logger.info(f\"Modifying order: endpoint={endpoint}, data={form_data}\")\n        response_data = await self._request(\"PUT\", endpoint, data=form_data)\n\n        if \"order_id\" not in response_data:\n             logger.error(f\"'order_id' not found in response: {response_data}\")\n             raise KiteApiException(500, \"MalformedResponse\", f\"'order_id' missing from successful modify order response: {response_data}\")\n\n        return {\"order_id\": str(response_data[\"order_id\"]) # Ensure it's a string\n}\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=2.0.0,<3.0.0\nhttpx>=0.25.0,<0.28.0\npython-dotenv>=1.0.0\nuvicorn>=0.20.0 # For running FastMCP\n"
    },
    {
      "name": ".env.example",
      "content": "# Zerodha Kite Connect API Credentials\n# Obtain these from your Kite Developer account: https://developers.kite.trade/\nKITE_API_KEY=\"YOUR_API_KEY\"\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\" # This is short-lived and needs to be generated regularly\n\n# Optional: Base URL for the Kite Connect API (defaults to production)\n# KITE_BASE_URL=\"https://api.kite.trade\"\n\n# Optional: MCP Server Host and Port (defaults used by FastMCP if not set)\n# MCP_HOST=\"127.0.0.1\"\n# MCP_PORT=8000\n"
    },
    {
      "name": "README.md",
      "content": "# Zerodha Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server built with FastMCP to interact with the Zerodha Kite Connect v3 API, specifically for managing trading orders.\n\nIt allows language models or other applications to place and modify orders through a standardized MCP interface.\n\n## Features\n\n*   Place various types of orders (regular, AMO, CO, Iceberg, Auction).\n*   Modify pending orders.\n*   Asynchronous API interaction using `httpx`.\n*   Input validation using Pydantic models.\n*   Environment variable-based configuration.\n*   Structured logging.\n*   Basic Kite API error handling.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Zerodha Kite Connect API credentials:\n        *   `KITE_API_KEY`: Your Kite application's API key.\n        *   `KITE_ACCESS_TOKEN`: A valid access token obtained through the Kite Connect login flow. **Note:** Access tokens are short-lived and need to be regenerated periodically.\n        *   `KITE_BASE_URL` (Optional): Defaults to `https://api.kite.trade`.\n\n## Running the Server\n\nStart the MCP server using Uvicorn (which is included via FastMCP's run command):\n\n```bash\npython main.py\n```\n\nBy default, the server will run on `http://127.0.0.1:8000` (or the host/port specified by `MCP_HOST`/`MCP_PORT` environment variables if set).\n\nYou can access the auto-generated OpenAPI documentation at `http://127.0.0.1:8000/docs`.\n\n## Available Tools\n\nThe MCP server exposes the following tools:\n\n1.  **`place_order`**\n    *   **Description:** Places an order of a specified variety.\n    *   **Parameters:** See the `PlaceOrderParams` model in `models.py` for detailed arguments and descriptions (e.g., `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, `validity`, `price`, `trigger_price`, etc.).\n    *   **Returns:** `Dict[str, str]` containing the `order_id` on success.\n\n2.  **`modify_order`**\n    *   **Description:** Modifies attributes of a pending regular or cover order.\n    *   **Parameters:** See the `ModifyOrderParams` model in `models.py` (e.g., `variety`, `order_id`, `parent_order_id`, `order_type`, `quantity`, `price`, `trigger_price`, `validity`, etc.).\n    *   **Returns:** `Dict[str, str]` containing the `order_id` on success.\n\n## Error Handling\n\n*   The API client (`client.py`) attempts to parse errors returned by the Kite Connect API and raises a `KiteApiException` with details (status code, error type, message).\n*   Network errors (timeouts, connection issues) during the API call also raise `KiteApiException`.\n*   Input validation errors (e.g., missing required fields, invalid values) are handled by Pydantic within the models (`models.py`) and will result in errors before the API call is made.\n*   Unexpected server-side errors will raise standard Python exceptions.\n*   MCP tools propagate `KiteApiException` directly, allowing clients to potentially handle specific API errors. Other exceptions are caught and re-raised as generic `RuntimeError`.\n\n## Rate Limits\n\nThe Zerodha Kite Connect API has rate limits (typically around 10 requests per second for order operations, but check the official documentation for current limits).\n\nThis implementation **does not** include built-in client-side rate limiting. If you anticipate high request volumes, you may need to add rate limiting logic (e.g., using libraries like `aiolimiter`) either within the MCP tools or in the application calling the MCP server.\n\n## Authentication\n\nAuthentication is handled via the `KITE_API_KEY` and `KITE_ACCESS_TOKEN` provided in the environment variables. Ensure the access token is valid and refreshed as needed.\n\n## Disclaimer\n\nTrading involves substantial risk. This code is provided as-is, without warranty. Ensure thorough testing in a simulated environment before using with real funds. The authors are not responsible for any financial losses incurred.\n"
    }
  ]
}
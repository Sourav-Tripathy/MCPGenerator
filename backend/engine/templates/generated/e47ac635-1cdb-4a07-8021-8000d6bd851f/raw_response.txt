{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom models import PlaceOrderParams, ModifyOrderParams, OrderResponse, ErrorResponse\nfrom client import KiteConnectClient, KiteConnectError\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"kite_connect_orders\",\n    description=\"MCP server for managing trading orders via the Kite Connect v3 API. Allows placing, modifying, cancelling, and retrieving orders and trades.\"\n)\n\n# Initialize Kite Connect Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n    # Optionally raise an error or exit\n    # raise ValueError(\"API Key and Access Token are required.\")\n    # For now, we allow it to proceed but the client init will likely fail or requests will be unauthorized\n\nkite_client = KiteConnectClient(api_key=api_key, access_token=access_token, base_url=base_url)\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\n\n    Args:\n        params: Parameters for placing the order.\n\n    Returns:\n        A dictionary containing the 'order_id' if successful, or an error dictionary.\n    \"\"\"\n    logger.info(f\"Received request to place order: {params.dict(exclude_none=True)}\")\n    try:\n        response_data = await kite_client.place_order_async(params)\n        # Assuming the response structure contains {'data': {'order_id': '...'}}\n        if isinstance(response_data, dict) and 'data' in response_data and 'order_id' in response_data['data']:\n            order_id = response_data['data']['order_id']\n            logger.info(f\"Successfully placed order {order_id}\")\n            return OrderResponse(order_id=order_id).dict()\n        else:\n            logger.warning(f\"Place order call succeeded but response format unexpected: {response_data}\")\n            # Return the raw response if format is not as expected but request didn't fail\n            return {\"status\": \"success\", \"data\": response_data}\n\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error placing order: {e.code} - {e.message}\", exc_info=True)\n        return ErrorResponse(error_type=e.error_type, message=e.message, code=e.code).dict()\n    except Exception as e:\n        logger.error(f\"Unexpected error placing order: {str(e)}\", exc_info=True)\n        return ErrorResponse(error_type=\"ServerError\", message=str(e), code=500).dict()\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modify an open or pending order.\n\n    Args:\n        params: Parameters for modifying the order.\n\n    Returns:\n        A dictionary containing the 'order_id' if successful, or an error dictionary.\n    \"\"\"\n    logger.info(f\"Received request to modify order {params.order_id}: {params.dict(exclude={'order_id', 'variety'}, exclude_none=True)}\")\n    try:\n        response_data = await kite_client.modify_order_async(params)\n        # Assuming the response structure contains {'data': {'order_id': '...'}}\n        if isinstance(response_data, dict) and 'data' in response_data and 'order_id' in response_data['data']:\n            order_id = response_data['data']['order_id']\n            logger.info(f\"Successfully modified order {order_id}\")\n            return OrderResponse(order_id=order_id).dict()\n        else:\n            logger.warning(f\"Modify order call succeeded but response format unexpected: {response_data}\")\n            # Return the raw response if format is not as expected but request didn't fail\n            return {\"status\": \"success\", \"data\": response_data}\n\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error modifying order {params.order_id}: {e.code} - {e.message}\", exc_info=True)\n        return ErrorResponse(error_type=e.error_type, message=e.message, code=e.code).dict()\n    except Exception as e:\n        logger.error(f\"Unexpected error modifying order {params.order_id}: {str(e)}\", exc_info=True)\n        return ErrorResponse(error_type=\"ServerError\", message=str(e), code=500).dict()\n\nif __name__ == \"__main__\":\n    logger.info(\"Starting Kite Connect Orders MCP Server...\")\n    mcp.run()\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field, validator\nfrom typing import Optional, Dict\nfrom typing_extensions import Literal\n\n# Define Literal types for parameters\nVarietyType = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nExchangeType = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety type.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange.\")\n    transaction_type: TransactionType = Field(..., description=\"Transaction type.\")\n    order_type: OrderType = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: ProductType = Field(..., description=\"Product code.\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (SL, SL-M).\")\n    disclosed_quantity: Optional[int] = Field(None, gt=0, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity: ValidityType = Field(..., description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, gt=0, description=\"Order life span in minutes for TTL validity orders.\")\n    iceberg_legs: Optional[int] = Field(None, ge=2, le=10, description=\"Total number of legs for iceberg order type (2-10). Required if variety is 'iceberg'.\")\n    iceberg_quantity: Optional[int] = Field(None, gt=0, description=\"Split quantity for each iceberg leg order. Required if variety is 'iceberg'.\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction. Required if variety is 'auction'.\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"An optional tag to apply to an order (alphanumeric, max 20 chars).\")\n\n    @validator('price')\n    def price_required_for_limit(cls, v, values):\n        if values.get('order_type') == 'LIMIT' and v is None:\n            raise ValueError('Price is required for LIMIT orders')\n        if values.get('order_type') != 'LIMIT' and v is not None:\n             # Kite API might ignore it, but better to be explicit or raise error\n             # raise ValueError('Price is only applicable for LIMIT orders')\n             pass # Allow sending it, API might handle it\n        return v\n\n    @validator('trigger_price')\n    def trigger_price_required_for_sl(cls, v, values):\n        if values.get('order_type') in ['SL', 'SL-M'] and v is None:\n            raise ValueError('Trigger price is required for SL/SL-M orders')\n        if values.get('order_type') not in ['SL', 'SL-M'] and v is not None:\n            # raise ValueError('Trigger price is only applicable for SL/SL-M orders')\n            pass # Allow sending it\n        return v\n\n    @validator('validity_ttl')\n    def validity_ttl_required(cls, v, values):\n        if values.get('validity') == 'TTL' and v is None:\n            raise ValueError('validity_ttl is required for TTL validity')\n        if values.get('validity') != 'TTL' and v is not None:\n            raise ValueError('validity_ttl is only applicable for TTL validity')\n        return v\n\n    @validator('iceberg_legs')\n    def iceberg_legs_required(cls, v, values):\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError('iceberg_legs is required for iceberg variety')\n        if values.get('variety') != 'iceberg' and v is not None:\n            raise ValueError('iceberg_legs is only applicable for iceberg variety')\n        return v\n\n    @validator('iceberg_quantity')\n    def iceberg_quantity_required(cls, v, values):\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError('iceberg_quantity is required for iceberg variety')\n        if values.get('variety') != 'iceberg' and v is not None:\n            raise ValueError('iceberg_quantity is only applicable for iceberg variety')\n        # Add validation: iceberg_quantity should be less than total quantity\n        if v is not None and values.get('quantity') is not None and v >= values['quantity']:\n             raise ValueError('iceberg_quantity must be less than total quantity')\n        return v\n\n    @validator('auction_number')\n    def auction_number_required(cls, v, values):\n        if values.get('variety') == 'auction' and v is None:\n            raise ValueError('auction_number is required for auction variety')\n        if values.get('variety') != 'auction' and v is not None:\n            raise ValueError('auction_number is only applicable for auction variety')\n        return v\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Parameters for modifying an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety type.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    order_type: Optional[OrderType] = Field(None, description=\"New order type.\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity.\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M orders).\")\n    disclosed_quantity: Optional[int] = Field(None, gt=0, description=\"New disclosed quantity.\")\n    validity: Optional[ValidityType] = Field(None, description=\"New validity.\")\n\n    @validator('price')\n    def price_check_for_limit(cls, v, values):\n        # Price is only relevant if changing to or modifying a LIMIT order\n        # Actual validation depends on the original order and the new order_type if provided\n        # Keeping it simple here, Kite API will perform the final validation\n        return v\n\n    @validator('trigger_price')\n    def trigger_price_check_for_sl(cls, v, values):\n        # Trigger price is only relevant if changing to or modifying an SL/SL-M order\n        return v\n\nclass OrderResponse(BaseModel):\n    \"\"\"Standard success response containing the order ID.\"\"\"\n    order_id: str = Field(..., description=\"The unique identifier for the order.\")\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response.\"\"\"\n    error_type: str = Field(..., description=\"Type of error.\")\n    message: str = Field(..., description=\"Detailed error message.\")\n    code: int = Field(..., description=\"HTTP status code or custom error code.\")\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nfrom typing import Dict, Any, Optional\nfrom models import PlaceOrderParams, ModifyOrderParams\n\nlogger = logging.getLogger(__name__)\n\n# Define custom exceptions for Kite Connect specific errors\nclass KiteConnectError(Exception):\n    \"\"\"Base exception class for Kite Connect client errors.\"\"\"\n    def __init__(self, message=\"An error occurred with the Kite Connect API\", code=500, error_type=\"APIError\"):\n        self.message = message\n        self.code = code\n        self.error_type = error_type\n        super().__init__(f\"[{error_type}/{code}] {message}\")\n\nclass AuthenticationError(KiteConnectError):\n    \"\"\"Raised for authentication failures (403 Forbidden).\"\"\"\n    def __init__(self, message=\"Authentication failed\", error_type=\"TokenException\"):\n        super().__init__(message, code=403, error_type=error_type)\n\nclass NetworkError(KiteConnectError):\n    \"\"\"Raised for network-related issues.\"\"\"\n    def __init__(self, message=\"Network error connecting to Kite API\"):\n        super().__init__(message, code=503, error_type=\"NetworkException\")\n\nclass TimeoutError(KiteConnectError):\n    \"\"\"Raised for request timeouts.\"\"\"\n    def __init__(self, message=\"Request timed out\"):\n        super().__init__(message, code=504, error_type=\"TimeoutException\")\n\nclass OrderRejectionError(KiteConnectError):\n    \"\"\"Raised for specific order rejections (e.g., insufficient funds, validation).\"\"\"\n    pass # Uses code/message/type from API response\n\nclass InputValidationError(KiteConnectError):\n     \"\"\"Raised for client-side or API-side input validation errors.\"\"\"\n     pass # Uses code/message/type from API response\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect v3 API.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        \"\"\"Initialize the Kite Connect client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after successful login.\n            base_url: The base URL for the Kite Connect API.\n            timeout: Default request timeout in seconds.\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.timeout = timeout\n        self.headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form data\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=self.timeout\n        )\n        # Note: Rate limiting (10 req/sec) is not actively enforced by this client.\n        # Consider using a library like 'asyncio-throttle' or 'limits' for robust rate limiting.\n        logger.info(f\"KiteConnectClient initialized for base URL: {self.base_url}\")\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite Connect API.\n\n        Args:\n            method: HTTP method (e.g., 'POST', 'PUT', 'GET', 'DELETE').\n            endpoint: API endpoint path (e.g., '/orders/regular').\n            data: Dictionary of form data for the request body (optional).\n\n        Returns:\n            The parsed JSON response from the API.\n\n        Raises:\n            AuthenticationError: If the API returns a 403 status.\n            InputValidationError: If the API returns a 400 status.\n            OrderRejectionError: For specific order-related errors (often 400).\n            NetworkError: For connection errors.\n            TimeoutError: If the request times out.\n            KiteConnectError: For other API errors or unexpected statuses.\n        \"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Sending {method} request to {url} with data: {data}\")\n        try:\n            response = await self.client.request(method, endpoint, data=data)\n            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx\n            logger.debug(f\"Received successful response ({response.status_code}) from {url}\")\n            return response.json()\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timeout for {method} {url}: {e}\")\n            raise TimeoutError(f\"Request timed out: {method} {url}\") from e\n        except httpx.NetworkError as e:\n            logger.error(f\"Network error for {method} {url}: {e}\")\n            raise NetworkError(f\"Network error connecting to Kite API: {e}\") from e\n        except httpx.HTTPStatusError as e:\n            status_code = e.response.status_code\n            try:\n                # Try to parse the error response body from Kite\n                error_data = e.response.json()\n                message = error_data.get(\"message\", \"Unknown API error\")\n                error_type = error_data.get(\"error_type\", \"APIException\")\n                logger.error(f\"Kite API error ({status_code}) for {method} {url}: {error_type} - {message}\")\n\n                if status_code == 403:\n                    raise AuthenticationError(message, error_type=error_type) from e\n                elif status_code == 400:\n                    # Distinguish between general validation and order rejection if possible\n                    if \"order\" in message.lower() or \"margin\" in message.lower() or \"funds\" in message.lower():\n                         raise OrderRejectionError(message, code=status_code, error_type=error_type) from e\n                    else:\n                         raise InputValidationError(message, code=status_code, error_type=error_type) from e\n                else:\n                    # General KiteConnectError for other 4xx/5xx\n                    raise KiteConnectError(message, code=status_code, error_type=error_type) from e\n            except Exception as parse_exc:\n                # Fallback if response body is not JSON or parsing fails\n                logger.error(f\"HTTP error ({status_code}) for {method} {url} with non-JSON or unparseable body: {e.response.text}\", exc_info=parse_exc)\n                if status_code == 403:\n                    raise AuthenticationError(f\"Authentication failed (status {status_code})\") from e\n                else:\n                    raise KiteConnectError(f\"HTTP error {status_code}: {e.response.text}\", code=status_code) from e\n        except Exception as e:\n            logger.error(f\"Unexpected error during request to {method} {url}: {e}\", exc_info=True)\n            raise KiteConnectError(f\"An unexpected error occurred: {e}\") from e\n\n    async def place_order_async(self, params: PlaceOrderParams) -> Dict[str, Any]:\n        \"\"\"Place an order asynchronously.\n\n        Args:\n            params: PlaceOrderParams object containing order details.\n\n        Returns:\n            Dictionary containing the API response (typically includes 'order_id').\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Convert Pydantic model to dict, excluding None values\n        data = params.dict(exclude={'variety'}, exclude_none=True)\n        # Ensure integer fields are sent as integers, float as floats\n        for key, value in data.items():\n            if isinstance(value, float):\n                data[key] = str(value) # Kite API expects numbers as strings in form data sometimes\n            elif isinstance(value, int):\n                data[key] = str(value)\n\n        logger.info(f\"Placing {params.variety} order: {data}\")\n        return await self._request(\"POST\", endpoint, data=data)\n\n    async def modify_order_async(self, params: ModifyOrderParams) -> Dict[str, Any]:\n        \"\"\"Modify an existing order asynchronously.\n\n        Args:\n            params: ModifyOrderParams object containing modification details.\n\n        Returns:\n            Dictionary containing the API response (typically includes 'order_id').\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Convert Pydantic model to dict, excluding None values and path params\n        data = params.dict(exclude={'variety', 'order_id'}, exclude_none=True)\n        # Ensure numeric fields are sent correctly\n        for key, value in data.items():\n             if isinstance(value, float):\n                 data[key] = str(value)\n             elif isinstance(value, int):\n                 data[key] = str(value)\n\n        logger.info(f\"Modifying {params.variety} order {params.order_id}: {data}\")\n        return await self._request(\"PUT\", endpoint, data=data)\n\n    async def close(self):\n        \"\"\"Close the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.2.0,<0.3.0\npydantic>=1.9.0,<2.0.0\nhttpx>=0.23.0,<0.28.0\npython-dotenv>=0.19.0,<1.1.0\ntyping-extensions>=4.0.0 # For Literal support in older Python versions\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer Console (https://developers.kite.trade/)\n\n# Your Kite Connect API Key\nKITE_API_KEY=\"your_api_key\"\n\n# The access token obtained after a successful user login flow\n# This token is typically short-lived (valid for one day)\n# You might need a separate mechanism to refresh or obtain this token daily\nKITE_ACCESS_TOKEN=\"your_access_token\"\n\n# Base URL for the Kite Connect API (optional, defaults to https://api.kite.trade)\n# KITE_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the order placement and modification endpoints of the Zerodha Kite Connect v3 API. It allows language models or other applications to manage trading orders through a standardized interface.\n\nBuilt using [FastMCP](https://github.com/your-repo/fastmcp). <!-- Replace with actual FastMCP link if available -->\n\n## Features\n\n*   Place various types of orders (regular, AMO, CO, Iceberg, Auction).\n*   Modify existing pending orders.\n*   Uses Pydantic for robust request validation.\n*   Asynchronous API client built with `httpx`.\n*   Handles common Kite Connect API errors.\n*   Configurable via environment variables.\n\n## Prerequisites\n\n*   Python 3.8+\n*   A Zerodha Kite Connect API key and secret.\n*   A valid `access_token` obtained through the Kite Connect login flow. **Note:** Access tokens are typically valid for only one day. You will need a mechanism to generate/refresh this token daily and update the environment variable or `.env` file.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <your-repo-url>\n    cd kite-connect-mcp\n    ```\n\n2.  **Create a virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    Create a `.env` file in the project root directory by copying the example file:\n    ```bash\n    cp .env.example .env\n    ```\n    Edit the `.env` file and add your Kite Connect API key and a valid access token:\n    ```dotenv\n    # .env\n    KITE_API_KEY=\"your_api_key\"\n    KITE_ACCESS_TOKEN=\"your_valid_access_token\"\n    # KITE_BASE_URL=\"https://api.kite.trade\" # Optional: uncomment to override default\n    ```\n    **Security Note:** Treat your API key, secret, and access token as sensitive credentials. Do not commit them directly into your version control system.\n\n## Running the Server\n\nStart the MCP server using:\n\n```bash\npython main.py\n```\n\nThe server will start, typically listening on `http://127.0.0.1:8000` (or as configured by FastMCP).\n\n## Available Tools\n\nThe MCP server exposes the following tools:\n\n### 1. `place_order`\n\nPlaces a new trading order.\n\n*   **Description:** Place an order of a particular variety (regular, amo, co, iceberg, auction).\n*   **Input Model:** `PlaceOrderParams` (see `models.py` for details)\n    *   `variety`: 'regular', 'amo', 'co', 'iceberg', 'auction'\n    *   `tradingsymbol`: e.g., \"INFY\", \"NIFTY23JUL18000CE\"\n    *   `exchange`: 'NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'\n    *   `transaction_type`: 'BUY', 'SELL'\n    *   `order_type`: 'MARKET', 'LIMIT', 'SL', 'SL-M'\n    *   `quantity`: Positive integer\n    *   `product`: 'CNC', 'NRML', 'MIS', 'MTF'\n    *   `price`: Float (Required for LIMIT orders)\n    *   `trigger_price`: Float (Required for SL, SL-M orders)\n    *   `disclosed_quantity`: Optional positive integer\n    *   `validity`: 'DAY', 'IOC', 'TTL'\n    *   `validity_ttl`: Optional positive integer (Required for TTL validity)\n    *   `iceberg_legs`: Optional integer (2-10, Required for 'iceberg' variety)\n    *   `iceberg_quantity`: Optional positive integer (Required for 'iceberg' variety)\n    *   `auction_number`: Optional string (Required for 'auction' variety)\n    *   `tag`: Optional string (max 20 chars)\n*   **Returns:** `Dict[str, str]` containing `{\"order_id\": \"<the_new_order_id>\"}` on success, or an `ErrorResponse` dictionary on failure.\n\n### 2. `modify_order`\n\nModifies an existing pending order.\n\n*   **Description:** Modify an open or pending regular order.\n*   **Input Model:** `ModifyOrderParams` (see `models.py` for details)\n    *   `variety`: 'regular', 'co', 'amo', 'iceberg', 'auction' (Must match the original order's variety)\n    *   `order_id`: The ID of the order to modify.\n    *   `order_type`: Optional new order type ('MARKET', 'LIMIT', 'SL', 'SL-M')\n    *   `quantity`: Optional new positive integer quantity.\n    *   `price`: Optional new float price (for LIMIT orders).\n    *   `trigger_price`: Optional new float trigger price (for SL, SL-M orders).\n    *   `disclosed_quantity`: Optional new positive integer disclosed quantity.\n    *   `validity`: Optional new validity ('DAY', 'IOC', 'TTL').\n*   **Returns:** `Dict[str, str]` containing `{\"order_id\": \"<the_modified_order_id>\"}` on success, or an `ErrorResponse` dictionary on failure.\n\n## Error Handling\n\nThe API client (`client.py`) attempts to catch common errors:\n\n*   `AuthenticationError`: Invalid API key or access token (HTTP 403).\n*   `InputValidationError`: Invalid parameters sent to the API (HTTP 400).\n*   `OrderRejectionError`: Order rejected due to margins, validation rules, etc. (often HTTP 400).\n*   `NetworkError`: Could not connect to the Kite API.\n*   `TimeoutError`: Request timed out.\n*   `KiteConnectError`: Other generic API errors.\n\nThe MCP tools return an `ErrorResponse` dictionary in case of failure, containing `error_type`, `message`, and `code`.\n\n## Rate Limiting\n\nThe Kite Connect API has rate limits (typically 10 requests per second). This client implementation *does not* actively enforce rate limiting. For high-throughput applications, consider adding a rate-limiting library like `asyncio-throttle` or `limits`.\n"
    }
  ]
}
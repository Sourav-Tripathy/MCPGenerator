{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams, OrderResponse\nfrom client import KiteConnectClient, KiteApiException\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"kite_connect_orders\",\n    description=\"Provides tools to interact with the Kite Connect Orders API, allowing users to place, modify, cancel, and retrieve order and trade information.\"\n)\n\n# Initialize Kite Connect Client\n# Ensure KITE_API_KEY and KITE_ACCESS_TOKEN are set in your environment or .env file\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables or .env file.\")\n    # Optionally raise an exception or exit if credentials are required at startup\n    # raise ValueError(\"API Key and Access Token not configured\")\n    # For now, we allow it to proceed, but client calls will fail.\n    kite_client = None\nelse:\n    try:\n        kite_client = KiteConnectClient(api_key=api_key, access_token=access_token)\n    except Exception as e:\n        logger.exception(\"Failed to initialize KiteConnectClient\")\n        kite_client = None\n\ndef handle_api_error(tool_name: str, error: Exception) -> Dict[str, Any]:\n    \"\"\"Centralized error handler for API calls.\"\"\"\n    logger.error(f\"Error in {tool_name}: {error}\", exc_info=True)\n    if isinstance(error, KiteApiException):\n        return {\"error\": error.message, \"code\": error.code, \"status\": \"error\"}\n    else:\n        # General exception\n        return {\"error\": f\"An unexpected error occurred: {str(error)}\", \"status\": \"error\"}\n\n@mcp.tool()\ndef place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Places an order of a specific variety (regular, amo, co, iceberg, auction).\n\n    Args:\n        params: Order placement parameters including variety, tradingsymbol, exchange, etc.\n\n    Returns:\n        A dictionary containing the 'order_id' of the placed order or an error message.\n    \"\"\"\n    if not kite_client:\n        return {\"error\": \"Kite Connect client not initialized. Check API Key/Access Token.\", \"status\": \"error\"}\n\n    logger.info(f\"Placing order with params: {params.dict(exclude_none=True)}\")\n    try:\n        response_data = await kite_client.place_order(params)\n        logger.info(f\"Order placed successfully: {response_data}\")\n        # Ensure the response matches the expected structure\n        if isinstance(response_data, dict) and \"order_id\" in response_data:\n             return OrderResponse(order_id=response_data[\"order_id\"]).dict()\n        else:\n             logger.error(f\"Unexpected response format from place_order: {response_data}\")\n             return {\"error\": \"Unexpected response format from API\", \"details\": response_data, \"status\": \"error\"}\n\n    except Exception as e:\n        return handle_api_error(\"place_order\", e)\n\n@mcp.tool()\ndef modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Modifies attributes of a pending regular or CO order.\n\n    Args:\n        params: Order modification parameters including variety, order_id, and fields to modify.\n\n    Returns:\n        A dictionary containing the 'order_id' of the modified order or an error message.\n    \"\"\"\n    if not kite_client:\n        return {\"error\": \"Kite Connect client not initialized. Check API Key/Access Token.\", \"status\": \"error\"}\n\n    logger.info(f\"Modifying order with params: {params.dict(exclude_none=True)}\")\n    try:\n        response_data = await kite_client.modify_order(params)\n        logger.info(f\"Order modified successfully: {response_data}\")\n        # Ensure the response matches the expected structure\n        if isinstance(response_data, dict) and \"order_id\" in response_data:\n            return OrderResponse(order_id=response_data[\"order_id\"]).dict()\n        else:\n            logger.error(f\"Unexpected response format from modify_order: {response_data}\")\n            return {\"error\": \"Unexpected response format from API\", \"details\": response_data, \"status\": \"error\"}\n\n    except Exception as e:\n        return handle_api_error(\"modify_order\", e)\n\n@mcp.tool()\ndef cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Cancels a pending order.\n\n    Args:\n        params: Order cancellation parameters including variety and order_id.\n\n    Returns:\n        A dictionary containing the 'order_id' of the cancelled order or an error message.\n    \"\"\"\n    if not kite_client:\n        return {\"error\": \"Kite Connect client not initialized. Check API Key/Access Token.\", \"status\": \"error\"}\n\n    logger.info(f\"Cancelling order with params: {params.dict()}\")\n    try:\n        response_data = await kite_client.cancel_order(params)\n        logger.info(f\"Order cancelled successfully: {response_data}\")\n        # Ensure the response matches the expected structure\n        if isinstance(response_data, dict) and \"order_id\" in response_data:\n            return OrderResponse(order_id=response_data[\"order_id\"]).dict()\n        else:\n            logger.error(f\"Unexpected response format from cancel_order: {response_data}\")\n            return {\"error\": \"Unexpected response format from API\", \"details\": response_data, \"status\": \"error\"}\n\n    except Exception as e:\n        return handle_api_error(\"cancel_order\", e)\n\nif __name__ == \"__main__\":\n    # For local development, using uvicorn directly\n    import uvicorn\n    logger.info(\"Starting Kite Connect Orders MCP server...\")\n    # Make sure the app is referenced correctly, e.g., main:mcp.app for uvicorn command line\n    # When running directly like this, it might need adjustment based on FastMCP internals\n    # Typically, you'd run: uvicorn main:mcp.app --reload\n    # This block is mostly for illustrative purposes if running the script directly.\n    # uvicorn.run(mcp.app, host=\"0.0.0.0\", port=8000)\n    print(\"MCP Server defined. Run with: uvicorn main:mcp.app --reload\")\n    print(\"Ensure KITE_API_KEY and KITE_ACCESS_TOKEN are set in your environment or .env file.\")\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field, validator\nfrom typing import Optional, Literal, Dict\n\n# Define Literal types for common parameters\nVarietyType = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nExchangeType = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\nModifyVarietyType = Literal['regular', 'co']\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange.\")\n    transaction_type: TransactionType = Field(..., description=\"Transaction type.\")\n    order_type: OrderType = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: ProductType = Field(..., description=\"Product code.\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders.\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity: ValidityType = Field(..., description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10). Required if variety is 'iceberg'.\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order. Required if variety is 'iceberg'.\")\n    auction_number: Optional[str] = Field(None, description=\"Unique identifier for a particular auction. Required if variety is 'auction'.\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"Optional tag for the order (alphanumeric, max 20 chars).\")\n\n    @validator('price')\n    def price_required_for_limit(cls, v, values):\n        if values.get('order_type') == 'LIMIT' and v is None:\n            raise ValueError('Price is required for LIMIT orders')\n        if values.get('order_type') != 'LIMIT' and v is not None:\n             # Kite API might ignore it, but good practice to warn or clear\n             # print(\"Warning: Price is only applicable for LIMIT orders.\")\n             return None # Or return v if API handles it\n        return v\n\n    @validator('trigger_price')\n    def trigger_price_required_for_sl(cls, v, values):\n        if values.get('order_type') in ['SL', 'SL-M'] and v is None:\n            raise ValueError('Trigger price is required for SL and SL-M orders')\n        if values.get('order_type') not in ['SL', 'SL-M'] and v is not None:\n            # print(\"Warning: Trigger price is only applicable for SL/SL-M orders.\")\n            return None # Or return v\n        return v\n\n    @validator('validity_ttl')\n    def validity_ttl_required(cls, v, values):\n        if values.get('validity') == 'TTL' and v is None:\n            raise ValueError('validity_ttl is required when validity is TTL')\n        if values.get('validity') != 'TTL' and v is not None:\n            return None\n        return v\n\n    @validator('iceberg_legs')\n    def iceberg_legs_required(cls, v, values):\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError('iceberg_legs is required when variety is iceberg')\n        if values.get('variety') != 'iceberg' and v is not None:\n            return None\n        if v is not None and not (2 <= v <= 10):\n             raise ValueError('iceberg_legs must be between 2 and 10')\n        return v\n\n    @validator('iceberg_quantity')\n    def iceberg_quantity_required(cls, v, values):\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError('iceberg_quantity is required when variety is iceberg')\n        if values.get('variety') != 'iceberg' and v is not None:\n            return None\n        # Add validation for iceberg_quantity relative to total quantity if needed\n        # if v is not None and values.get('quantity') is not None and values.get('iceberg_legs') is not None:\n        #     if v * values['iceberg_legs'] < values['quantity']:\n        #         raise ValueError('iceberg_quantity * iceberg_legs must be >= total quantity')\n        return v\n\n    @validator('auction_number')\n    def auction_number_required(cls, v, values):\n        if values.get('variety') == 'auction' and v is None:\n            raise ValueError('auction_number is required when variety is auction')\n        if values.get('variety') != 'auction' and v is not None:\n            return None\n        return v\n\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Parameters for modifying a pending order.\"\"\"\n    variety: ModifyVarietyType = Field(..., description=\"Order variety. Currently supports 'regular' and 'co'.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    # Fields below are optional for modification\n    order_type: Optional[OrderType] = Field(None, description=\"New order type (Regular only).\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity (Regular only).\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders, Regular/CO).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, CO orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (Regular only). Not applicable for CO.\")\n    validity: Optional[ValidityType] = Field(None, description=\"New validity (Regular only). Not applicable for CO.\")\n\n    @validator('order_type', 'quantity', 'disclosed_quantity', 'validity')\n    def regular_only_fields(cls, v, field, values):\n        if values.get('variety') == 'co' and v is not None:\n            raise ValueError(f\"{field.name} cannot be modified for CO orders.\")\n        return v\n\n    @validator('price')\n    def modify_price_check(cls, v, values):\n        # Price can be modified for LIMIT orders (Regular/CO)\n        # If changing to LIMIT, price might become required (handled by API or needs more complex validation)\n        return v\n\n    @validator('trigger_price')\n    def modify_trigger_price_check(cls, v, values):\n        # Trigger price can be modified for SL, SL-M (Regular) and CO orders\n        return v\n\nclass CancelOrderParams(BaseModel):\n    \"\"\"Parameters for cancelling an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"Order variety.\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel.\")\n\nclass OrderResponse(BaseModel):\n    \"\"\"Standard response format for successful order operations.\"\"\"\n    order_id: str = Field(..., description=\"The unique order ID.\")\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nimport os\nimport asyncio\nfrom typing import Dict, Any, Optional\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams\n\nlogger = logging.getLogger(__name__)\n\n# Define Kite Connect API specific exceptions\nclass KiteApiException(Exception):\n    \"\"\"Custom exception for Kite Connect API errors.\"\"\"\n    def __init__(self, message, code=None, status_code=None):\n        self.message = message\n        self.code = code  # Kite specific error code (if available)\n        self.status_code = status_code # HTTP status code\n        super().__init__(self.message)\n\n    def __str__(self):\n        return f\"KiteApiException: {self.message} (Code: {self.code}, HTTP Status: {self.status_code})\"\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect Orders API.\"\"\"\n\n    DEFAULT_BASE_URL = \"https://api.kite.trade\"\n    KITE_API_VERSION = \"3\" # Specify the Kite API version\n    # Basic rate limiting: delay between requests (in seconds)\n    # A more robust solution would use token buckets or similar.\n    REQUEST_DELAY = 0.1 # Corresponds to ~10 requests/sec limit\n\n    def __init__(self, api_key: str, access_token: str, base_url: Optional[str] = None, timeout: float = 30.0):\n        \"\"\"\n        Initializes the Kite Connect client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after login.\n            base_url: The base URL for the Kite API. Defaults to production URL.\n            timeout: Default request timeout in seconds.\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url or self.DEFAULT_BASE_URL\n        self.timeout = timeout\n\n        self.headers = {\n            \"X-Kite-Version\": self.KITE_API_VERSION,\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            # Kite API expects form-encoded data, not JSON\n            # 'Content-Type': 'application/x-www-form-urlencoded' # httpx sets this automatically for `data=`\n        }\n\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=self.timeout\n        )\n\n        self._last_request_time = 0\n\n    async def _rate_limit_delay(self):\n        \"\"\"Applies a simple delay to respect rate limits.\"\"\"\n        now = asyncio.get_event_loop().time()\n        elapsed = now - self._last_request_time\n        if elapsed < self.REQUEST_DELAY:\n            await asyncio.sleep(self.REQUEST_DELAY - elapsed)\n        self._last_request_time = asyncio.get_event_loop().time()\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"\n        Internal method to make API requests.\n\n        Args:\n            method: HTTP method (GET, POST, PUT, DELETE).\n            endpoint: API endpoint path (e.g., '/orders/regular').\n            data: Dictionary of data to send (will be form-encoded for POST/PUT).\n\n        Returns:\n            The JSON response data as a dictionary.\n\n        Raises:\n            KiteApiException: If the API returns an error or the request fails.\n        \"\"\"\n        await self._rate_limit_delay()\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Making request: {method} {url} Data: {data}\")\n\n        try:\n            response = await self.client.request(method, url, data=data)\n            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx\n            response_data = response.json()\n\n            # Kite API typically wraps successful responses in a 'data' field\n            if isinstance(response_data, dict) and 'status' in response_data:\n                if response_data['status'] == 'success':\n                    return response_data.get('data', {}) # Return the content within 'data'\n                elif response_data['status'] == 'error':\n                    error_message = response_data.get('message', 'Unknown API error')\n                    error_type = response_data.get('error_type', None) # e.g., InputException, TokenException\n                    logger.error(f\"Kite API Error: {error_message} (Type: {error_type})\")\n                    raise KiteApiException(message=error_message, code=error_type, status_code=response.status_code)\n                else:\n                    # Unexpected status value\n                    logger.error(f\"Unexpected status in Kite API response: {response_data.get('status')}\")\n                    raise KiteApiException(message=\"Unexpected status in API response\", status_code=response.status_code)\n            else:\n                # Handle cases where response might not follow the {status: ..., data: ...} structure\n                # This might happen for certain errors or unexpected responses.\n                logger.warning(f\"Unexpected API response format: {response_data}\")\n                # Attempt to return data if it looks valid, otherwise raise error\n                if isinstance(response_data, dict):\n                    return response_data # Assume it's the data if no status field\n                else:\n                    raise KiteApiException(message=\"Received non-dictionary response\", status_code=response.status_code)\n\n        except httpx.HTTPStatusError as e:\n            # Handle HTTP errors (4xx, 5xx)\n            try:\n                # Try to parse error details from response body\n                error_data = e.response.json()\n                message = error_data.get('message', f\"HTTP Error: {e.response.status_code}\")\n                code = error_data.get('error_type', None)\n            except Exception:\n                message = f\"HTTP Error: {e.response.status_code} - {e.response.text[:100]}\" # Truncate long responses\n                code = None\n            logger.error(f\"HTTP Error during API request to {e.request.url}: {message}\", exc_info=False)\n            raise KiteApiException(message=message, code=code, status_code=e.response.status_code) from e\n\n        except httpx.RequestError as e:\n            # Handle network errors, timeouts, etc.\n            logger.error(f\"Request failed for {e.request.url}: {e}\", exc_info=True)\n            raise KiteApiException(message=f\"Network request failed: {e}\", status_code=None) from e\n\n        except Exception as e:\n            # Catch any other unexpected errors during request/processing\n            logger.exception(f\"An unexpected error occurred during API request to {url}\")\n            raise KiteApiException(message=f\"An unexpected error occurred: {str(e)}\", status_code=None) from e\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, str]:\n        \"\"\"\n        Places an order.\n\n        Args:\n            params: PlaceOrderParams object containing order details.\n\n        Returns:\n            Dictionary containing the 'order_id'.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Convert Pydantic model to dict, excluding None values\n        payload = params.dict(exclude_none=True, exclude={'variety'}) # Variety is in the path\n        # Kite API expects integer quantities\n        if 'quantity' in payload: payload['quantity'] = int(payload['quantity'])\n        if 'disclosed_quantity' in payload: payload['disclosed_quantity'] = int(payload['disclosed_quantity'])\n        if 'iceberg_legs' in payload: payload['iceberg_legs'] = int(payload['iceberg_legs'])\n        if 'iceberg_quantity' in payload: payload['iceberg_quantity'] = int(payload['iceberg_quantity'])\n\n        # Convert float prices to strings if needed by API (check Kite docs, usually not needed for form data)\n        # if 'price' in payload: payload['price'] = str(payload['price'])\n        # if 'trigger_price' in payload: payload['trigger_price'] = str(payload['trigger_price'])\n\n        logger.info(f\"Placing order: POST {endpoint}, Payload: {payload}\")\n        return await self._request(\"POST\", endpoint, data=payload)\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, str]:\n        \"\"\"\n        Modifies a pending order.\n\n        Args:\n            params: ModifyOrderParams object containing modification details.\n\n        Returns:\n            Dictionary containing the 'order_id'.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        payload = params.dict(exclude_none=True, exclude={'variety', 'order_id'}) # Path params excluded\n\n        if 'quantity' in payload: payload['quantity'] = int(payload['quantity'])\n        if 'disclosed_quantity' in payload: payload['disclosed_quantity'] = int(payload['disclosed_quantity'])\n\n        logger.info(f\"Modifying order: PUT {endpoint}, Payload: {payload}\")\n        return await self._request(\"PUT\", endpoint, data=payload)\n\n    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, str]:\n        \"\"\"\n        Cancels a pending order.\n\n        Args:\n            params: CancelOrderParams object containing order details.\n\n        Returns:\n            Dictionary containing the 'order_id'.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # No payload needed for DELETE\n        logger.info(f\"Cancelling order: DELETE {endpoint}\")\n        return await self._request(\"DELETE\", endpoint)\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"Kite Connect client closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.2.0\npydantic>=1.9.0,<2.0.0\nhttpx>=0.23.0\npython-dotenv>=0.20.0\nuvicorn>=0.17.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Copy this file to .env and fill in your actual credentials.\n\n# Your Kite Connect application's API key\nKITE_API_KEY=\n\n# The access token obtained after a successful Kite Connect login flow\n# This token is typically short-lived and needs to be refreshed periodically.\nKITE_ACCESS_TOKEN=\n\n# (Optional) Base URL for the Kite Connect API\n# Defaults to https://api.kite.trade if not specified\n# KITE_API_BASE_URL=https://api.kite.trade\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect Orders MCP Server\n\nThis project provides an MCP (Model Context Protocol) server for interacting with the Kite Connect Orders API. It allows language models or other applications to place, modify, and cancel stock market orders using natural language or structured requests via the MCP interface.\n\n## Features\n\n*   **Place Orders:** Supports various order types (regular, AMO, CO, Iceberg, Auction).\n*   **Modify Orders:** Allows modification of pending regular and CO orders.\n*   **Cancel Orders:** Enables cancellation of pending orders.\n*   **Typed Inputs:** Uses Pydantic models for robust input validation.\n*   **Asynchronous:** Built with `asyncio` and `httpx` for non-blocking I/O.\n*   **Error Handling:** Provides informative error messages from the Kite API.\n\n## Setup\n\n1.  **Clone the Repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a Virtual Environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install Dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect `API KEY` and a valid `ACCESS TOKEN`.\n        ```dotenv\n        KITE_API_KEY=your_api_key\n        KITE_ACCESS_TOKEN=your_access_token\n        # KITE_API_BASE_URL=https://api.kite.trade # Optional override\n        ```\n    *   **Important:** The `ACCESS TOKEN` is obtained after a successful Kite Connect login flow (e.g., using the Python client library or manual login) and is typically short-lived.\nYou need a mechanism to refresh or provide a valid token.\n\n## Running the Server\n\nUse Uvicorn to run the FastMCP application:\n\n```bash\nuvicorn main:mcp.app --reload --host 0.0.0.0 --port 8000\n```\n\n*   `--reload`: Enables auto-reloading for development.\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n\nThe server will start, and the MCP tools will be available for interaction.\n\n## Available Tools\n\nThe following tools are exposed by this MCP server:\n\n1.  **`place_order(params: PlaceOrderParams)`**\n    *   Description: Places an order of a specific variety.\n    *   Input: `PlaceOrderParams` model (includes `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, and optional fields like `price`, `trigger_price`, etc.).\n    *   Returns: `{\"order_id\": \"<order_id>\"}` on success, or an error dictionary.\n\n2.  **`modify_order(params: ModifyOrderParams)`**\n    *   Description: Modifies attributes of a pending regular or CO order.\n    *   Input: `ModifyOrderParams` model (includes `variety`, `order_id`, and optional fields like `quantity`, `price`, `trigger_price`).\n    *   Returns: `{\"order_id\": \"<order_id>\"}` on success, or an error dictionary.\n\n3.  **`cancel_order(params: CancelOrderParams)`**\n    *   Description: Cancels a pending order.\n    *   Input: `CancelOrderParams` model (includes `variety`, `order_id`).\n    *   Returns: `{\"order_id\": \"<order_id>\"}` on success, or an error dictionary.\n\nRefer to `models.py` for the detailed structure of the input parameter models.\n\n## Authentication\n\nAuthentication with the Kite Connect API is handled via the `KITE_API_KEY` and `KITE_ACCESS_TOKEN` provided in the `.env` file. Ensure the access token is valid and has the necessary permissions for order placement and modification.\n\n## Error Handling\n\nThe server attempts to catch errors from the Kite Connect API (like insufficient funds, invalid parameters, network issues) and returns them in a structured JSON format:\n\n```json\n{\n  \"error\": \"Specific error message from Kite API or client.\",\n  \"code\": \"KITE_ERROR_CODE\", // Optional: Kite specific error type (e.g., InputException)\n  \"status\": \"error\"\n}\n```\n\nCheck the server logs for more detailed error information and stack traces.\n\n## Rate Limiting\n\nThe Kite Connect API has rate limits (e.g., 10 requests per second). The client includes a basic delay mechanism (`REQUEST_DELAY` in `client.py`) to mitigate hitting these limits. For high-throughput applications, a more sophisticated rate limiting strategy (e.g., token bucket) might be necessary.\n"
    }
  ]
}
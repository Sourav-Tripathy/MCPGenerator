{
  "files": [
    {
      "name": "main.py",
      "content": "import logging\nimport os\nfrom typing import Dict, Any, List\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import KiteConnectClient, KiteConnectError\nfrom models import (PlaceOrderParams, ModifyOrderParams, CancelOrderParams,\n                    GetOrdersParams, OrderResponse, OrderHistoryResponse)\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP\nmcp = FastMCP(\n    service_name=\"KiteConnect\",\n    description=\"MCP server for Zerodha Kite Connect API, enabling interaction with trading functionalities like placing orders, retrieving order/trade history, fetching instrument data, and managing mutual fund orders. It utilizes the official pykiteconnect library.\"\n)\n\n# Initialize Kite Connect Client\ntry:\n    kite_client = KiteConnectClient()\n    logger.info(\"KiteConnect client initialized successfully.\")\nexcept KiteConnectError as e:\n    logger.error(f\"Failed to initialize KiteConnect client: {e}\")\n    # Exit or handle initialization failure appropriately\n    exit(1)\nexcept Exception as e:\n    logger.error(f\"An unexpected error occurred during client initialization: {e}\")\n    exit(1)\n\n@mcp.tool()\ndef place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Place a trading order (regular, AMO, CO, Iceberg, Auction).\"\"\"\n    try:\n        logger.info(f\"Placing order with params: {params.dict(exclude_none=True)}\")\n        order_result = kite_client.place_order(\n            variety=params.variety,\n            exchange=params.exchange,\n            tradingsymbol=params.tradingsymbol,\n            transaction_type=params.transaction_type,\n            quantity=params.quantity,\n            product=params.product,\n            order_type=params.order_type,\n            price=params.price,\n            validity=params.validity,\n            disclosed_quantity=params.disclosed_quantity,\n            trigger_price=params.trigger_price,\n            iceberg_legs=params.iceberg_legs,\n            iceberg_quantity=params.iceberg_quantity,\n            auction_number=params.auction_number,\n            tag=params.tag,\n            validity_ttl=params.validity_ttl\n        )\n        logger.info(f\"Order placed successfully: {order_result}\")\n        return OrderResponse(**order_result).dict()\n    except KiteConnectError as e:\n        logger.error(f\"Error placing order: {e}\")\n        return {\"error\": str(e), \"details\": e.details}\n    except Exception as e:\n        logger.exception(\"Unexpected error placing order\")\n        return {\"error\": \"An unexpected error occurred.\", \"details\": str(e)}\n\n@mcp.tool()\ndef modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modify a pending regular or cover order.\"\"\"\n    try:\n        logger.info(f\"Modifying order {params.order_id} with params: {params.dict(exclude={'order_id', 'variety'}, exclude_none=True)}\")\n        modify_result = kite_client.modify_order(\n            variety=params.variety,\n            order_id=params.order_id,\n            parent_order_id=params.parent_order_id,\n            quantity=params.quantity,\n            price=params.price,\n            order_type=params.order_type,\n            trigger_price=params.trigger_price,\n            validity=params.validity,\n            disclosed_quantity=params.disclosed_quantity\n        )\n        logger.info(f\"Order modified successfully: {modify_result}\")\n        return OrderResponse(**modify_result).dict()\n    except KiteConnectError as e:\n        logger.error(f\"Error modifying order {params.order_id}: {e}\")\n        return {\"error\": str(e), \"details\": e.details}\n    except Exception as e:\n        logger.exception(f\"Unexpected error modifying order {params.order_id}\")\n        return {\"error\": \"An unexpected error occurred.\", \"details\": str(e)}\n\n@mcp.tool()\ndef cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"Cancel a pending regular, AMO, CO, Iceberg, or Auction order.\"\"\"\n    try:\n        logger.info(f\"Cancelling order {params.order_id} (variety: {params.variety})\")\n        cancel_result = kite_client.cancel_order(\n            variety=params.variety,\n            order_id=params.order_id,\n            parent_order_id=params.parent_order_id\n        )\n        logger.info(f\"Order cancelled successfully: {cancel_result}\")\n        return OrderResponse(**cancel_result).dict()\n    except KiteConnectError as e:\n        logger.error(f\"Error cancelling order {params.order_id}: {e}\")\n        return {\"error\": str(e), \"details\": e.details}\n    except Exception as e:\n        logger.exception(f\"Unexpected error cancelling order {params.order_id}\")\n        return {\"error\": \"An unexpected error occurred.\", \"details\": str(e)}\n\n@mcp.tool()\ndef get_orders(params: GetOrdersParams) -> Dict[str, Any]: # Keep params for potential future filtering\n    \"\"\"Retrieve the list of all orders (open, pending, executed) for the current trading day.\"\"\"\n    try:\n        logger.info(\"Fetching orders\")\n        orders = kite_client.get_orders()\n        logger.info(f\"Fetched {len(orders)} orders successfully.\")\n        # Ensure the response matches the expected structure if needed\n        # For now, return the raw list as KiteConnect provides it within a dict\n        return OrderHistoryResponse(orders=orders).dict()\n    except KiteConnectError as e:\n        logger.error(f\"Error fetching orders: {e}\")\n        return {\"error\": str(e), \"details\": e.details}\n    except Exception as e:\n        logger.exception(\"Unexpected error fetching orders\")\n        return {\"error\": \"An unexpected error occurred.\", \"details\": str(e)}\n\n# Example of how to run the server (e.g., using uvicorn)\n# uvicorn main:mcp.app --host 0.0.0.0 --port 8000\nif __name__ == \"__main__\":\n    import uvicorn\n    logger.info(\"Starting KiteConnect MCP server...\")\n    # MCP exposes a FastAPI app instance at mcp.app\n    uvicorn.run(mcp.app, host=\"0.0.0.0\", port=int(os.getenv(\"PORT\", 8000)))\n"
    },
    {
      "name": "models.py",
      "content": "from typing import Optional, Literal, Dict, List, Any\nfrom pydantic import BaseModel, Field, conint, constr\n\n# Base Models for API Parameters\nclass BaseParams(BaseModel):\n    class Config:\n        extra = 'forbid' # Disallow extra fields\n\n# Models for Tool Inputs\nclass PlaceOrderParams(BaseParams):\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument\")\n    exchange: Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'] = Field(..., description=\"Name of the exchange\")\n    transaction_type: Literal['BUY', 'SELL'] = Field(..., description=\"Transaction type\")\n    order_type: Literal['MARKET', 'LIMIT', 'SL', 'SL-M'] = Field(..., description=\"Order type\")\n    quantity: conint(gt=0) = Field(..., description=\"Quantity to transact (must be positive)\")\n    product: Literal['CNC', 'NRML', 'MIS', 'MTF'] = Field(..., description=\"Product type\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders. Required if order_type is LIMIT.\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders. Required if order_type is SL or SL-M.\")\n    disclosed_quantity: Optional[conint(ge=0)] = Field(None, description=\"Quantity to disclose publicly (equity only, must be non-negative)\")\n    validity: Literal['DAY', 'IOC', 'TTL'] = Field(..., description=\"Order validity\")\n    validity_ttl: Optional[conint(gt=0)] = Field(None, description=\"Order life span in minutes for TTL validity (must be positive). Required if validity is TTL.\")\n    iceberg_legs: Optional[conint(ge=2, le=10)] = Field(None, description=\"Number of legs for iceberg order (2-10). Required if variety is iceberg.\")\n    iceberg_quantity: Optional[conint(gt=0)] = Field(None, description=\"Split quantity for each iceberg leg (quantity/iceberg_legs). Required if variety is iceberg.\")\n    auction_number: Optional[str] = Field(None, description=\"Unique identifier for auction order. Required if variety is auction.\")\n    tag: Optional[constr(max_length=20)] = Field(None, description=\"Optional tag for the order (max 20 chars)\")\n\nclass ModifyOrderParams(BaseParams):\n    variety: Literal['regular', 'co'] = Field(..., description=\"Order variety to modify\")\n    order_id: str = Field(..., description=\"The ID of the order to modify\")\n    parent_order_id: Optional[str] = Field(None, description=\"The parent order ID if modifying a second leg CO order\")\n    order_type: Optional[Literal['MARKET', 'LIMIT', 'SL', 'SL-M']] = Field(None, description=\"New order type (Regular only)\")\n    quantity: Optional[conint(gt=0)] = Field(None, description=\"New quantity (Regular only, must be positive)\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders)\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, CO orders)\")\n    disclosed_quantity: Optional[conint(ge=0)] = Field(None, description=\"New disclosed quantity (Regular equity only, must be non-negative)\")\n    validity: Optional[Literal['DAY', 'IOC', 'TTL']] = Field(None, description=\"New validity (Regular only)\")\n\nclass CancelOrderParams(BaseParams):\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety to cancel\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel\")\n    parent_order_id: Optional[str] = Field(None, description=\"The parent order ID if cancelling a second leg CO order\")\n\nclass GetOrdersParams(BaseParams):\n    # Currently no parameters needed for get_orders, but define for consistency\n    pass\n\n# Models for Tool Outputs / Responses\nclass OrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID.\")\n\nclass OrderHistoryResponse(BaseModel):\n    orders: List[Dict[str, Any]] = Field(..., description=\"List of orders for the day.\")\n"
    },
    {
      "name": "client.py",
      "content": "import os\nimport logging\nfrom kiteconnect import KiteConnect\nfrom kiteconnect import exceptions as kite_ex\n\nlogger = logging.getLogger(__name__)\n\n# Custom Exception for KiteConnect Client Errors\nclass KiteConnectError(Exception):\n    def __init__(self, message, details=None):\n        super().__init__(message)\n        self.details = details\n\nclass KiteConnectClient:\n    \"\"\"Client to interact with the Zerodha Kite Connect API using pykiteconnect.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the KiteConnect client using API key and access token from environment variables.\"\"\"\n        self.api_key = os.getenv(\"KITE_API_KEY\")\n        self.access_token = os.getenv(\"KITE_ACCESS_TOKEN\")\n\n        if not self.api_key:\n            raise KiteConnectError(\"KITE_API_KEY environment variable not set.\")\n        # Access token is crucial for authenticated calls\n        if not self.access_token:\n            logger.warning(\"KITE_ACCESS_TOKEN environment variable not set. Authenticated calls will fail.\")\n            # Depending on use case, might raise error or allow partial functionality\n            # raise KiteConnectError(\"KITE_ACCESS_TOKEN environment variable not set.\")\n\n        try:\n            self.kite = KiteConnect(api_key=self.api_key)\n            # Set access token if available. Most methods require it.\n            if self.access_token:\n                self.kite.set_access_token(self.access_token)\n                logger.info(\"KiteConnect client initialized and access token set.\")\n            else:\n                logger.warning(\"KiteConnect client initialized WITHOUT access token. Only public methods might work.\")\n\n            # Optional: Set a default timeout (in seconds)\n            self.kite.set_timeout(10)\n\n        except Exception as e:\n            logger.exception(\"Failed to initialize KiteConnect instance\")\n            raise KiteConnectError(f\"Failed to initialize KiteConnect: {e}\")\n\n    def _handle_api_error(self, error: Exception, context: str):\n        \"\"\"Handles exceptions raised by the KiteConnect library.\"\"\"\n        error_type = type(error).__name__\n        error_message = str(error)\n        details = {\"type\": error_type, \"message\": error_message}\n\n        if isinstance(error, kite_ex.InputException):\n            logger.error(f\"Input Error during {context}: {error_message}\")\n            raise KiteConnectError(f\"Invalid input provided for {context}.\", details=details)\n        elif isinstance(error, kite_ex.TokenException):\n            logger.error(f\"Token Error during {context}: {error_message}. Check API Key and Access Token.\")\n            raise KiteConnectError(f\"Authentication error during {context}. Please check credentials.\", details=details)\n        elif isinstance(error, kite_ex.PermissionException):\n            logger.error(f\"Permission Error during {context}: {error_message}\")\n            raise KiteConnectError(f\"Permission denied for {context}.\", details=details)\n        elif isinstance(error, kite_ex.OrderException):\n            logger.error(f\"Order Placement/Modification Error during {context}: {error_message}\")\n            raise KiteConnectError(f\"Order error during {context}.\", details=details)\n        elif isinstance(error, kite_ex.NetworkException):\n            logger.error(f\"Network Error during {context}: {error_message}\")\n            raise KiteConnectError(f\"Network error communicating with Kite API during {context}.\", details=details)\n        elif isinstance(error, kite_ex.GeneralException):\n            logger.error(f\"General Kite API Error during {context}: {error_message}\")\n            raise KiteConnectError(f\"A general Kite API error occurred during {context}.\", details=details)\n        else:\n            logger.exception(f\"An unexpected error occurred during {context}\")\n            raise KiteConnectError(f\"An unexpected error occurred during {context}.\", details=details)\n\n    def place_order(self, **kwargs):\n        \"\"\"Places an order.\"\"\"\n        context = \"placing order\"\n        if not self.access_token:\n            raise KiteConnectError(\"Access token is required for placing orders.\")\n        try:\n            # Filter out None values before sending to kite.place_order\n            order_params = {k: v for k, v in kwargs.items() if v is not None}\n            logger.debug(f\"Placing order with filtered params: {order_params}\")\n            return self.kite.place_order(**order_params)\n        except Exception as e:\n            self._handle_api_error(e, context)\n\n    def modify_order(self, **kwargs):\n        \"\"\"Modifies an existing order.\"\"\"\n        context = f\"modifying order {kwargs.get('order_id')}\"\n        if not self.access_token:\n            raise KiteConnectError(\"Access token is required for modifying orders.\")\n        try:\n            # Filter out None values\n            modify_params = {k: v for k, v in kwargs.items() if v is not None}\n            logger.debug(f\"Modifying order with filtered params: {modify_params}\")\n            return self.kite.modify_order(**modify_params)\n        except Exception as e:\n            self._handle_api_error(e, context)\n\n    def cancel_order(self, **kwargs):\n        \"\"\"Cancels an order.\"\"\"\n        context = f\"cancelling order {kwargs.get('order_id')}\"\n        if not self.access_token:\n            raise KiteConnectError(\"Access token is required for cancelling orders.\")\n        try:\n            # Filter out None values\n            cancel_params = {k: v for k, v in kwargs.items() if v is not None}\n            logger.debug(f\"Cancelling order with filtered params: {cancel_params}\")\n            return self.kite.cancel_order(**cancel_params)\n        except Exception as e:\n            self._handle_api_error(e, context)\n\n    def get_orders(self):\n        \"\"\"Retrieves the list of orders for the day.\"\"\"\n        context = \"fetching orders\"\n        if not self.access_token:\n            raise KiteConnectError(\"Access token is required for fetching orders.\")\n        try:\n            logger.debug(\"Fetching all orders for the day\")\n            return self.kite.orders()\n        except Exception as e:\n            self._handle_api_error(e, context)\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npykiteconnect>=4.0.0,<5.0.0\npydantic>=1.9.0,<2.0.0\npython-dotenv>=0.19.0\nuvicorn>=0.15.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Zerodha Kite Connect API Credentials\n# Obtain these from your Kite Developer Console (https://developers.kite.trade/)\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# The access token obtained after completing the login flow.\n# This token is typically valid for one day and needs to be regenerated.\n# How to generate this token is outside the scope of this MCP server.\n# See Kite Connect documentation for the login flow.\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# Port for the MCP server\nPORT=8000\n"
    },
    {
      "name": "README.md",
      "content": "# KiteConnect MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect API. It allows language models or other applications to perform trading-related actions like placing, modifying, and cancelling orders, as well as retrieving order history using natural language or structured requests via the MCP interface.\n\nThis server uses the official `pykiteconnect` library to communicate with the Kite API.\n\n## Features\n\n*   **Place Orders**: Place various types of orders (regular, AMO, CO, Iceberg, Auction).\n*   **Modify Orders**: Modify pending regular or cover orders.\n*   **Cancel Orders**: Cancel pending orders.\n*   **Get Orders**: Retrieve the list of all orders for the current trading day.\n*   Built with **FastMCP** for easy integration.\n*   Uses **Pydantic** for robust data validation.\n*   Includes **error handling** for common Kite API exceptions.\n\n## Prerequisites\n\n*   Python 3.8+\n*   A Zerodha Kite account.\n*   Kite Connect API Key and API Secret obtained from the [Kite Developer Console](https://developers.kite.trade/).\n*   A valid `access_token`. Generating the `access_token` requires implementing the Kite Connect login flow, which is **outside the scope of this server**. You need to obtain this token beforehand and provide it via environment variables.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    Create a `.env` file in the project root directory by copying the example file:\n    ```bash\n    cp .env.example .env\n    ```\n    Edit the `.env` file and add your Kite API Key and the pre-generated Access Token:\n    ```dotenv\n    # Zerodha Kite Connect API Credentials\n    KITE_API_KEY=\"YOUR_ACTUAL_API_KEY\"\n    KITE_ACCESS_TOKEN=\"YOUR_PREGENERATED_ACCESS_TOKEN\"\n\n    # Port for the MCP server (optional, defaults to 8000)\n    PORT=8000\n    ```\n    **Important:** The `KITE_ACCESS_TOKEN` needs to be valid. You usually obtain this daily after completing the login flow.\n\n## Running the Server\n\nUse Uvicorn to run the FastMCP application:\n\n```bash\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port (can be changed, ensure it matches `PORT` in `.env` if set).\n*   `--reload`: Automatically restarts the server when code changes (useful for development).\n\nThe MCP server will be available at `http://localhost:8000` (or the configured host/port).\n\n## Available Tools\n\nThe server exposes the following tools via the MCP protocol:\n\n1.  **`place_order`**: Place a trading order.\n    *   **Input**: `PlaceOrderParams` model (see `models.py` for fields like `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, `price`, etc.)\n    *   **Output**: `OrderResponse` model (contains `order_id`) or an error dictionary.\n\n2.  **`modify_order`**: Modify a pending order.\n    *   **Input**: `ModifyOrderParams` model (see `models.py` for fields like `variety`, `order_id`, `quantity`, `price`, `trigger_price`, etc.)\n    *   **Output**: `OrderResponse` model (contains `order_id`) or an error dictionary.\n\n3.  **`cancel_order`**: Cancel a pending order.\n    *   **Input**: `CancelOrderParams` model (see `models.py` for fields like `variety`, `order_id`)\n    *   **Output**: `OrderResponse` model (contains `order_id`) or an error dictionary.\n\n4.  **`get_orders`**: Retrieve all orders for the day.\n    *   **Input**: `GetOrdersParams` model (currently empty).\n    *   **Output**: `OrderHistoryResponse` model (contains a list of `orders`) or an error dictionary.\n\n## Error Handling\n\nThe server catches common exceptions from the `pykiteconnect` library (e.g., `TokenException`, `InputException`, `OrderException`, `NetworkException`) and returns a JSON object with an `error` message and `details` about the specific Kite API error.\n\n## Disclaimer\n\nTrading involves substantial risk. This software is provided \"as is\" without warranty of any kind. Use it at your own risk. Ensure you understand the Kite Connect API's rate limits and terms of service.\n"
    }
  ]
}
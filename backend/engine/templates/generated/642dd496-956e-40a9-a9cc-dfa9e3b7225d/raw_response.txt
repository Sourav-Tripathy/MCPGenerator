{
  "files": [
    {
      "name": "main.py",
      "content": "import logging\nimport os\nfrom typing import Dict, Any\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import KiteConnectClient, KiteConnectError\nfrom models import PlaceOrderParams, ModifyOrderParams\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectOrders\",\n    description=\"MCP service for managing trading orders (placing, modifying, cancelling, retrieving orders and trades) using the Kite Connect v3 API. This service allows interaction with the order management system of Zerodha's Kite platform.\"\n)\n\n# Initialize Kite Connect Client\ntry:\n    kite_client = KiteConnectClient()\nexcept ValueError as e:\n    logger.error(f\"Failed to initialize KiteConnectClient: {e}\")\n    # Exit or handle appropriately if client initialization fails\n    exit(1)\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Place an order of a specified variety (regular, amo, co, iceberg, auction).\n    Returns the order_id upon successful placement.\n\n    Args:\n        params: Parameters for placing the order.\n\n    Returns:\n        A dictionary containing the status and the order_id of the placed order,\n        or an error dictionary.\n    \"\"\"\n    logger.info(f\"Received place_order request: {params.dict(exclude_none=True)}\")\n    try:\n        result = await kite_client.place_order(params)\n        logger.info(f\"place_order successful: {result}\")\n        return result\n    except KiteConnectError as e:\n        logger.error(f\"KiteConnectError in place_order: {e}\")\n        return {\"status\": \"error\", \"error_type\": e.__class__.__name__, \"message\": str(e)}\n    except Exception as e:\n        logger.exception(f\"Unexpected error in place_order: {e}\")\n        return {\"status\": \"error\", \"error_type\": \"ServerError\", \"message\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Modify attributes of a pending regular or cover order (CO).\n\n    Args:\n        params: Parameters for modifying the order.\n\n    Returns:\n        A dictionary containing the status and the order_id of the modified order,\n        or an error dictionary.\n    \"\"\"\n    logger.info(f\"Received modify_order request for order_id {params.order_id}: {params.dict(exclude={'order_id', 'variety'}, exclude_none=True)}\")\n    try:\n        result = await kite_client.modify_order(params)\n        logger.info(f\"modify_order successful: {result}\")\n        return result\n    except KiteConnectError as e:\n        logger.error(f\"KiteConnectError in modify_order: {e}\")\n        return {\"status\": \"error\", \"error_type\": e.__class__.__name__, \"message\": str(e)}\n    except Exception as e:\n        logger.exception(f\"Unexpected error in modify_order: {e}\")\n        return {\"status\": \"error\", \"error_type\": \"ServerError\", \"message\": f\"An unexpected error occurred: {str(e)}\"}\n\nif __name__ == \"__main__\":\n    # This block is for running the server directly, e.g., for development\n    # For production, use a command like: uvicorn main:mcp.app --host 0.0.0.0 --port 8000\n    import uvicorn\n    uvicorn.run(mcp.app, host=\"127.0.0.1\", port=8000)\n"
    },
    {
      "name": "models.py",
      "content": "from typing import Optional, Literal, Dict, Any\nfrom pydantic import BaseModel, Field, validator, root_validator\n\n# Define Literal types for common parameters\nExchangeType = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\nVarietyType = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nModifyVarietyType = Literal['regular', 'co']\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Input model for the place_order tool.\"\"\"\n    variety: VarietyType = Field(..., description=\"The variety of the order.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange.\")\n    transaction_type: TransactionType = Field(..., description=\"Transaction type.\")\n    order_type: OrderType = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: ProductType = Field(..., description=\"Product margin type.\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders.\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (equity only).\", ge=0)\n    validity: ValidityType = Field(..., description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\", gt=0)\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10).\", ge=2, le=10)\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs).\", gt=0)\n    auction_number: Optional[str] = Field(None, description=\"Unique identifier for a specific auction.\")\n    tag: Optional[str] = Field(None, description=\"Optional tag for the order (alphanumeric, max 20 chars).\", max_length=20)\n\n    @root_validator\n    def check_conditional_fields(cls, values: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate conditional requirements based on order type, variety, etc.\"\"\"\n        order_type = values.get('order_type')\n        price = values.get('price')\n        trigger_price = values.get('trigger_price')\n        variety = values.get('variety')\n        validity = values.get('validity')\n        validity_ttl = values.get('validity_ttl')\n        iceberg_legs = values.get('iceberg_legs')\n        iceberg_quantity = values.get('iceberg_quantity')\n        quantity = values.get('quantity')\n        auction_number = values.get('auction_number')\n\n        if order_type == 'LIMIT' and price is None:\n            raise ValueError(\"Price is required for LIMIT orders.\")\n        if order_type in ['SL', 'SL-M'] and trigger_price is None:\n            raise ValueError(\"Trigger price is required for SL and SL-M orders.\")\n        if variety == 'co' and trigger_price is None:\n             # CO Market needs trigger price relative to LTP, CO Limit needs it too\n             pass # Kiteconnect library handles specific CO logic, basic check here\n        if validity == 'TTL' and validity_ttl is None:\n            raise ValueError(\"validity_ttl is required for TTL validity.\")\n        if variety == 'iceberg' and (iceberg_legs is None or iceberg_quantity is None):\n            raise ValueError(\"iceberg_legs and iceberg_quantity are required for iceberg orders.\")\n        if variety == 'iceberg' and iceberg_quantity and iceberg_legs and quantity:\n            # Approximate check, exact validation might depend on broker rules\n            if not (quantity / iceberg_legs) >= iceberg_quantity:\n                 pass # Let API handle exact validation, avoid complex client-side rules\n        if variety == 'auction' and auction_number is None:\n            raise ValueError(\"auction_number is required for auction orders.\")\n\n        # Prevent price/trigger_price for MARKET orders if not needed by variety (e.g., regular MARKET)\n        if order_type == 'MARKET' and variety == 'regular':\n            if price is not None:\n                raise ValueError(\"Price should not be provided for regular MARKET orders.\")\n            # Trigger price might be used in AMO SL-M orders, so allow it generally\n            # if trigger_price is not None:\n            #     raise ValueError(\"Trigger price should not be provided for regular MARKET orders.\")\n\n        return values\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Input model for the modify_order tool.\"\"\"\n    variety: ModifyVarietyType = Field(..., description=\"The variety of the order to modify ('regular' or 'co').\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    order_type: Optional[OrderType] = Field(None, description=\"New order type (Regular variety only).\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (Regular variety only).\", gt=0)\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, CO LIMIT orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (Regular variety only).\", ge=0)\n    validity: Optional[ValidityType] = Field(None, description=\"New validity (Regular variety only).\")\n\n    @root_validator\n    def check_regular_only_fields(cls, values: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Ensure fields only applicable to 'regular' variety are not set for 'co'.\"\"\"\n        variety = values.get('variety')\n        if variety == 'co':\n            # Fields not modifiable for CO orders according to general Kite docs\n            if values.get('order_type') is not None:\n                raise ValueError(\"order_type cannot be modified for CO orders.\")\n            if values.get('quantity') is not None:\n                raise ValueError(\"quantity cannot be modified for CO orders.\")\n            if values.get('disclosed_quantity') is not None:\n                raise ValueError(\"disclosed_quantity cannot be modified for CO orders.\")\n            if values.get('validity') is not None:\n                raise ValueError(\"validity cannot be modified for CO orders.\")\n        elif variety == 'regular':\n            # Validate conditions for regular order modification\n            order_type = values.get('order_type')\n            price = values.get('price')\n            trigger_price = values.get('trigger_price')\n\n            if order_type == 'LIMIT' and price is None and values.get('price') is None:\n                 # If modifying to LIMIT, price must be provided. If already LIMIT, price is optional.\n                 # This logic is complex without knowing the original order state. Let API handle.\
                 pass\n            if order_type in ['SL', 'SL-M'] and trigger_price is None and values.get('trigger_price') is None:\n                 # Similar complexity as above. Let API handle.\
                 pass\n        return values\n\n# Example Response Structure (as per plan, tools return Dict[str, Any])\nclass OrderResponse(BaseModel):\n    status: str\n    data: Optional[Dict[str, Any]] = None\n    error_type: Optional[str] = None\n    message: Optional[str] = None\n"
    },
    {
      "name": "client.py",
      "content": "import os\nimport logging\nfrom typing import Dict, Any, Optional\n\nimport httpx\nfrom tenacity import retry, stop_after_attempt, wait_fixed, retry_if_exception_type\n\nfrom models import PlaceOrderParams, ModifyOrderParams\n\nlogger = logging.getLogger(__name__)\n\n# --- Custom Exceptions ---\nclass KiteConnectError(Exception):\n    \"\"\"Base exception for Kite Connect client errors.\"\"\"\n    def __init__(self, message=\"Kite Connect API error\", status_code: Optional[int] = None, details: Optional[Dict] = None):\n        self.status_code = status_code\n        self.details = details or {}\n        super().__init__(message)\n\n    def __str__(self):\n        return f\"{super().__str__()} (Status: {self.status_code}, Details: {self.details})\"\n\nclass AuthenticationError(KiteConnectError):\n    \"\"\"Error related to authentication (invalid API key or access token).\"\"\"\n    pass\n\nclass NetworkError(KiteConnectError):\n    \"\"\"Error related to network connectivity or timeouts.\"\"\"\n    pass\n\nclass BadRequestError(KiteConnectError):\n    \"\"\"Error for general 4xx client errors (e.g., validation).\"\"\"\n    pass\n\nclass OrderPlacementError(BadRequestError):\n    \"\"\"Specific error during order placement (e.g., insufficient funds, invalid params).\"\"\"\n    pass\n\nclass OrderModificationError(BadRequestError):\n    \"\"\"Specific error during order modification (e.g., order not found, invalid state).\"\"\"\n    pass\n\nclass RateLimitError(KiteConnectError):\n    \"\"\"Error when API rate limits are exceeded (HTTP 429).\"\"\"\n    pass\n\nclass ServerError(KiteConnectError):\n    \"\"\"Error for 5xx server-side errors.\"\"\"\n    pass\n\n# --- Kite Connect Client ---\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect v3 API.\"\"\"\n\n    # Note: Kite Connect API has rate limits (e.g., 10 requests/second overall).\n    # This client uses basic retry logic for transient errors but does not implement\n    # sophisticated rate limiting. Consider using a library like 'limits' or\n    # implementing token bucket/leaky bucket algorithm if needed.\n    RETRY_ATTEMPTS = 3\n    RETRY_WAIT_SECONDS = 2\n\n    def __init__(self):\n        self.api_key = os.getenv(\"KITE_API_KEY\")\n        self.access_token = os.getenv(\"KITE_ACCESS_TOKEN\")\n        self.base_url = os.getenv(\"KITE_API_BASE_URL\", \"https://api.kite.trade\")\n\n        if not self.api_key or not self.access_token:\n            raise ValueError(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n\n        self.headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            # Content-Type is set per request (form-data)\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=30.0  # Set a reasonable timeout\n        )\n\n    @retry(\n        stop=stop_after_attempt(RETRY_ATTEMPTS),\n        wait=wait_fixed(RETRY_WAIT_SECONDS),\n        retry=retry_if_exception_type((NetworkError, RateLimitError, ServerError)),\n        reraise=True, # Reraise the exception after retries are exhausted\n        before_sleep=lambda retry_state: logger.warning(f\"Retrying API call due to {retry_state.outcome.exception().__class__.__name__}, attempt {retry_state.attempt_number}...\")\n    )\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite Connect API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Making {method} request to {url} with data: {data}\")\n\n        try:\n            response = await self.client.request(method, endpoint, data=data)\n\n            # Handle specific HTTP status codes\n            if response.status_code == 400:\n                error_details = self._parse_error_response(response)\n                logger.error(f\"Bad Request (400) for {method} {endpoint}: {error_details}\")\n                raise BadRequestError(message=error_details.get('message', 'Bad Request'), status_code=400, details=error_details)\n            if response.status_code == 403:\n                error_details = self._parse_error_response(response)\n                logger.error(f\"Authentication Error (403) for {method} {endpoint}: {error_details}\")\n                raise AuthenticationError(message=error_details.get('message', 'Forbidden/Authentication Error'), status_code=403, details=error_details)\n            if response.status_code == 404:\n                 error_details = self._parse_error_response(response)\n                 logger.error(f\"Not Found (404) for {method} {endpoint}: {error_details}\")\n                 raise BadRequestError(message=error_details.get('message', 'Resource Not Found'), status_code=404, details=error_details)\n            if response.status_code == 429:\n                logger.warning(f\"Rate Limit Exceeded (429) for {method} {endpoint}. Retrying might be needed.\")\n                raise RateLimitError(message=\"Rate limit exceeded\", status_code=429)\n            if response.status_code >= 500:\n                logger.error(f\"Server Error ({response.status_code}) for {method} {endpoint}: {response.text}\")\n                raise ServerError(message=f\"Kite API Server Error: {response.text}\", status_code=response.status_code)\n\n            # Raise for other 4xx errors not explicitly handled above\n            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx\n\n            # Successful response (usually 200 OK)\n            json_response = response.json()\n            logger.debug(f\"Received successful response ({response.status_code}) from {method} {endpoint}: {json_response}\")\n            return json_response\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out for {method} {endpoint}: {e}\")\n            raise NetworkError(f\"Request timed out: {e}\") from e\n        except httpx.NetworkError as e:\n            logger.error(f\"Network error for {method} {endpoint}: {e}\")\n            raise NetworkError(f\"Network error occurred: {e}\") from e\n        except httpx.HTTPStatusError as e:\n            # This catches errors raised by response.raise_for_status() for unhandled 4xx/5xx\n            error_details = self._parse_error_response(e.response)\n            logger.error(f\"HTTP Error ({e.response.status_code}) for {method} {endpoint}: {error_details}\")\n            # Map to a more specific error if possible based on status code\n            if e.response.status_code >= 400 and e.response.status_code < 500:\n                 raise BadRequestError(message=error_details.get('message', f'HTTP Client Error: {e.response.status_code}'), status_code=e.response.status_code, details=error_details) from e\n            else:\n                 raise ServerError(message=error_details.get('message', f'HTTP Server Error: {e.response.status_code}'), status_code=e.response.status_code, details=error_details) from e\n        except Exception as e:\n            logger.exception(f\"Unexpected error during request to {method} {endpoint}: {e}\")\n            raise KiteConnectError(f\"An unexpected error occurred: {e}\") from e\n\n    def _parse_error_response(self, response: httpx.Response) -> Dict[str, Any]:\n        \"\"\"Attempts to parse error details from the Kite API response.\"\"\"\n        try:\n            data = response.json()\n            if isinstance(data, dict) and 'status' in data and data['status'] == 'error':\n                return {\n                    'message': data.get('message', 'Unknown error'),\n                    'error_type': data.get('error_type', 'UnknownError')\n                }\n        except Exception:\n            pass # Ignore if response is not valid JSON or doesn't match expected error format\n        return {'message': response.text or f'HTTP Error {response.status_code}', 'error_type': 'UnknownHttpError'}\n\n    def _prepare_payload(self, params: BaseModel, exclude_fields: set = None) -> Dict[str, Any]:\n        \"\"\"Converts Pydantic model to dictionary suitable for form data, excluding None values and specified fields.\"\"\"\n        if exclude_fields is None:\n            exclude_fields = set()\n        payload = params.dict(exclude_none=True, exclude=exclude_fields)\n        # Convert relevant fields to string as expected by form encoding if necessary (httpx usually handles this)\n        # For example, boolean might need 'true'/'false', but httpx handles common types.\n        # Ensure numeric types are sent correctly.\n        return payload\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, Any]:\n        \"\"\"Place an order.\"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        payload = self._prepare_payload(params, exclude_fields={'variety'})\n        try:\n            response_data = await self._request(\"POST\", endpoint, data=payload)\n            # Expecting {'status': 'success', 'data': {'order_id': '...'}}\n            if response_data.get('status') == 'success' and 'data' in response_data and 'order_id' in response_data['data']:\n                return response_data\n            else:\n                logger.error(f\"place_order response format unexpected: {response_data}\")\n                raise OrderPlacementError(message=\"Order placement response format unexpected\", details=response_data)\n        except BadRequestError as e:\n            # More specific error for placement issues\n            raise OrderPlacementError(message=e.args[0], status_code=e.status_code, details=e.details) from e\n        except KiteConnectError as e:\n            # Catch other client errors\n            raise e\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, Any]:\n        \"\"\"Modify a pending order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        payload = self._prepare_payload(params, exclude_fields={'variety', 'order_id'})\n        try:\n            response_data = await self._request(\"PUT\", endpoint, data=payload)\n            # Expecting {'status': 'success', 'data': {'order_id': '...'}}\n            if response_data.get('status') == 'success' and 'data' in response_data and 'order_id' in response_data['data']:\n                return response_data\n            else:\n                logger.error(f\"modify_order response format unexpected: {response_data}\")\n                raise OrderModificationError(message=\"Order modification response format unexpected\", details=response_data)\n        except BadRequestError as e:\n             # More specific error for modification issues (e.g., 400 or 404 if order_id invalid)\n            raise OrderModificationError(message=e.args[0], status_code=e.status_code, details=e.details) from e\n        except KiteConnectError as e:\n            raise e\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0,<0.2.0\nhttpx[http2]>=0.25.0,<0.28.0\npydantic>=1.10.0,<2.0.0\npython-dotenv>=1.0.0,<2.0.0\nuvicorn[standard]>=0.23.0,<0.25.0\ntenacity>=8.2.0,<9.0.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer account: https://developers.kite.trade/\n\n# Your Kite Connect API key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# The access token obtained after a successful login flow (e.g., using KiteConnect library or manual process)\n# This token is typically short-lived and needs to be regenerated periodically.\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# (Optional) Base URL for the Kite Connect API\n# KITE_API_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the order management endpoints of the Zerodha Kite Connect v3 API. It allows language models or other clients to place and modify trading orders through a standardized MCP interface.\n\n## Features\n\n*   **Place Orders:** Place various types of orders (regular, AMO, CO, Iceberg, Auction).\n*   **Modify Orders:** Modify pending regular and CO orders.\n*   **Asynchronous:** Built with `asyncio` and `httpx` for non-blocking I/O.\n*   **Typed:** Uses Pydantic for request validation and data modeling.\n*   **Error Handling:** Maps Kite Connect API errors to specific exceptions.\n*   **Configurable:** Uses environment variables for API credentials.\n\n## Prerequisites\n\n*   Python 3.8+\n*   Zerodha Kite Connect API Key and Access Token.\n    *   You need to register an app on the [Kite Developer Console](https://developers.kite.trade/).\n    *   You need a valid `access_token` obtained through the Kite Connect login flow. This token usually has a daily expiry and needs to be regenerated.\n*   Understanding of Kite Connect API parameters and order types.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create and activate a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure environment variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect API Key and a valid Access Token:\n        ```dotenv\n        KITE_API_KEY=\"YOUR_API_KEY\"\n        KITE_ACCESS_TOKEN=\"YOUR_VALID_ACCESS_TOKEN\"\n        # KITE_API_BASE_URL=\"https://api.kite.trade\" # Optional: uncomment to override default\n        ```\n    *   **Important:** The `KITE_ACCESS_TOKEN` is short-lived. You will need a mechanism to refresh this token regularly and update the `.env` file or the environment variable.\n\n## Running the Server\n\nUse `uvicorn` to run the FastMCP application:\n\n```bash\nuvicorn main:mcp.app --host 127.0.0.1 --port 8000 --reload\n```\n\n*   `--reload`: Enables auto-reloading for development (remove in production).\n*   Adjust `--host` and `--port` as needed.\n\n## Available Tools\n\nThe MCP server exposes the following tools:\n\n1.  **`place_order`**\n    *   **Description:** Place an order of a specified variety (regular, amo, co, iceberg, auction). Returns the order_id upon successful placement.\n    *   **Input Model:** `PlaceOrderParams` (see `models.py` for details)\n        *   `variety`: 'regular', 'amo', 'co', 'iceberg', 'auction'\n        *   `tradingsymbol`: e.g., \"INFY\"\n        *   `exchange`: 'NSE', 'BSE', 'NFO', etc.\n        *   `transaction_type`: 'BUY' or 'SELL'\n        *   `order_type`: 'MARKET', 'LIMIT', 'SL', 'SL-M'\n        *   `quantity`: Integer > 0\n        *   `product`: 'CNC', 'NRML', 'MIS', 'MTF'\n        *   `price`: Float (Required for LIMIT)\n        *   `trigger_price`: Float (Required for SL, SL-M)\n        *   `validity`: 'DAY', 'IOC', 'TTL'\n        *   ... (see `models.PlaceOrderParams` for all optional fields like `disclosed_quantity`, `validity_ttl`, `iceberg_legs`, `tag`, etc.)\n    *   **Returns:** `Dict[str, Any]` - e.g., `{'status': 'success', 'data': {'order_id': '151220000000000'}}` or `{'status': 'error', 'error_type': '...', 'message': '...'}`\n\n2.  **`modify_order`**\n    *   **Description:** Modify attributes of a pending regular or cover order (CO).\n    *   **Input Model:** `ModifyOrderParams` (see `models.py` for details)\n        *   `variety`: 'regular' or 'co'\n        *   `order_id`: The ID of the order to modify.\n        *   `order_type`: New order type (Regular only)\n        *   `quantity`: New quantity (Regular only)\n        *   `price`: New price (LIMIT)\n        *   `trigger_price`: New trigger price (SL, SL-M, CO)\n        *   `validity`: New validity (Regular only)\n        *   ... (see `models.ModifyOrderParams` for optional fields)\n    *   **Returns:** `Dict[str, Any]` - e.g., `{'status': 'success', 'data': {'order_id': '151220000000000'}}` or `{'status': 'error', 'error_type': '...', 'message': '...'}`\n\n## Error Handling\n\nThe client (`client.py`) attempts to map HTTP errors and Kite Connect specific error responses (based on status codes and response bodies) to custom exceptions (`KiteConnectError` subclasses). These errors are caught in `main.py` and returned as structured JSON error messages.\n\nCommon errors include:\n*   `AuthenticationError`: Invalid API key or access token (HTTP 403).\n*   `OrderPlacementError`/`OrderModificationError`: Invalid parameters, insufficient funds, order not found, etc. (HTTP 400).\n*   `RateLimitError`: Exceeding API rate limits (HTTP 429).\n*   `NetworkError`: Connection issues or timeouts.\n*   `ServerError`: Errors on the Kite Connect API side (HTTP 5xx).\n\n## Rate Limiting\n\nThe Kite Connect API enforces rate limits (typically 10 requests/second). This client includes basic retry logic for transient errors (`NetworkError`, `RateLimitError`, `ServerError`) using `tenacity`. However, it does **not** implement proactive rate limiting. If you anticipate high request volumes, consider adding a more robust rate limiting mechanism.\n\n## Disclaimer\n\nTrading involves substantial risk. This software is provided \"as is\" without warranty of any kind. Use it at your own risk. Ensure thorough testing in a simulated environment before using with real funds. The developers are not responsible for any financial losses incurred.\n"
    }
  ]
}
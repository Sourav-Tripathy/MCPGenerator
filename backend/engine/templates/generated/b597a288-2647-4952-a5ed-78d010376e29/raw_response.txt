{
  "files": [
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field\nfrom typing import Optional, Dict, Any, Literal\n\nclass PlaceOrderParams(BaseModel):\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument\")\n    exchange: Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'] = Field(..., description=\"Name of the exchange\")\n    transaction_type: Literal['BUY', 'SELL'] = Field(..., description=\"BUY or SELL\")\n    order_type: Literal['MARKET', 'LIMIT', 'SL', 'SL-M'] = Field(..., description=\"Order type\")\n    quantity: int = Field(..., description=\"Quantity to transact\")\n    product: Literal['CNC', 'NRML', 'MIS', 'MTF'] = Field(..., description=\"Product code\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (for LIMIT orders)\")\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (for SL, SL-M orders)\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades)\")\n    validity: Optional[Literal['DAY', 'IOC', 'TTL']] = Field('DAY', description=\"Order validity. Default is DAY.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10)\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs)\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction (for auction variety)\")\n    tag: Optional[str] = Field(None, description=\"An optional tag to apply to an order (alphanumeric, max 20 chars)\")\n\nclass ModifyOrderParams(BaseModel):\n    variety: Literal['regular', 'co'] = Field(..., description=\"Order variety\")\n    order_id: str = Field(..., description=\"The ID of the order to modify\")\n    parent_order_id: Optional[str] = Field(None, description=\"The parent order ID (required for modifying second leg of CO)\")\n    order_type: Optional[Literal['MARKET', 'LIMIT', 'SL', 'SL-M']] = Field(None, description=\"New order type (only for regular variety)\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (only for regular variety)\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders)\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, or LIMIT CO orders)\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (only for regular variety)\")\n    validity: Optional[Literal['DAY', 'IOC']] = Field(None, description=\"New validity (only for regular variety, DAY or IOC)\")\n\nclass CancelOrderParams(BaseModel):\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel\")\n    parent_order_id: Optional[str] = Field(None, description=\"The parent order ID (required for cancelling second leg of CO)\")\n\nclass OrderResponse(BaseModel):\n    order_id: str\n\nclass SuccessResponse(BaseModel):\n    status: str = \"success\"\n    data: OrderResponse\n\nclass ErrorResponse(BaseModel):\n    status: str = \"error\"\n    message: str\n    error_type: Optional[str] = None\n"
    },
    {
      "name": "client.py",
      "content": "import logging\nimport asyncio\nfrom kiteconnect import KiteConnect\nfrom kiteconnect import exceptions as kite_ex\nfrom typing import Dict, Any, Union\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams, SuccessResponse, ErrorResponse\n\nlogger = logging.getLogger(__name__)\n\n# Mapping Kite exceptions to string identifiers\nKITE_EXCEPTION_MAP = {\n    kite_ex.InputException: \"InputException\",\n    kite_ex.TokenException: \"TokenException\",\n    kite_ex.PermissionException: \"PermissionException\",\n    kite_ex.OrderException: \"OrderException\",\n    kite_ex.NetworkException: \"NetworkException\",\n    kite_ex.DataException: \"DataException\",\n    kite_ex.GeneralException: \"GeneralException\",\n}\n\nclass KiteConnectClient:\n    \"\"\"Client to interact with the Kite Connect API using pykiteconnect.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str):\n        \"\"\"\n        Initializes the KiteConnect client.\n\n        Args:\n            api_key: The Kite Connect API key.\n            access_token: The Kite Connect access token for the session.\n\n        Raises:\n            ValueError: If api_key or access_token is missing.\n            kite_ex.TokenException: If the access token is invalid during initialization (e.g., profile fetch).\n        \"\"\"\n        if not api_key or not access_token:\n            logger.error(\"Kite API Key or Access Token not provided.\")\n            raise ValueError(\"Kite API Key and Access Token are required.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        try:\n            self.kite = KiteConnect(api_key=self.api_key)\n            self.kite.set_access_token(self.access_token)\n            logger.info(\"KiteConnect client initialized successfully.\")\n            # Optional: Add a check like fetching profile to ensure token validity early\n            # try:\n            #     self.kite.profile()\n            #     logger.info(\"KiteConnect access token verified.\")\n            # except kite_ex.TokenException as e:\n            #     logger.error(f\"KiteConnect TokenException during initialization: {e}\")\n            #     raise\n        except Exception as e:\n            logger.exception(\"Failed to initialize KiteConnect client.\")\n            raise\n\n    async def _run_sync_kite_call(self, func, *args, **kwargs) -> Union[Dict[str, Any], ErrorResponse]:\n        \"\"\"Runs a synchronous pykiteconnect function in a thread pool.\"\"\"\n        try:\n            # Use asyncio.to_thread if Python 3.9+\n            # result = await asyncio.to_thread(func, *args, **kwargs)\n            loop = asyncio.get_running_loop()\n            result = await loop.run_in_executor(None, lambda: func(*args, **kwargs))\n            logger.debug(f\"Kite API call {func.__name__} successful.\")\n            return result\n        except (kite_ex.InputException,\n                kite_ex.TokenException,\n                kite_ex.PermissionException,\n                kite_ex.OrderException,\n                kite_ex.NetworkException,\n                kite_ex.DataException,\n                kite_ex.GeneralException) as e:\n            error_type = KITE_EXCEPTION_MAP.get(type(e), \"UnknownKiteException\")\n            logger.error(f\"Kite API Error ({error_type}) in {func.__name__}: {e}\", exc_info=False)\n            return ErrorResponse(message=str(e), error_type=error_type)\n        except Exception as e:\n            logger.exception(f\"Unexpected error during Kite API call {func.__name__}: {e}\")\n            return ErrorResponse(message=f\"An unexpected error occurred: {str(e)}\", error_type=\"UnexpectedException\")\n\n    async def place_order_async(self, params: PlaceOrderParams) -> Union[SuccessResponse, ErrorResponse]:\n        \"\"\"Asynchronously places an order using Kite Connect.\"\"\"\n        logger.info(f\"Placing order: {params.tradingsymbol} {params.transaction_type} Qty: {params.quantity}\")\n        # pykiteconnect expects None for optional fields not provided, Pydantic handles this\n        result = await self._run_sync_kite_call(\n            self.kite.place_order,\n            variety=params.variety,\n            exchange=params.exchange,\n            tradingsymbol=params.tradingsymbol,\n            transaction_type=params.transaction_type,\n            quantity=params.quantity,\n            product=params.product,\n            order_type=params.order_type,\n            price=params.price,\n            validity=params.validity,\n            disclosed_quantity=params.disclosed_quantity,\n            trigger_price=params.trigger_price,\n            validity_ttl=params.validity_ttl,\n            iceberg_legs=params.iceberg_legs,\n            iceberg_quantity=params.iceberg_quantity,\n            auction_number=params.auction_number,\n            tag=params.tag\n        )\n        if isinstance(result, ErrorResponse):\n            return result\n        elif isinstance(result, dict) and 'order_id' in result:\n            return SuccessResponse(data=OrderResponse(order_id=result['order_id']))\n        else:\n            logger.error(f\"Unexpected response format from place_order: {result}\")\n            return ErrorResponse(message=\"Unexpected response format from Kite API\", error_type=\"ApiResponseFormatError\")\n\n    async def modify_order_async(self, params: ModifyOrderParams) -> Union[SuccessResponse, ErrorResponse]:\n        \"\"\"Asynchronously modifies a pending order using Kite Connect.\"\"\"\n        logger.info(f\"Modifying order ID: {params.order_id} Variety: {params.variety}\")\n        result = await self._run_sync_kite_call(\n            self.kite.modify_order,\n            variety=params.variety,\n            order_id=params.order_id,\n            parent_order_id=params.parent_order_id,\n            quantity=params.quantity,\n            price=params.price,\n            order_type=params.order_type,\n            trigger_price=params.trigger_price,\n            validity=params.validity,\n            disclosed_quantity=params.disclosed_quantity\n        )\n        if isinstance(result, ErrorResponse):\n            return result\n        elif isinstance(result, dict) and 'order_id' in result:\n             return SuccessResponse(data=OrderResponse(order_id=result['order_id']))\n        else:\n            logger.error(f\"Unexpected response format from modify_order: {result}\")\n            return ErrorResponse(message=\"Unexpected response format from Kite API\", error_type=\"ApiResponseFormatError\")\n\n    async def cancel_order_async(self, params: CancelOrderParams) -> Union[SuccessResponse, ErrorResponse]:\n        \"\"\"Asynchronously cancels a pending order using Kite Connect.\"\"\"\n        logger.info(f\"Cancelling order ID: {params.order_id} Variety: {params.variety}\")\n        result = await self._run_sync_kite_call(\n            self.kite.cancel_order,\n            variety=params.variety,\n            order_id=params.order_id,\n            parent_order_id=params.parent_order_id\n        )\n        if isinstance(result, ErrorResponse):\n            return result\n        elif isinstance(result, dict) and 'order_id' in result:\n             return SuccessResponse(data=OrderResponse(order_id=result['order_id']))\n        else:\n            logger.error(f\"Unexpected response format from cancel_order: {result}\")\n            return ErrorResponse(message=\"Unexpected response format from Kite API\", error_type=\"ApiResponseFormatError\")\n"
    },
    {
      "name": "main.py",
      "content": "import logging\nimport os\nfrom typing import Dict, Any, Union\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import KiteConnectClient\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams, SuccessResponse, ErrorResponse\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Load environment variables from .env file\nload_dotenv()\n\n# --- MCP Server Setup ---\nSERVICE_NAME = \"kite_connect_orders\"\nSERVICE_DESCRIPTION = \"Provides tools to interact with the Kite Connect Orders API (v3) for placing, modifying, cancelling stock market orders. This MCP utilizes the pykiteconnect library.\"\n\nmcp = FastMCP(\n    service_name=SERVICE_NAME,\n    description=SERVICE_DESCRIPTION,\n    version=\"1.0.0\"\n)\n\n# --- Kite Connect Client Initialization ---\ntry:\n    kite_api_key = os.getenv(\"KITE_API_KEY\")\n    kite_access_token = os.getenv(\"KITE_ACCESS_TOKEN\")\n    if not kite_api_key or not kite_access_token:\n        logger.error(\"KITE_API_KEY or KITE_ACCESS_TOKEN environment variables not set.\")\n        # Allow server to start but tools will fail if client is needed\n        kite_client = None\n    else:\n        kite_client = KiteConnectClient(api_key=kite_api_key, access_token=kite_access_token)\nexcept ValueError as e:\n    logger.error(f\"Failed to initialize Kite Client: {e}\")\n    kite_client = None\nexcept Exception as e:\n    logger.exception(\"An unexpected error occurred during Kite Client initialization.\")\n    kite_client = None\n\n# --- MCP Tools Definition ---\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Place an order of a particular variety (regular, amo, co, iceberg, auction).\n    Does not guarantee execution, only placement.\n\n    Args:\n        params: Parameters for placing the order.\n\n    Returns:\n        Dictionary containing the 'order_id' upon successful placement or an error message.\n    \"\"\"\n    if kite_client is None:\n        logger.error(\"place_order tool called, but Kite Client is not initialized.\")\n        return ErrorResponse(message=\"Kite client not initialized. Check environment variables.\", error_type=\"ConfigurationError\").dict()\n\n    logger.info(f\"Received place_order request: {params.dict(exclude_none=True)}\")\n    result = await kite_client.place_order_async(params)\n    return result.dict()\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Modify attributes of a pending regular or cover order (CO).\n\n    Args:\n        params: Parameters for modifying the order.\n\n    Returns:\n        Dictionary containing the 'order_id' of the modified order or an error message.\n    \"\"\"\n    if kite_client is None:\n        logger.error(\"modify_order tool called, but Kite Client is not initialized.\")\n        return ErrorResponse(message=\"Kite client not initialized. Check environment variables.\", error_type=\"ConfigurationError\").dict()\n\n    logger.info(f\"Received modify_order request: {params.dict(exclude_none=True)}\")\n    result = await kite_client.modify_order_async(params)\n    return result.dict()\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Cancel a pending order.\n\n    Args:\n        params: Parameters for cancelling the order.\n\n    Returns:\n        Dictionary containing the 'order_id' of the cancelled order or an error message.\n    \"\"\"\n    if kite_client is None:\n        logger.error(\"cancel_order tool called, but Kite Client is not initialized.\")\n        return ErrorResponse(message=\"Kite client not initialized. Check environment variables.\", error_type=\"ConfigurationError\").dict()\n\n    logger.info(f\"Received cancel_order request: {params.dict(exclude_none=True)}\")\n    result = await kite_client.cancel_order_async(params)\n    return result.dict()\n\n# --- Main Execution --- #\nif __name__ == \"__main__\":\n    import uvicorn\n    logger.info(\"Starting Kite Connect Orders MCP server...\")\n    # To run: uvicorn main:mcp --host 0.0.0.0 --port 8000 --reload\n    # The FastMCP object 'mcp' is the ASGI application\n    uvicorn.run(\"main:mcp\", host=\"0.0.0.0\", port=8000, reload=True)\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.2.0\npykiteconnect==3.9.3\npydantic>=1.9.0,<2.0.0\npython-dotenv>=0.19.0\nuvicorn[standard]>=0.15.0\nhttpx>=0.20.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials\n# Obtain these from your Kite Developer account (https://developers.kite.trade/)\n\n# Your Kite application's API key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# The access token obtained after a successful login flow for the user.\n# This token is typically valid for one day (until midnight).\n# You will need a mechanism to generate/refresh this token daily.\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server built with FastMCP to interact with the Kite Connect Orders API (v3). It allows language models or other agents to place, modify, and cancel stock market orders using the `pykiteconnect` library.\n\n## Features\n\n*   **Place Orders:** Place regular, AMO, CO, Iceberg, and Auction orders.\n*   **Modify Orders:** Modify pending regular or CO orders.\n*   **Cancel Orders:** Cancel pending orders.\n*   **Typed Inputs:** Uses Pydantic models for clear and validated input parameters.\n*   **Error Handling:** Captures and reports specific exceptions from the `pykiteconnect` library.\n*   **Asynchronous:** Leverages `asyncio` for non-blocking operations suitable for MCP environments.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure environment variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect API Key and a valid Access Token:\n        ```dotenv\n        KITE_API_KEY=\"YOUR_API_KEY\"\n        KITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n        ```\n    *   **Important:** The `KITE_ACCESS_TOKEN` is short-lived (typically valid for one day). You need a separate process or mechanism to obtain a new access token daily using the Kite Connect login flow and update the `.env` file or environment variable accordingly before starting the server.\n\n## Running the Server\n\nUse Uvicorn to run the FastMCP application:\n\n```bash\nuvicorn main:mcp --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n*   `--reload`: Automatically restarts the server when code changes are detected (useful for development).\n\nThe MCP server will be available at `http://localhost:8000` (or your machine's IP address).\n\n## API Tools\n\nThe server exposes the following tools:\n\n1.  **`place_order(params: PlaceOrderParams) -> Dict[str, Any]`**\n    *   Description: Places a new order.\n    *   Input: `PlaceOrderParams` model (see `models.py` for fields like `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, etc.).\n    *   Output: A dictionary containing `status: 'success'` and `data: {'order_id': '...'}` on success, or `status: 'error'` with details on failure.\n\n2.  **`modify_order(params: ModifyOrderParams) -> Dict[str, Any]`**\n    *   Description: Modifies an existing pending order.\n    *   Input: `ModifyOrderParams` model (see `models.py` for fields like `variety`, `order_id`, `quantity`, `price`, etc.).\n    *   Output: A dictionary containing `status: 'success'` and `data: {'order_id': '...'}` on success, or `status: 'error'` with details on failure.\n\n3.  **`cancel_order(params: CancelOrderParams) -> Dict[str, Any]`**\n    *   Description: Cancels an existing pending order.\n    *   Input: `CancelOrderParams` model (see `models.py` for fields like `variety`, `order_id`).\n    *   Output: A dictionary containing `status: 'success'` and `data: {'order_id': '...'}` on success, or `status: 'error'` with details on failure.\n\n## Error Handling\n\nThe server catches exceptions raised by the `pykiteconnect` library (e.g., `TokenException`, `OrderException`, `InputException`) and returns a structured error response:\n\n```json\n{\n  \"status\": \"error\",\n  \"message\": \"Invalid login credentials.\",\n  \"error_type\": \"TokenException\"\n}\n```\n\n## Rate Limits\n\nThe Kite Connect API has rate limits (e.g., 3 requests per second for order placement/modification/cancellation). This MCP server *does not* implement explicit rate limiting itself. Calls exceeding the Kite API limits will result in errors returned by the API (`NetworkException` or similar). Ensure any client using this MCP respects these limits.\n\n## Disclaimer\n\nTrading in financial markets involves risk. This software is provided \"as is\" without warranty of any kind. Use it at your own risk and ensure you understand the implications of automated trading.\n"
    }
  ]
}
{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, List\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom models import (\n    PlaceOrderParams,\n    ModifyOrderParams,\n    CancelOrderParams,\n    GetOrdersParams,\n    OrderIDResponse,\n    Order,\n    KiteErrorResponse\n)\nfrom client import ZerodhaKiteClient, KiteApiException\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"ZerodhaKiteConnectOrders\",\n    description=\"MCP service for managing orders (placing, modifying, cancelling, retrieving) and trades using the Zerodha Kite Connect v3 API.\"\n)\n\n# Initialize API Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables or .env file.\")\n    # Depending on the desired behavior, you might want to exit or raise an exception here.\n    # For now, we'll let the client initialization fail if credentials are missing.\n\nkite_client = ZerodhaKiteClient(api_key=api_key, access_token=access_token, base_url=base_url)\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Place an order of a particular variety (regular, amo, co, iceberg, auction).\n\n    Args:\n        params: Order placement parameters.\n\n    Returns:\n        A dictionary containing the 'order_id' of the placed order or an error dictionary.\n    \"\"\"\n    try:\n        logger.info(f\"Placing order with params: {params.dict(exclude_none=True)}\")\n        response_data = await kite_client.place_order(params)\n        # Ensure the response format matches the expected OrderIDResponse\n        if isinstance(response_data, dict) and \"order_id\" in response_data.get(\"data\", {}):\n             result = OrderIDResponse(order_id=response_data[\"data\"][\"order_id\"])\n             logger.info(f\"Order placed successfully: {result.order_id}\")\n             return result.dict()\n        else:\n            logger.error(f\"Unexpected response format from place_order: {response_data}\")\n            return KiteErrorResponse(error_type=\"UnexpectedResponse\", message=\"Unexpected response format received from API.\").dict()\n\n    except KiteApiException as e:\n        logger.error(f\"API Error placing order: {e}\")\n        return KiteErrorResponse(error_type=e.error_type, message=e.message, status_code=e.status_code).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error placing order: {e}\")\n        return KiteErrorResponse(error_type=\"InternalServerError\", message=str(e)).dict()\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Modify an open or pending order.\n\n    Args:\n        params: Order modification parameters.\n\n    Returns:\n        A dictionary containing the 'order_id' of the modified order or an error dictionary.\n    \"\"\"\n    try:\n        logger.info(f\"Modifying order {params.order_id} with params: {params.dict(exclude={'variety', 'order_id'}, exclude_none=True)}\")\n        response_data = await kite_client.modify_order(params)\n        # Ensure the response format matches the expected OrderIDResponse\n        if isinstance(response_data, dict) and \"order_id\" in response_data.get(\"data\", {}):\n            result = OrderIDResponse(order_id=response_data[\"data\"][\"order_id\"])\n            logger.info(f\"Order modified successfully: {result.order_id}\")\n            return result.dict()\n        else:\n            logger.error(f\"Unexpected response format from modify_order: {response_data}\")\n            return KiteErrorResponse(error_type=\"UnexpectedResponse\", message=\"Unexpected response format received from API.\").dict()\n\n    except KiteApiException as e:\n        logger.error(f\"API Error modifying order: {e}\")\n        return KiteErrorResponse(error_type=e.error_type, message=e.message, status_code=e.status_code).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error modifying order: {e}\")\n        return KiteErrorResponse(error_type=\"InternalServerError\", message=str(e)).dict()\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Cancel an open or pending order.\n\n    Args:\n        params: Order cancellation parameters.\n\n    Returns:\n        A dictionary containing the 'order_id' of the cancelled order or an error dictionary.\n    \"\"\"\n    try:\n        logger.info(f\"Cancelling order {params.order_id} (variety: {params.variety.value}) with parent_id: {params.parent_order_id}\")\n        response_data = await kite_client.cancel_order(params)\n        # Ensure the response format matches the expected OrderIDResponse\n        if isinstance(response_data, dict) and \"order_id\" in response_data.get(\"data\", {}):\n            result = OrderIDResponse(order_id=response_data[\"data\"][\"order_id\"])\n            logger.info(f\"Order cancelled successfully: {result.order_id}\")\n            return result.dict()\n        else:\n            logger.error(f\"Unexpected response format from cancel_order: {response_data}\")\n            return KiteErrorResponse(error_type=\"UnexpectedResponse\", message=\"Unexpected response format received from API.\").dict()\n\n    except KiteApiException as e:\n        logger.error(f\"API Error cancelling order: {e}\")\n        return KiteErrorResponse(error_type=e.error_type, message=e.message, status_code=e.status_code).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error cancelling order: {e}\")\n        return KiteErrorResponse(error_type=\"InternalServerError\", message=str(e)).dict()\n\n@mcp.tool()\nasync def get_orders(params: GetOrdersParams) -> Dict[str, Any]:\n    \"\"\"\n    Retrieve the list of all orders (open, pending, executed) for the day.\n\n    Args:\n        params: Get orders parameters (currently empty).\n\n    Returns:\n        A dictionary containing a list of order objects or an error dictionary.\n    \"\"\"\n    try:\n        logger.info(\"Retrieving orders\")\n        orders_data = await kite_client.get_orders()\n        # Basic validation: check if it's a list\n        if isinstance(orders_data, list):\n            # Attempt to parse each item into an Order model, logging errors for invalid items\n            parsed_orders = []\n            for order_item in orders_data:\n                try:\n                    # Ensure order_item is a dict before parsing\n                    if isinstance(order_item, dict):\n                        parsed_orders.append(Order(**order_item).dict())\n                    else:\n                         logger.warning(f\"Skipping non-dict item in orders list: {order_item}\")\n                except Exception as parse_error:\n                    logger.warning(f\"Failed to parse order item: {order_item}. Error: {parse_error}\")\n                    # Optionally include partially parsed or raw data if needed\n\n            logger.info(f\"Retrieved {len(parsed_orders)} orders successfully.\")\n            return {\"orders\": parsed_orders} # Wrap the list in a dictionary\n        else:\n            logger.error(f\"Unexpected response format from get_orders: {orders_data}\")\n            return KiteErrorResponse(error_type=\"UnexpectedResponse\", message=\"Expected a list of orders, but received a different format.\").dict()\n\n    except KiteApiException as e:\n        logger.error(f\"API Error retrieving orders: {e}\")\n        return KiteErrorResponse(error_type=e.error_type, message=e.message, status_code=e.status_code).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error retrieving orders: {e}\")\n        return KiteErrorResponse(error_type=\"InternalServerError\", message=str(e)).dict()\n\n\nif __name__ == \"__main__\":\n    # Note: FastMCP().run() starts the Uvicorn server.\n    # You might need to configure host and port depending on your deployment.\n    # Example: mcp.run(host=\"0.0.0.0\", port=8000)\n    mcp.run()\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field, validator\nfrom typing import Optional, List, Dict, Any\nfrom enum import Enum\n\n# --- Enums based on Kite Connect API documentation ---\n\nclass OrderVariety(str, Enum):\n    REGULAR = \"regular\"\n    AMO = \"amo\"\n    CO = \"co\"\n    ICEBERG = \"iceberg\"\n    AUCTION = \"auction\"\n\nclass ExchangeType(str, Enum):\n    NSE = \"NSE\"\n    BSE = \"BSE\"\n    NFO = \"NFO\"\n    CDS = \"CDS\"\n    BCD = \"BCD\"\n    MCX = \"MCX\"\n\nclass TransactionType(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n\nclass OrderType(str, Enum):\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n    SL = \"SL\"\n    SL_M = \"SL-M\"\n\nclass ProductType(str, Enum):\n    CNC = \"CNC\"  # Cash & Carry for equity\n    NRML = \"NRML\" # Normal for F&O, CDS, MCX\n    MIS = \"MIS\"  # Margin Intraday Squareoff\n    MTF = \"MTF\" # Margin Trading Facility\n\nclass OrderValidity(str, Enum):\n    DAY = \"DAY\"\n    IOC = \"IOC\"  # Immediate or Cancel\n    TTL = \"TTL\"  # Time to Live (in minutes)\n\nclass OrderStatus(str, Enum):\n    # Common statuses, might need expansion based on API details\n    OPEN = \"OPEN\"\n    COMPLETE = \"COMPLETE\"\n    CANCELLED = \"CANCELLED\"\n    REJECTED = \"REJECTED\"\n    MODIFY_PENDING = \"MODIFY PENDING\"\n    # Add other potential statuses\n\n# --- Input Models for Tools ---\n\nclass PlaceOrderParams(BaseModel):\n    variety: OrderVariety = Field(..., description=\"Order variety (regular, amo, co, iceberg, auction)\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., INFY, NIFTY23JUL17500CE)\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange (NSE, BSE, NFO, CDS, BCD, MCX)\")\n    transaction_type: TransactionType = Field(..., description=\"BUY or SELL\")\n    order_type: OrderType = Field(..., description=\"Order type (MARKET, LIMIT, SL, SL-M)\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact\")\n    product: ProductType = Field(..., description=\"Margin product to use (CNC, NRML, MIS, MTF)\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (required for LIMIT orders)\")\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (required for SL, SL-M orders)\")\n    disclosed_quantity: Optional[int] = Field(None, ge=0, description=\"Quantity to disclose publicly (for equity trades)\")\n    validity: OrderValidity = Field(..., description=\"Order validity (DAY, IOC, TTL)\")\n    validity_ttl: Optional[int] = Field(None, gt=0, description=\"Order life span in minutes for TTL validity orders\")\n    iceberg_legs: Optional[int] = Field(None, ge=2, le=10, description=\"Total number of legs for iceberg order type (2-10)\")\n    iceberg_quantity: Optional[int] = Field(None, gt=0, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs)\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"An optional tag to apply to an order (alphanumeric, max 20 chars)\")\n\n    @validator('price', always=True)\n    def check_price_for_limit(cls, v, values):\n        if values.get('order_type') == OrderType.LIMIT and v is None:\n            raise ValueError('Price is required for LIMIT orders')\n        if values.get('order_type') == OrderType.MARKET and v is not None:\n            # Kite API might ignore price for market orders, but good practice to disallow\n            raise ValueError('Price should not be provided for MARKET orders')\n        return v\n\n    @validator('trigger_price', always=True)\n    def check_trigger_price_for_sl(cls, v, values):\n        if values.get('order_type') in [OrderType.SL, OrderType.SL_M] and v is None:\n            raise ValueError('Trigger price is required for SL and SL-M orders')\n        return v\n\n    @validator('validity_ttl', always=True)\n    def check_validity_ttl(cls, v, values):\n        if values.get('validity') == OrderValidity.TTL and v is None:\n            raise ValueError('validity_ttl is required for TTL validity')\n        if values.get('validity') != OrderValidity.TTL and v is not None:\n            raise ValueError('validity_ttl should only be provided for TTL validity')\n        return v\n\n    @validator('iceberg_legs', 'iceberg_quantity', always=True)\n    def check_iceberg_params(cls, v, values, field):\n        is_iceberg = values.get('variety') == OrderVariety.ICEBERG\n        if is_iceberg and field.name == 'iceberg_legs' and v is None:\n            raise ValueError('iceberg_legs is required for iceberg orders')\n        if is_iceberg and field.name == 'iceberg_quantity' and v is None:\n             # Note: Kite API might calculate this automatically if not provided, but explicit is often better.\n             # Check API docs if this is strictly required or can be derived.\n             # raise ValueError('iceberg_quantity is required for iceberg orders')\n             pass # Assuming API might derive if not provided\n        if not is_iceberg and v is not None:\n            raise ValueError(f'{field.name} should only be provided for iceberg orders')\n        return v\n\nclass ModifyOrderParams(BaseModel):\n    variety: OrderVariety = Field(..., description=\"Order variety (regular, co)\") # Note: API docs say regular, co, amo, iceberg, auction can be modified\n    order_id: str = Field(..., description=\"The ID of the order to modify\")\n    parent_order_id: Optional[str] = Field(None, description=\"Parent order id for second leg CO order modification\")\n    order_type: Optional[OrderType] = Field(None, description=\"New order type (only applicable for regular variety - check API docs for others)\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity (only applicable for regular variety - check API docs for others)\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders)\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, CO orders)\")\n    disclosed_quantity: Optional[int] = Field(None, ge=0, description=\"New disclosed quantity (only applicable for regular variety - check API docs for others)\")\n    validity: Optional[OrderValidity] = Field(None, description=\"New validity (only applicable for regular variety, DAY or IOC - check API docs for others)\")\n\n    @validator('validity')\n    def check_validity_options(cls, v):\n        if v not in [None, OrderValidity.DAY, OrderValidity.IOC]:\n            # Based on implementation plan, but double-check API docs if TTL is allowed for modification\n            raise ValueError('Validity for modification can only be DAY or IOC (or None)')\n        return v\n\nclass CancelOrderParams(BaseModel):\n    variety: OrderVariety = Field(..., description=\"Order variety (regular, amo, co, iceberg, auction)\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel\")\n    parent_order_id: Optional[str] = Field(None, description=\"Parent order id for second leg CO order cancellation\")\n\nclass GetOrdersParams(BaseModel):\n    # No parameters needed for fetching all orders for the day as per plan\n    pass\n\n# --- Return Models ---\n\nclass OrderIDResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique ID of the order.\")\n\nclass Order(BaseModel):\n    # Based on common fields in Kite Connect orderbook response\n    # Adjust fields based on actual API response structure\n    order_id: Optional[str] = None\n    parent_order_id: Optional[str] = None\n    exchange_order_id: Optional[str] = None\n    status: Optional[str] = None # Consider using OrderStatus enum if comprehensive\n    status_message: Optional[str] = None\n    status_message_raw: Optional[str] = None\n    order_timestamp: Optional[str] = None # Consider datetime type\n    exchange_timestamp: Optional[str] = None # Consider datetime type\n    variety: Optional[str] = None # Consider OrderVariety enum\n    exchange: Optional[str] = None # Consider ExchangeType enum\n    tradingsymbol: Optional[str] = None\n    instrument_token: Optional[int] = None\n    order_type: Optional[str] = None # Consider OrderType enum\n    transaction_type: Optional[str] = None # Consider TransactionType enum\n    validity: Optional[str] = None # Consider OrderValidity enum\n    product: Optional[str] = None # Consider ProductType enum\n    quantity: Optional[int] = None\n    disclosed_quantity: Optional[int] = None\n    price: Optional[float] = None\n    trigger_price: Optional[float] = None\n    average_price: Optional[float] = None\n    filled_quantity: Optional[int] = None\n    pending_quantity: Optional[int] = None\n    cancelled_quantity: Optional[int] = None\n    tag: Optional[str] = None\n    meta: Optional[Dict[str, Any]] = None\n    # Add any other relevant fields from the API response\n\nclass KiteErrorResponse(BaseModel):\n    error_type: str = Field(..., description=\"Category of the error.\")\n    message: str = Field(..., description=\"Detailed error message.\")\n    status_code: Optional[int] = Field(None, description=\"HTTP status code associated with the error.\")\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nfrom typing import Dict, Any, Optional, List\nimport json\n\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams\n\nlogger = logging.getLogger(__name__)\n\n# Custom Exception for API specific errors\nclass KiteApiException(Exception):\n    def __init__(self, message: str, status_code: Optional[int] = None, error_type: str = \"APIError\"):\n        self.message = message\n        self.status_code = status_code\n        self.error_type = error_type\n        super().__init__(f\"[{error_type}/{status_code}] {message}\")\n\nclass ZerodhaKiteClient:\n    \"\"\"Asynchronous client for interacting with the Zerodha Kite Connect v3 API.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\"):\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Default for many Kite POST/PUT\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=30.0,  # Set a reasonable timeout\n            event_hooks={'response': [self._log_response], 'request': [self._log_request]}\n        )\n\n    async def _log_request(self, request: httpx.Request):\n        # Be careful logging request body if it contains sensitive info\n        # For form data, it might be okay, but avoid logging raw auth headers\n        try:\n            body = await request.aread()\n            logger.debug(f\"Request: {request.method} {request.url} - Headers: {request.headers} - Body: {body.decode()}\")\n        except Exception:\n             logger.debug(f\"Request: {request.method} {request.url} - Headers: {request.headers}\")\n\n    async def _log_response(self, response: httpx.Response):\n        await response.aread() # Ensure response body is loaded for logging\n        logger.debug(f\"Response: {response.request.method} {response.request.url} - Status: {response.status_code} - Body: {response.text}\")\n\n    async def _request(self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any] | List[Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite API.\"\"\"\n        try:\n            response = await self.client.request(method, endpoint, params=params, data=data)\n\n            # Check for HTTP errors\n            response.raise_for_status()\n\n            # Parse JSON response\n            response_data = response.json()\n\n            # Check for Kite API specific errors in the response body\n            if response_data.get(\"status\") == \"error\":\n                error_type = response_data.get(\"error_type\", \"UnknownAPIError\")\n                message = response_data.get(\"message\", \"An unknown API error occurred.\")\n                logger.error(f\"Kite API Error: Type={error_type}, Message={message}\")\n                raise KiteApiException(message=message, status_code=response.status_code, error_type=error_type)\n\n            # Return the data part of the response\n            return response_data.get(\"data\", response_data) # Some endpoints might not have 'data' wrapper\n\n        except httpx.HTTPStatusError as e:\n            status_code = e.response.status_code\n            error_type = f\"HTTP{status_code}\"\n            message = f\"HTTP Error {status_code}: {e.response.text[:500]}...\" # Limit error message size\n            # Try parsing Kite error from body even on HTTP error status\n            try:\n                error_data = e.response.json()\n                if error_data.get(\"status\") == \"error\":\n                    error_type = error_data.get(\"error_type\", error_type)\n                    message = error_data.get(\"message\", message)\n            except (json.JSONDecodeError, AttributeError):\n                pass # Keep the original HTTP error message\n\n            logger.error(f\"HTTP Error during API request to {e.request.url}: {status_code} - {message}\")\n            # Map common HTTP errors to Kite error types based on documentation/convention\n            if status_code == 400:\n                error_type = \"InputException\" # Bad request, likely invalid params\n            elif status_code == 401 or status_code == 403:\n                error_type = \"AuthenticationError\" # Unauthorized or Forbidden\n            elif status_code == 429:\n                error_type = \"RateLimitError\"\n            elif status_code >= 500:\n                error_type = \"GeneralException\" # Server-side errors\n\n            raise KiteApiException(message=message, status_code=status_code, error_type=error_type) from e\n\n        except httpx.RequestError as e:\n            logger.error(f\"Network or Request Error during API request to {e.request.url}: {e}\")\n            raise KiteApiException(message=f\"Network error: {e}\", error_type=\"NetworkException\") from e\n        except json.JSONDecodeError as e:\n            logger.error(f\"Failed to decode JSON response: {e}\")\n            raise KiteApiException(message=\"Invalid JSON response from API\", error_type=\"DataException\") from e\n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during API request: {e}\")\n            raise KiteApiException(message=f\"An unexpected error occurred: {str(e)}\", error_type=\"InternalError\") from e\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, Any]:\n        \"\"\"Place an order.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}\"\n        # Convert Pydantic model to dict, excluding None values\n        data = params.dict(exclude={'variety'}, exclude_none=True)\n        # Convert boolean/numeric types to string if required by API (check docs)\n        # For Kite, form data typically handles types correctly, but explicit conversion might be safer\n        for key, value in data.items():\n            if isinstance(value, (int, float)):\n                data[key] = str(value)\n            elif isinstance(value, Enum):\n                 data[key] = value.value # Ensure enums are sent as their string values\n\n        logger.info(f\"Placing order: POST {endpoint} with data: {data}\")\n        return await self._request(\"POST\", endpoint, data=data)\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, Any]:\n        \"\"\"Modify an existing order.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}/{params.order_id}\"\n        data = params.dict(exclude={'variety', 'order_id'}, exclude_none=True)\n        # Convert types if needed\n        for key, value in data.items():\n            if isinstance(value, (int, float)):\n                data[key] = str(value)\n            elif isinstance(value, Enum):\n                 data[key] = value.value\n\n        logger.info(f\"Modifying order: PUT {endpoint} with data: {data}\")\n        return await self._request(\"PUT\", endpoint, data=data)\n\n    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, Any]:\n        \"\"\"Cancel an existing order.\"\"\"\n        endpoint = f\"/orders/{params.variety.value}/{params.order_id}\"\n        query_params = {}\n        if params.parent_order_id:\n            query_params[\"parent_order_id\"] = params.parent_order_id\n\n        logger.info(f\"Cancelling order: DELETE {endpoint} with params: {query_params}\")\n        return await self._request(\"DELETE\", endpoint, params=query_params)\n\n    async def get_orders(self) -> List[Dict[str, Any]]:\n        \"\"\"Retrieve the list of orders for the day.\"\"\"\n        endpoint = \"/orders\"\n        logger.info(f\"Getting orders: GET {endpoint}\")\n        result = await self._request(\"GET\", endpoint)\n        if isinstance(result, list):\n            return result\n        else:\n            logger.error(f\"Expected list from get_orders, got {type(result)}\")\n            raise KiteApiException(message=\"API returned unexpected data format for orders.\", error_type=\"DataException\")\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"ZerodhaKiteClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=1.9.0,<2.0.0\nhttpx>=0.23.0\npython-dotenv>=0.20.0\nuvicorn>=0.18.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Zerodha Kite Connect API Credentials and Configuration\n# Obtain these from https://developers.kite.trade/\n\n# Your Kite Connect API key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# The access token obtained after a successful login flow (valid for one day)\n# You need a mechanism to generate/refresh this token daily.\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# Base URL for the Kite Connect API (usually doesn't need changing)\nKITE_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Zerodha Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect v3 API, specifically focusing on order management functionalities.\n\nIt allows language models or other applications to place, modify, cancel, and retrieve orders through a standardized MCP interface, powered by FastMCP.\n\n## Features\n\nThis MCP server exposes the following tools:\n\n*   **`place_order`**: Place an order of a particular variety (regular, amo, co, iceberg, auction).\n*   **`modify_order`**: Modify an open or pending order.\n*   **`cancel_order`**: Cancel an open or pending order.\n*   **`get_orders`**: Retrieve the list of all orders (open, pending, executed) for the day.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Zerodha Kite Connect API credentials:\n        *   `KITE_API_KEY`: Your application's API key.\n        *   `KITE_ACCESS_TOKEN`: The access token generated after a user logs in via Kite Connect. **Note:** This token is typically valid only for the day it's generated. You will need a separate process (e.g., a manual login flow or an automated mechanism if feasible) to obtain a valid `access_token` each day before running the server.\n        *   `KITE_BASE_URL`: The base URL for the API (default is usually correct).\n\n## Running the Server\n\nOnce the setup is complete, you can run the MCP server using Uvicorn:\n\n```bash\npython main.py\n# Or directly with uvicorn for more control:\n# uvicorn main:mcp.app --reload --host 0.0.0.0 --port 8000\n```\n\nThe server will start, typically on `http://127.0.0.1:8000` (unless configured otherwise).\n\n## API Client (`client.py`)\n\nThe `client.py` file contains the `ZerodhaKiteClient` class responsible for:\n\n*   Making asynchronous requests to the Kite Connect API.\n*   Handling authentication headers (`Authorization`, `X-Kite-Version`).\n*   Parsing responses and checking for API-specific errors.\n*   Mapping HTTP status codes and API errors to a custom `KiteApiException`.\n*   Basic request/response logging.\n\n## Models (`models.py`)\n\nThe `models.py` file defines Pydantic models for:\n\n*   **Enums:** Representing fixed sets of values used by the API (e.g., `OrderVariety`, `TransactionType`, `ExchangeType`).\n*   **Input Parameters:** Defining the expected structure and validation rules for data passed to each MCP tool (e.g., `PlaceOrderParams`, `ModifyOrderParams`).\n*   **Return Types:** Defining the structure of successful responses (e.g., `OrderIDResponse`, `Order`).\n*   **Error Response:** A standard structure (`KiteErrorResponse`) for returning errors from the MCP tools.\n\n## Error Handling\n\nThe server attempts to catch errors at different levels:\n\n1.  **HTTP Errors:** The `ZerodhaKiteClient` catches `httpx.HTTPStatusError` and maps common status codes (4xx, 5xx) to `KiteApiException` with appropriate error types (e.g., `AuthenticationError`, `InputException`, `GeneralException`, `RateLimitError`).\n2.  **Kite API Errors:** If the API returns a `200 OK` status but includes an error message in the response body (`{\"status\": \"error\", ...}`), the client parses this and raises a `KiteApiException`.\n3.  **Network/Request Errors:** `httpx.RequestError` is caught for issues like timeouts or connection problems, resulting in a `NetworkException`.\n4.  **Validation Errors:** Pydantic models in `models.py` perform initial validation on input parameters.\n5.  **Unexpected Errors:** Generic exceptions are caught in the MCP tool implementations and returned as a `InternalServerError` or similar.\n\nFailed tool executions return a JSON dictionary conforming to the `KiteErrorResponse` model.\n\n## Important Considerations\n\n*   **Access Token Management:** The biggest challenge with Kite Connect is managing the daily `access_token`. This MCP server *assumes* a valid token is provided via the environment variable. You need a separate process to handle the Kite Connect login flow and update the `KITE_ACCESS_TOKEN` daily.\n*   **Rate Limiting:** The Kite API enforces rate limits (e.g., 10 requests/second for orders). The client currently handles `429 Too Many Requests` errors by raising a `RateLimitError`. Implement retry logic or client-side delays if needed, although relying on the API's 429 response is often sufficient.\n*   **Security:** Never commit your `.env` file with real credentials to version control. Ensure the server running this MCP is secured appropriately.\n"
    }
  ]
}
{
  "files": [
    {
      "name": "main.py",
      "content": "import logging\nimport os\nfrom typing import Dict, Any\n\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\n\nfrom client import KiteConnectClient, KiteConnectError\nfrom models import PlaceOrderParams, ModifyOrderParams, OrderResponse\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectOrders\",\n    description=\"Provides tools to manage trading orders (place, modify) using the Kite Connect API v3.\"\n)\n\n# Initialize Kite Connect Client\nAPI_KEY = os.getenv(\"KITE_API_KEY\")\nACCESS_TOKEN = os.getenv(\"KITE_ACCESS_TOKEN\")\nAPI_BASE_URL = os.getenv(\"KITE_API_BASE_URL\", \"https://api.kite.trade\")\n\nif not API_KEY or not ACCESS_TOKEN:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n    # Optionally raise an error or exit if credentials are critical\n    # raise ValueError(\"API Key and Access Token are required.\")\n    # For now, let it proceed but client initialization will likely fail later or be non-functional\n\nkite_client = KiteConnectClient(api_key=API_KEY, access_token=ACCESS_TOKEN, base_url=API_BASE_URL)\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Places an order of a specified variety (regular, amo, co, iceberg, auction).\n\n    Args:\n        params: Parameters for placing the order.\n\n    Returns:\n        A dictionary containing the 'order_id' of the successfully placed order or an error message.\n    \"\"\"\n    logger.info(f\"Attempting to place order: {params.tradingsymbol} {params.transaction_type} Qty: {params.quantity}\")\n    try:\n        result = await kite_client.place_order_async(params)\n        logger.info(f\"Successfully placed order {result['order_id']} for {params.tradingsymbol}\")\n        # Ensure the response matches the expected Pydantic model\n        return OrderResponse(**result).dict()\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error placing order for {params.tradingsymbol}: {e}\")\n        return {\"error\": str(e), \"error_type\": e.__class__.__name__}\n    except Exception as e:\n        logger.exception(f\"Unexpected error placing order for {params.tradingsymbol}: {e}\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\", \"error_type\": \"ServerError\"}\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modifies attributes of a pending order (regular, co, amo, iceberg, auction).\n\n    Args:\n        params: Parameters for modifying the order.\n\n    Returns:\n        A dictionary containing the 'order_id' of the modified order or an error message.\n    \"\"\"\n    logger.info(f\"Attempting to modify order: {params.order_id} (Variety: {params.variety})\")\n    try:\n        result = await kite_client.modify_order_async(params)\n        logger.info(f\"Successfully modified order {result['order_id']}\")\n        # Ensure the response matches the expected Pydantic model\n        return OrderResponse(**result).dict()\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error modifying order {params.order_id}: {e}\")\n        return {\"error\": str(e), \"error_type\": e.__class__.__name__}\n    except Exception as e:\n        logger.exception(f\"Unexpected error modifying order {params.order_id}: {e}\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\", \"error_type\": \"ServerError\"}\n\nif __name__ == \"__main__\":\n    if not API_KEY or not ACCESS_TOKEN:\n        print(\"ERROR: KITE_API_KEY and KITE_ACCESS_TOKEN environment variables are not set.\")\n        print(\"Please create a .env file or set them in your environment.\")\n    else:\n        logger.info(f\"Starting KiteConnectOrders MCP server...\")\n        # Note: FastMCP's run() method handles the Uvicorn server startup.\n        # You might need to adjust host and port if needed, e.g., mcp.run(host=\"0.0.0.0\", port=8000)\n        mcp.run()\n"
    },
    {
      "name": "models.py",
      "content": "from typing import Optional, Literal, Dict\nfrom pydantic import BaseModel, Field, validator, root_validator\n\n# Define common types used across models\nOrderVariety = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nExchange = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\n\n    Corresponds to the input needed for the place_order tool.\n    \"\"\"\n    variety: OrderVariety = Field(..., description=\"The variety of the order.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., 'ACC', 'SBIN').\")\n    exchange: Exchange = Field(..., description=\"Name of the exchange.\")\n    transaction_type: TransactionType = Field(..., description=\"Transaction type.\")\n    order_type: OrderType = Field(..., description=\"Type of order.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact. Must be positive.\")\n    product: ProductType = Field(..., description=\"Product type (CNC, NRML, MIS, MTF).\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders. Required if order_type is LIMIT or SL.\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders. Required if order_type is SL or SL-M. For CO orders, this is the stoploss trigger price.\")\n    disclosed_quantity: Optional[int] = Field(None, ge=0, description=\"Quantity to disclose publicly (for equity trades). Defaults to 0 if None.\")\n    validity: ValidityType = Field(..., description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders. Required if validity is TTL.\")\n    iceberg_legs: Optional[int] = Field(None, ge=2, le=10, description=\"Total number of legs for iceberg order (2-10). Required for variety='iceberg'.\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg (quantity/iceberg_legs). Auto-calculated if not provided for variety='iceberg'.\")\n    auction_number: Optional[str] = Field(None, description=\"Unique identifier for a specific auction. Required for variety='auction'.\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"Optional tag for the order (alphanumeric, max 20 chars).\")\n\n    @root_validator(pre=False, skip_on_failure=True)\n    def check_conditional_required_fields(cls, values):\n        order_type = values.get('order_type')\n        price = values.get('price')\n        trigger_price = values.get('trigger_price')\n        validity = values.get('validity')\n        validity_ttl = values.get('validity_ttl')\n        variety = values.get('variety')\n        iceberg_legs = values.get('iceberg_legs')\n        auction_number = values.get('auction_number')\n\n        if order_type in ['LIMIT', 'SL'] and price is None:\n            raise ValueError(\"price is required for LIMIT and SL order types\")\n        if order_type in ['SL', 'SL-M'] and trigger_price is None:\n            raise ValueError(\"trigger_price is required for SL and SL-M order types\")\n        if variety == 'co' and trigger_price is None:\n            # CO orders require a trigger price (stoploss)\n            raise ValueError(\"trigger_price is required for CO variety\")\n        if validity == 'TTL' and validity_ttl is None:\n            raise ValueError(\"validity_ttl is required when validity is TTL\")\n        if variety == 'iceberg' and iceberg_legs is None:\n            raise ValueError(\"iceberg_legs is required for iceberg variety\")\n        if variety == 'auction' and auction_number is None:\n            raise ValueError(\"auction_number is required for auction variety\")\n\n        return values\n\n    class Config:\n        use_enum_values = True # Ensure Literal values are used directly\n\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Parameters for modifying a pending order.\n\n    Corresponds to the input needed for the modify_order tool.\n    \"\"\"\n    variety: OrderVariety = Field(..., description=\"The variety of the order to modify.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    order_type: Optional[OrderType] = Field(None, description=\"New order type (only for regular variety).\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity (only for regular variety). Must be positive if provided.\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders - regular/co variety).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, CO orders).\")\n    disclosed_quantity: Optional[int] = Field(None, ge=0, description=\"New disclosed quantity (only for regular variety, equity). Defaults to 0 if None.\")\n    validity: Optional[ValidityType] = Field(None, description=\"New validity (only for regular variety).\")\n\n    @root_validator(pre=False, skip_on_failure=True)\n    def check_modify_conditions(cls, values):\n        variety = values.get('variety')\n        order_type = values.get('order_type')\n        quantity = values.get('quantity')\n        disclosed_quantity = values.get('disclosed_quantity')\n        validity = values.get('validity')\n\n        # Restrictions based on Kite Connect documentation for modifications\n        if variety != 'regular':\n            if order_type is not None:\n                raise ValueError(f\"order_type cannot be modified for {variety} variety\")\n            if quantity is not None:\n                raise ValueError(f\"quantity cannot be modified for {variety} variety\")\n            if disclosed_quantity is not None:\n                raise ValueError(f\"disclosed_quantity cannot be modified for {variety} variety\")\n            if validity is not None:\n                raise ValueError(f\"validity cannot be modified for {variety} variety\")\n\n        return values\n\n    class Config:\n        use_enum_values = True\n\n\nclass OrderResponse(BaseModel):\n    \"\"\"Standard response structure for successful order placement or modification.\n\n    Contains the order ID.\n    \"\"\"\n    order_id: str = Field(..., description=\"The unique identifier for the order.\")\n"
    },
    {
      "name": "client.py",
      "content": "import logging\nfrom typing import Dict, Any, Optional\n\nimport httpx\nfrom tenacity import retry, stop_after_attempt, wait_fixed, retry_if_exception_type\n\nfrom models import PlaceOrderParams, ModifyOrderParams\n\nlogger = logging.getLogger(__name__)\n\n# --- Custom Exceptions --- #\n\nclass KiteConnectError(Exception):\n    \"\"\"Base exception for Kite Connect API errors.\"\"\"\n    def __init__(self, message=\"An API error occurred\", status_code=None, error_type=None):\n        self.status_code = status_code\n        self.error_type = error_type\n        super().__init__(f\"{error_type or 'API Error'} (HTTP {status_code}): {message}\")\n\nclass AuthenticationError(KiteConnectError):\n    \"\"\"Error related to authentication (invalid API key, access token).\"\"\"\n    pass\n\nclass InvalidInputError(KiteConnectError):\n    \"\"\"Error due to invalid input parameters.\"\"\"\n    pass\n\nclass InsufficientFundsError(KiteConnectError):\n    \"\"\"Error when there are not enough funds for the order.\"\"\"\n    pass\n\nclass NetworkError(KiteConnectError):\n    \"\"\"Error related to network connectivity issues.\"\"\"\n    pass\n\nclass RateLimitError(KiteConnectError):\n    \"\"\"Error when API rate limits are exceeded.\"\"\"\n    pass\n\nclass ExchangeError(KiteConnectError):\n    \"\"\"Error reported by the exchange.\"\"\"\n    pass\n\nclass OrderNotFoundError(KiteConnectError):\n    \"\"\"Error when trying to modify/cancel a non-existent order.\"\"\"\n    pass\n\nclass OrderNotModifiableError(KiteConnectError):\n    \"\"\"Error when trying to modify an order that is not in a modifiable state.\"\"\"\n    pass\n\nclass GeneralAPIError(KiteConnectError):\n    \"\"\"General or unclassified API errors.\"\"\"\n    pass\n\n# Mapping from Kite error types (strings) to custom exception classes\nKITE_ERROR_MAP = {\n    # General\n    \"InputException\": InvalidInputError,\n    \"TokenException\": AuthenticationError,\n    \"GeneralException\": GeneralAPIError,\n    \"NetworkException\": NetworkError, # Assuming httpx might raise this, map Kite's equivalent if exists\n    \"DataException\": GeneralAPIError, # Or could be InvalidInputError depending on context\n\n    # Order specific\n    \"OrderException\": GeneralAPIError, # Base for order errors, specific ones below\n    \"MarginException\": InsufficientFundsError,\n    \"FundsException\": InsufficientFundsError,\n    \"QuantityException\": InvalidInputError,\n    \"PriceException\": InvalidInputError,\n    \"TriggerPriceException\": InvalidInputError,\n    \"OrderNotFoundException\": OrderNotFoundError, # Hypothetical, check actual Kite errors\n    \"OrderModificationException\": OrderNotModifiableError, # Hypothetical\n\n    # Exchange specific\n    \"ExchangeException\": ExchangeError,\n\n    # Rate limiting\n    \"NetworkException\": RateLimitError, # Kite uses NetworkException for rate limits often\n    # Add more specific mappings based on Kite Connect v3 documentation\n}\n\n# Mapping from HTTP status codes to custom exception classes\nHTTP_STATUS_MAP = {\n    400: InvalidInputError, # Bad Request\n    401: AuthenticationError, # Unauthorized (likely token issue)\n    403: AuthenticationError, # Forbidden (API key issue or permissions)\n    404: OrderNotFoundError, # Not Found (often for modifying non-existent order)\n    405: GeneralAPIError, # Method Not Allowed\n    429: RateLimitError, # Too Many Requests\n    500: GeneralAPIError, # Internal Server Error\n    502: ExchangeError, # Bad Gateway (often exchange issues)\n    503: ExchangeError, # Service Unavailable (often exchange issues)\n    504: NetworkError, # Gateway Timeout\n}\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect API v3 Orders.\n\n    Handles request formation, authentication, and basic error handling.\n    \"\"\"\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        \"\"\"Initializes the Kite Connect client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after successful login.\n            base_url: The base URL for the Kite Connect API.\n            timeout: Request timeout in seconds.\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API Key and Access Token cannot be empty.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.timeout = timeout\n        self._headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite API expects form data\n        }\n        self._client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self._headers,\n            timeout=self.timeout\n        )\n\n    @retry(stop=stop_after_attempt(3), wait=wait_fixed(2), retry=retry_if_exception_type((NetworkError, RateLimitError)))\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite API with error handling and retries.\n\n        Args:\n            method: HTTP method (e.g., 'POST', 'PUT', 'GET', 'DELETE').\n            endpoint: API endpoint path (e.g., '/orders/regular').\n            data: Dictionary of form data for POST/PUT requests.\n\n        Returns:\n            The JSON response data as a dictionary.\n\n        Raises:\n            KiteConnectError: If the API returns an error or the request fails.\n        \"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            logger.debug(f\"Sending {method} request to {url} with data: {data}\")\n            response = await self._client.request(method, endpoint, data=data)\n\n            # Check for HTTP errors\n            response.raise_for_status()\n\n            # Successful response\n            json_response = response.json()\n            logger.debug(f\"Received successful response ({response.status_code}) from {url}: {json_response}\")\n\n            # Kite API specific success check (often has a 'data' field)\n            if 'status' in json_response and json_response['status'] == 'success':\n                return json_response.get('data', {}) # Return the nested data part\n            elif 'data' in json_response: # Handle cases where status might not be present but data is\n                 return json_response.get('data', {})\n            else:\n                # If structure is unexpected but status was 2xx\n                logger.warning(f\"Unexpected successful response structure from {url}: {json_response}\")\n                return json_response # Return the full response\n\n        except httpx.HTTPStatusError as e:\n            status_code = e.response.status_code\n            try:\n                error_data = e.response.json()\n                message = error_data.get('message', 'Unknown API error')\n                error_type = error_data.get('error_type', 'UnknownErrorType')\n                logger.error(f\"Kite API Error ({status_code}) from {url}: {message} (Type: {error_type})\")\n\n                # Map Kite error type first, then HTTP status code\n                exception_class = KITE_ERROR_MAP.get(error_type, HTTP_STATUS_MAP.get(status_code, GeneralAPIError))\n                raise exception_class(message=message, status_code=status_code, error_type=error_type) from e\n\n            except Exception as json_error:\n                # If parsing error response fails\n                message = e.response.text or f\"HTTP Error {status_code}\"\n                error_type = 'UnknownErrorType'\n                logger.error(f\"Kite API Error ({status_code}) from {url}. Failed to parse error response: {json_error}. Response text: {message}\")\n                exception_class = HTTP_STATUS_MAP.get(status_code, GeneralAPIError)\n                raise exception_class(message=message, status_code=status_code, error_type=error_type) from e\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out for {method} {url}: {e}\")\n            raise NetworkError(message=\"Request timed out\", status_code=None, error_type=\"TimeoutError\") from e\n        except httpx.NetworkError as e:\n            logger.error(f\"Network error for {method} {url}: {e}\")\n            # Check if it's a rate limit error disguised as NetworkException by Kite\n            if \"rate limit\" in str(e).lower(): # Basic check, might need refinement\n                 raise RateLimitError(message=\"Rate limit likely exceeded\", status_code=429, error_type=\"RateLimitError\") from e\n            raise NetworkError(message=f\"Network error: {e}\", status_code=None, error_type=\"NetworkError\") from e\n        except Exception as e:\n            logger.exception(f\"Unexpected error during request to {url}: {e}\")\n            raise GeneralAPIError(message=f\"An unexpected client error occurred: {e}\", status_code=None, error_type=\"ClientError\") from e\n\n    async def place_order_async(self, params: PlaceOrderParams) -> Dict[str, str]:\n        \"\"\"Places an order asynchronously.\n\n        Args:\n            params: An instance of PlaceOrderParams containing order details.\n\n        Returns:\n            A dictionary containing the 'order_id'.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Prepare form data, excluding None values and the 'variety' field itself\n        data = {k: v for k, v in params.dict(exclude={'variety'}).items() if v is not None}\n\n        logger.info(f\"Placing order via endpoint: {endpoint}\")\n        response_data = await self._request(\"POST\", endpoint, data=data)\n\n        if 'order_id' not in response_data:\n            logger.error(f\"'order_id' not found in response for place order: {response_data}\")\n            raise GeneralAPIError(message=\"'order_id' missing from successful place order response\", error_type=\"ResponseFormatError\")\n\n        return {\"order_id\": response_data['order_id']}\n\n    async def modify_order_async(self, params: ModifyOrderParams) -> Dict[str, str]:\n        \"\"\"Modifies a pending order asynchronously.\n\n        Args:\n            params: An instance of ModifyOrderParams containing modification details.\n\n        Returns:\n            A dictionary containing the 'order_id'.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Prepare form data, excluding None values and path parameters ('variety', 'order_id')\n        data = {k: v for k, v in params.dict(exclude={'variety', 'order_id'}).items() if v is not None}\n\n        logger.info(f\"Modifying order {params.order_id} via endpoint: {endpoint}\")\n        response_data = await self._request(\"PUT\", endpoint, data=data)\n\n        if 'order_id' not in response_data:\n            logger.error(f\"'order_id' not found in response for modify order: {response_data}\")\n            raise GeneralAPIError(message=\"'order_id' missing from successful modify order response\", error_type=\"ResponseFormatError\")\n\n        return {\"order_id\": response_data['order_id']}\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self._client.aclose()\n        logger.info(\"Kite Connect client closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.2.0,<0.3.0\nhttpx[http2]>=0.25.0,<0.28.0\npydantic>=1.9.0,<2.0.0\npython-dotenv>=0.19.0,<1.1.0\n# typing_extensions needed for Literal in older Python versions if not using >=3.8\n# typing_extensions>=4.0.0\nuvicorn>=0.15.0,<0.28.0\ntenacity>=8.0.0,<9.0.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer Console (https://developers.kite.trade/)\n\n# Your Kite Connect API Key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# The access token obtained after a successful Kite Connect login flow\n# This token is typically short-lived (valid for one day) and needs to be regenerated daily.\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# Base URL for the Kite Connect API (usually doesn't need changing)\nKITE_API_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect Orders MCP Server\n\nThis project provides an MCP (Model Context Protocol) server for interacting with the Zerodha Kite Connect API v3, specifically focusing on order management functionalities.\n\nIt allows language models or other applications to place and modify trading orders through a standardized MCP interface.\n\n## Features\n\n*   **Place Orders:** Place various types of orders (Regular, AMO, CO, Iceberg, Auction).\n*   **Modify Orders:** Modify attributes of pending orders.\n*   **Typed Interface:** Uses Pydantic models for clear and validated inputs and outputs.\n*   **Asynchronous:** Built with `asyncio` and `httpx` for non-blocking I/O.\n*   **Error Handling:** Maps Kite Connect API errors to specific exceptions.\n*   **Configurable:** Uses environment variables for API credentials and base URL.\n\n## Prerequisites\n\n*   Python 3.8+\n*   A Zerodha Kite Connect API Key and Secret.\n*   A valid `access_token` obtained through the Kite Connect login flow (this needs to be generated daily).\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect `API_KEY` and a valid `ACCESS_TOKEN`:\n        ```dotenv\n        KITE_API_KEY=\"YOUR_ACTUAL_API_KEY\"\n        KITE_ACCESS_TOKEN=\"YOUR_VALID_ACCESS_TOKEN\"\n        KITE_API_BASE_URL=\"https://api.kite.trade\"\n        ```\n    *   **Important:** The `ACCESS_TOKEN` is short-lived and needs to be updated regularly (typically daily) after completing the Kite Connect login flow.\n\n## Running the Server\n\nStart the MCP server using:\n\n```bash\npython main.py\n```\n\nThe server will start, usually on `http://127.0.0.1:8000` (unless configured otherwise).\n\n## Available Tools\n\nThe MCP server exposes the following tools:\n\n1.  **`place_order`**\n    *   **Description:** Places an order of a specified variety.\n    *   **Input:** `PlaceOrderParams` model (see `models.py` for details).\n        *   Requires fields like `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, `validity`, and conditionally required fields like `price`, `trigger_price`, etc., based on order type and variety.\n    *   **Output:** `OrderResponse` model containing the `order_id` on success, or an error dictionary.\n\n2.  **`modify_order`**\n    *   **Description:** Modifies attributes of a pending order.\n    *   **Input:** `ModifyOrderParams` model (see `models.py` for details).\n        *   Requires `variety` and `order_id`.\n        *   Optional fields for modification include `order_type`, `quantity`, `price`, `trigger_price`, `disclosed_quantity`, `validity` (restrictions apply based on order variety).\n    *   **Output:** `OrderResponse` model containing the `order_id` on success, or an error dictionary.\n\n## Error Handling\n\nThe client attempts to map common Kite Connect API errors and HTTP status codes to specific Python exceptions (defined in `client.py`). These errors are caught by the tool functions in `main.py` and returned as a JSON dictionary with `error` and `error_type` keys.\n\nExample error response:\n```json\n{\n  \"error\": \"InputException (HTTP 400): Invalid `trigger_price`.\",\n  \"error_type\": \"InvalidInputError\"\n}\n```\n\n## Rate Limiting\n\nThe Kite Connect API has rate limits (e.g., 10 requests per second for order placement/modification). This client includes basic retry logic for potential network issues and rate limit errors (HTTP 429), but robust handling might require more sophisticated client-side throttling if you expect high request volumes.\n\n## Disclaimer\n\nTrading involves substantial risk. This software is provided \"as is\" without warranty of any kind. Ensure you understand the risks and the behavior of the Kite Connect API before using this tool for live trading. Test thoroughly in a simulated environment if possible.\n"
    }
  ]
}
{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, List\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom models import (\n    PlaceOrderParams,\n    ModifyOrderParams,\n    CancelOrderParams,\n    GetOrderHistoryParams,\n    KiteResponse,\n    Order\n)\nfrom client import AsyncKiteClient, KiteApiException\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"ZerodhaKiteConnect\",\n    description=\"MCP server for interacting with the Zerodha Kite Connect API, focusing on order management and retrieval based on v3 documentation.\"\n)\n\n# Initialize API Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n    # Optionally raise an error or exit, depending on desired behavior\n    # raise ValueError(\"API Key and Access Token are required.\")\n    # For now, we allow it to proceed but client calls will likely fail\n\nkite_client = AsyncKiteClient(api_key=api_key, access_token=access_token, base_url=base_url)\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\n\n    Args:\n        params: Parameters for placing the order.\n\n    Returns:\n        A dictionary containing the 'order_id' of the placed order or an error message.\n    \"\"\"\n    logger.info(f\"Received request to place order: {params.dict(exclude_none=True)}\")\n    try:\n        response = await kite_client.place_order(params)\n        logger.info(f\"Successfully placed order: {response}\")\n        # Ensure the response structure matches the expected KiteResponse or similar\n        if isinstance(response, dict) and response.get(\"data\") and isinstance(response[\"data\"], dict) and \"order_id\" in response[\"data\"]:\n             return {\"order_id\": response[\"data\"][\"order_id\"]}\n        elif isinstance(response, dict):\n             # Handle cases where the structure might differ slightly but contains the ID\n             if \"order_id\" in response:\n                 return {\"order_id\": response[\"order_id\"]}\n             else:\n                 logger.warning(f\"Place order response structure unexpected: {response}\")\n                 return {\"warning\": \"Order placed, but response format unexpected.\", \"details\": response}\n        else:\n            logger.error(f\"Unexpected response type from place_order client: {type(response)}\")\n            return {\"error\": \"Unexpected response format from API\", \"details\": str(response)}\n\n    except KiteApiException as e:\n        logger.error(f\"API error placing order: {e}\")\n        return {\"error\": e.message, \"status_code\": e.status_code, \"error_type\": e.error_type}\n    except Exception as e:\n        logger.exception(\"Unexpected error placing order\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modify attributes of a pending regular or cover order.\n\n    Args:\n        params: Parameters for modifying the order.\n\n    Returns:\n        A dictionary containing the 'order_id' of the modified order or an error message.\n    \"\"\"\n    logger.info(f\"Received request to modify order {params.order_id}: {params.dict(exclude={'order_id', 'variety'}, exclude_none=True)}\")\n    try:\n        response = await kite_client.modify_order(params)\n        logger.info(f\"Successfully modified order {params.order_id}: {response}\")\n        # Ensure the response structure matches the expected KiteResponse or similar\n        if isinstance(response, dict) and response.get(\"data\") and isinstance(response[\"data\"], dict) and \"order_id\" in response[\"data\"]:\n             return {\"order_id\": response[\"data\"][\"order_id\"]}\n        elif isinstance(response, dict):\n             # Handle cases where the structure might differ slightly but contains the ID\n             if \"order_id\" in response:\n                 return {\"order_id\": response[\"order_id\"]}\n             else:\n                 logger.warning(f\"Modify order response structure unexpected: {response}\")\n                 return {\"warning\": \"Order modified, but response format unexpected.\", \"details\": response}\n        else:\n            logger.error(f\"Unexpected response type from modify_order client: {type(response)}\")\n            return {\"error\": \"Unexpected response format from API\", \"details\": str(response)}\n\n    except KiteApiException as e:\n        logger.error(f\"API error modifying order {params.order_id}: {e}\")\n        return {\"error\": e.message, \"status_code\": e.status_code, \"error_type\": e.error_type}\n    except Exception as e:\n        logger.exception(f\"Unexpected error modifying order {params.order_id}\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"Cancel a pending regular, amo, co, iceberg, or auction order.\n\n    Args:\n        params: Parameters for cancelling the order.\n\n    Returns:\n        A dictionary containing the 'order_id' of the cancelled order or an error message.\n    \"\"\"\n    logger.info(f\"Received request to cancel order {params.order_id} (variety: {params.variety}) Parent: {params.parent_order_id}\")\n    try:\n        response = await kite_client.cancel_order(params)\n        logger.info(f\"Successfully cancelled order {params.order_id}: {response}\")\n        # Ensure the response structure matches the expected KiteResponse or similar\n        if isinstance(response, dict) and response.get(\"data\") and isinstance(response[\"data\"], dict) and \"order_id\" in response[\"data\"]:\n             return {\"order_id\": response[\"data\"][\"order_id\"]}\n        elif isinstance(response, dict):\n             # Handle cases where the structure might differ slightly but contains the ID\n             if \"order_id\" in response:\n                 return {\"order_id\": response[\"order_id\"]}\n             else:\n                 logger.warning(f\"Cancel order response structure unexpected: {response}\")\n                 return {\"warning\": \"Order cancelled, but response format unexpected.\", \"details\": response}\n        else:\n            logger.error(f\"Unexpected response type from cancel_order client: {type(response)}\")\n            return {\"error\": \"Unexpected response format from API\", \"details\": str(response)}\n\n    except KiteApiException as e:\n        logger.error(f\"API error cancelling order {params.order_id}: {e}\")\n        return {\"error\": e.message, \"status_code\": e.status_code, \"error_type\": e.error_type}\n    except Exception as e:\n        logger.exception(f\"Unexpected error cancelling order {params.order_id}\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def get_orders() -> Dict[str, Any]:\n    \"\"\"Retrieve the list of all orders (open, pending, executed) for the current trading day.\n\n    Returns:\n        A dictionary containing a list of orders or an error message.\n    \"\"\"\n    logger.info(\"Received request to get orders\")\n    try:\n        response = await kite_client.get_orders()\n        logger.info(f\"Successfully retrieved {len(response.get('data', [])) if isinstance(response, dict) else 'unknown number of'} orders.\")\n        # Assuming response is {'status': 'success', 'data': [list of orders]}\n        if isinstance(response, dict) and response.get(\"status\") == \"success\" and isinstance(response.get(\"data\"), list):\n            # Optionally validate each item against the Order model if needed\n            return {\"orders\": response[\"data\"]}\n        else:\n            logger.error(f\"Unexpected response format from get_orders client: {response}\")\n            return {\"error\": \"Unexpected response format from API\", \"details\": str(response)}\n\n    except KiteApiException as e:\n        logger.error(f\"API error getting orders: {e}\")\n        return {\"error\": e.message, \"status_code\": e.status_code, \"error_type\": e.error_type}\n    except Exception as e:\n        logger.exception(\"Unexpected error getting orders\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\nasync def get_order_history(params: GetOrderHistoryParams) -> Dict[str, Any]:\n    \"\"\"Retrieve the history (status changes) of a given order.\n\n    Args:\n        params: Parameters containing the order_id.\n\n    Returns:\n        A dictionary containing the order history or an error message.\n    \"\"\"\n    logger.info(f\"Received request to get order history for order_id: {params.order_id}\")\n    try:\n        response = await kite_client.get_order_history(params)\n        logger.info(f\"Successfully retrieved history for order {params.order_id}\")\n        # Assuming response is {'status': 'success', 'data': [list of history items]}\n        if isinstance(response, dict) and response.get(\"status\") == \"success\" and isinstance(response.get(\"data\"), list):\n            return {\"history\": response[\"data\"]}\n        else:\n            logger.error(f\"Unexpected response format from get_order_history client: {response}\")\n            return {\"error\": \"Unexpected response format from API\", \"details\": str(response)}\n\n    except KiteApiException as e:\n        logger.error(f\"API error getting order history for {params.order_id}: {e}\")\n        return {\"error\": e.message, \"status_code\": e.status_code, \"error_type\": e.error_type}\n    except Exception as e:\n        logger.exception(f\"Unexpected error getting order history for {params.order_id}\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\nif __name__ == \"__main__\":\n    import uvicorn\n    # Run the MCP server using uvicorn\n    # The host and port can be configured as needed\n    # Reload=True is useful for development\n    uvicorn.run(\"main:mcp.app\", host=\"0.0.0.0\", port=8000, reload=True)\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field, validator\nfrom typing import Optional, List, Literal, Dict, Any, Union\nimport datetime\n\n# Define Literal types for allowed values based on Kite Connect API v3\nVarietyType = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nExchangeType = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\nModifyVarietyType = Literal['regular', 'co']\nModifyOrderType = Optional[OrderType]\nModifyValidityType = Optional[ValidityType]\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Input model for placing an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"The variety of the order.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange.\")\n    transaction_type: TransactionType = Field(..., description=\"BUY or SELL.\")\n    order_type: OrderType = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: ProductType = Field(..., description=\"Product code.\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (SL, SL-M). Required for SL/SL-M orders.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity: ValidityType = Field(..., description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders. Required if validity is TTL.\")\n    iceberg_legs: Optional[int] = Field(None, ge=2, le=10, description=\"Total number of legs for iceberg order type (2-10). Required if variety is iceberg.\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order. Required if variety is iceberg.\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction. Required if variety is auction.\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"An optional tag (alphanumeric, max 20 chars).\")\n\n    @validator('price')\n    def price_required_for_limit(cls, v, values):\n        if values.get('order_type') == 'LIMIT' and v is None:\n            raise ValueError('price is required for LIMIT orders')\n        if values.get('order_type') != 'LIMIT' and v is not None:\n             # Kite API might ignore it, but better to warn or raise\n             # raise ValueError('price is only applicable for LIMIT orders')\n             pass # Allow sending it, API might handle it\n        return v\n\n    @validator('trigger_price')\n    def trigger_price_required_for_sl(cls, v, values):\n        if values.get('order_type') in ['SL', 'SL-M'] and v is None:\n            raise ValueError('trigger_price is required for SL and SL-M orders')\n        if values.get('order_type') not in ['SL', 'SL-M'] and v is not None:\n            # raise ValueError('trigger_price is only applicable for SL and SL-M orders')\n            pass # Allow sending it\n        return v\n\n    @validator('validity_ttl')\n    def validity_ttl_required(cls, v, values):\n        if values.get('validity') == 'TTL' and v is None:\n            raise ValueError('validity_ttl is required for TTL validity')\n        if values.get('validity') != 'TTL' and v is not None:\n            raise ValueError('validity_ttl is only applicable for TTL validity')\n        return v\n\n    @validator('iceberg_legs')\n    def iceberg_legs_required(cls, v, values):\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError('iceberg_legs is required for iceberg variety')\n        if values.get('variety') != 'iceberg' and v is not None:\n            raise ValueError('iceberg_legs is only applicable for iceberg variety')\n        return v\n\n    @validator('iceberg_quantity')\n    def iceberg_quantity_required(cls, v, values):\n        if values.get('variety') == 'iceberg' and v is None:\n            raise ValueError('iceberg_quantity is required for iceberg variety')\n        if values.get('variety') != 'iceberg' and v is not None:\n            raise ValueError('iceberg_quantity is only applicable for iceberg variety')\n        return v\n\n    @validator('auction_number')\n    def auction_number_required(cls, v, values):\n        if values.get('variety') == 'auction' and v is None:\n            raise ValueError('auction_number is required for auction variety')\n        if values.get('variety') != 'auction' and v is not None:\n            raise ValueError('auction_number is only applicable for auction variety')\n        return v\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Input model for modifying an order.\"\"\"\n    variety: ModifyVarietyType = Field(..., description=\"The variety of the order to modify ('regular' or 'co').\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    order_type: ModifyOrderType = Field(None, description=\"New order type (only for regular variety).\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity (only for regular variety).\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, LIMIT CO orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (only for regular variety).\")\n    validity: ModifyValidityType = Field(None, description=\"New validity (only for regular variety).\")\n\n    @validator('order_type', 'quantity', 'disclosed_quantity', 'validity')\n    def regular_only_fields(cls, v, values, field):\n        if values.get('variety') == 'co' and v is not None:\n            raise ValueError(f\"{field.name} cannot be modified for 'co' variety orders.\")\n        return v\n\n    @validator('price')\n    def price_check(cls, v, values):\n        if values.get('variety') == 'co' and v is not None:\n            raise ValueError(\"price cannot be modified for 'co' variety orders.\")\n        # Add check if order_type is changing to/from LIMIT if needed\n        return v\n\n    @validator('trigger_price')\n    def trigger_price_check(cls, v, values):\n        # Trigger price can be modified for regular SL/SL-M and CO limit orders\n        # Add more specific validation based on target order_type if necessary\n        return v\n\nclass CancelOrderParams(BaseModel):\n    \"\"\"Input model for cancelling an order.\"\"\"\n    variety: VarietyType = Field(..., description=\"The variety of the order to cancel.\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Conditional parent order id for CO second leg cancellation.\")\n\n    @validator('parent_order_id')\n    def parent_order_id_for_co(cls, v, values):\n        # This might be needed if cancelling the second leg of a CO requires the parent_order_id\n        # The Kite documentation isn't explicit on this for DELETE, but it's good practice to include if applicable.\n        # if values.get('variety') == 'co' and v is None: # Check specific conditions if needed\n        #     raise ValueError(\"parent_order_id might be required for cancelling CO legs\")\n        if values.get('variety') != 'co' and v is not None:\n            raise ValueError(\"parent_order_id is only applicable for 'co' variety\")\n        return v\n\nclass GetOrderHistoryParams(BaseModel):\n    \"\"\"Input model for getting order history.\"\"\"\n    order_id: str = Field(..., description=\"The ID of the order to retrieve history for.\")\n\nclass KiteResponse(BaseModel):\n    \"\"\"Generic response model for simple Kite API returns.\"\"\"\n    order_id: str\n\n# Basic Order model based on typical fields in Kite Connect order book/history\n# This might need adjustments based on the exact fields returned by the API\nclass Order(BaseModel):\n    \"\"\"Represents a single order object returned by Kite API.\"\"\"\n    order_id: Optional[str] = None\n    parent_order_id: Optional[str] = None\n    exchange_order_id: Optional[str] = None\n    status: Optional[str] = None\n    status_message: Optional[str] = None\n    status_message_raw: Optional[str] = None\n    order_timestamp: Optional[Union[datetime.datetime, str]] = None # Kite often returns strings\n    exchange_timestamp: Optional[Union[datetime.datetime, str]] = None\n    variety: Optional[str] = None\n    exchange: Optional[str] = None\n    tradingsymbol: Optional[str] = None\n    instrument_token: Optional[int] = None\n    order_type: Optional[str] = None\n    transaction_type: Optional[str] = None\n    validity: Optional[str] = None\n    product: Optional[str] = None\n    quantity: Optional[int] = None\n    disclosed_quantity: Optional[int] = None\n    price: Optional[float] = None\n    trigger_price: Optional[float] = None\n    average_price: Optional[float] = None\n    filled_quantity: Optional[int] = None\n    pending_quantity: Optional[int] = None\n    cancelled_quantity: Optional[int] = None\n    guid: Optional[str] = None\n    market_protection: Optional[float] = None\n    tag: Optional[str] = None\n    meta: Optional[Dict[str, Any]] = None\n\n    # Allow extra fields as Kite API might add new ones\n    class Config:\n        extra = 'allow'\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nimport asyncio\nfrom typing import Dict, Any, Optional, List, Union\n\nfrom models import (\n    PlaceOrderParams,\n    ModifyOrderParams,\n    CancelOrderParams,\n    GetOrderHistoryParams\n)\n\nlogger = logging.getLogger(__name__)\n\n# Define a custom exception for Kite API errors\nclass KiteApiException(Exception):\n    def __init__(self, message: str, status_code: Optional[int] = None, error_type: Optional[str] = None, response_data: Optional[Any] = None):\n        self.message = message\n        self.status_code = status_code\n        self.error_type = error_type\n        self.response_data = response_data\n        super().__init__(self.message)\n\n    def __str__(self):\n        return f\"KiteApiException(status_code={self.status_code}, error_type='{self.error_type}', message='{self.message}')\"\n\nclass AsyncKiteClient:\n    \"\"\"Asynchronous client for interacting with the Zerodha Kite Connect API v3.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0, retries: int = 1, backoff_factor: float = 0.5):\n        \"\"\"Initialize the client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after successful login.\n            base_url: The base URL for the Kite API.\n            timeout: Default request timeout in seconds.\n            retries: Number of retries for transient errors (e.g., 5xx, timeouts).\n            backoff_factor: Factor to determine delay between retries (delay = backoff_factor * (2 ** retry_attempt)).\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API Key and Access Token cannot be empty.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.timeout = timeout\n        self.retries = retries\n        self.backoff_factor = backoff_factor\n\n        self.headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            # Content-Type is set per request by httpx based on 'json' or 'data' parameter\n        }\n\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=self.timeout,\n            # Enable HTTP/2 if supported by the server\n            http2=True\n        )\n\n    async def _request(self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None, data: Optional[Dict[str, Any]] = None) -> Any:\n        \"\"\"Makes an asynchronous HTTP request with retry logic.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Making request: {method} {url} | Params: {params} | Data: {data}\")\n\n        last_exception = None\n        for attempt in range(self.retries + 1):\n            try:\n                response = await self.client.request(\n                    method,\n                    endpoint, # Use relative endpoint with base_url in client\n                    params=params,\n                    data=data # Use data for form-encoded, json for JSON body\n                )\n\n                # Check for specific Kite error response structure\n                try:\n                    response_data = response.json()\n                except Exception:\n                    response_data = response.text # If not JSON\n\n                # Raise specific exception for HTTP errors (4xx, 5xx)\n                if response.is_error:\n                    status_code = response.status_code\n                    error_type = None\n                    message = f\"HTTP error {status_code}\"\n\n                    if isinstance(response_data, dict):\n                        error_type = response_data.get(\"error_type\")\n                        message = response_data.get(\"message\", message)\n\n                    # Handle rate limiting (429)\n                    if status_code == 429:\n                        message = response_data.get(\"message\", \"Rate limit exceeded\")\n                        error_type = response_data.get(\"error_type\", \"TooManyRequests\")\n                        logger.warning(f\"Rate limit hit (429). Attempt {attempt + 1}/{self.retries + 1}. {message}\")\n                        # If retries remain, back off and retry\n                        if attempt < self.retries:\n                            retry_after = self.backoff_factor * (2 ** attempt)\n                            logger.info(f\"Waiting {retry_after:.2f}s before retrying...\")\n                            await asyncio.sleep(retry_after)\n                            continue # Go to next attempt\n                        else:\n                            logger.error(\"Rate limit exceeded after all retries.\")\n                            raise KiteApiException(message, status_code, error_type, response_data)\n\n                    # Handle other client/server errors\n                    logger.error(f\"Kite API Error: Status={status_code}, Type={error_type}, Msg='{message}', Response={response_data}\")\n                    raise KiteApiException(message, status_code, error_type, response_data)\n\n                # Success (2xx)\n                logger.debug(f\"Request successful: {method} {endpoint} -> Status {response.status_code}\")\n                return response_data # Return parsed JSON\n\n            except httpx.TimeoutException as e:\n                logger.warning(f\"Request timed out: {method} {endpoint}. Attempt {attempt + 1}/{self.retries + 1}. Error: {e}\")\n                last_exception = e\n                if attempt < self.retries:\n                    retry_after = self.backoff_factor * (2 ** attempt)\n                    await asyncio.sleep(retry_after)\n                else:\n                    raise KiteApiException(f\"Request timed out after {self.retries} retries: {e}\", status_code=408, error_type=\"Timeout\") from e\n\n            except httpx.RequestError as e:\n                # Includes network errors, connection errors etc.\n                logger.warning(f\"Request failed: {method} {endpoint}. Attempt {attempt + 1}/{self.retries + 1}. Error: {e}\")\n                last_exception = e\n                # Only retry potentially transient network errors, not configuration errors like invalid URL\n                if isinstance(e, (httpx.NetworkError, httpx.ConnectError, httpx.ReadError)) and attempt < self.retries:\n                     retry_after = self.backoff_factor * (2 ** attempt)\n                     await asyncio.sleep(retry_after)\n                else:\n                    raise KiteApiException(f\"Request failed: {e}\", error_type=\"RequestError\") from e\n\n            except KiteApiException as e:\n                # Re-raise KiteApiException if caught (e.g., from 429 handling)\n                raise e\n\n            except Exception as e:\n                logger.exception(f\"An unexpected error occurred during request: {method} {endpoint}\")\n                raise KiteApiException(f\"An unexpected error occurred: {str(e)}\", error_type=\"UnexpectedError\") from e\n\n        # Should not be reached if retries > 0, but as a fallback\n        if last_exception:\n             raise KiteApiException(f\"Request failed after {self.retries} retries: {last_exception}\", error_type=\"MaxRetriesExceeded\") from last_exception\n         # Should definitely not be reached\n        raise KiteApiException(\"Request failed due to unknown error after retries\", error_type=\"UnknownRetryFailure\")\n\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, Any]:\n        \"\"\"Place an order.\"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Kite API expects form-encoded data for orders\n        data = params.dict(exclude={'variety'}, exclude_none=True)\n        # Convert boolean/numeric types to strings if required by API, though httpx usually handles this\n        # Example: data = {k: str(v) for k, v in data.items()}\n        return await self._request(\"POST\", endpoint, data=data)\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, Any]:\n        \"\"\"Modify a pending order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        data = params.dict(exclude={'variety', 'order_id'}, exclude_none=True)\n        return await self._request(\"PUT\", endpoint, data=data)\n\n    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, Any]:\n        \"\"\"Cancel a pending order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        query_params = {}\n        if params.parent_order_id:\n            query_params['parent_order_id'] = params.parent_order_id\n\n        # DELETE requests typically don't have a body, use query params if needed\n        return await self._request(\"DELETE\", endpoint, params=query_params if query_params else None)\n\n    async def get_orders(self) -> Dict[str, Any]:\n        \"\"\"Retrieve the list of orders for the day.\"\"\"\n        endpoint = \"/orders\"\n        return await self._request(\"GET\", endpoint)\n\n    async def get_order_history(self, params: GetOrderHistoryParams) -> Dict[str, Any]:\n        \"\"\"Retrieve the history of a specific order.\"\"\"\n        endpoint = f\"/orders/{params.order_id}\"\n        return await self._request(\"GET\", endpoint)\n\n    async def close(self):\n        \"\"\"Close the underlying HTTP client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"Kite API client closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=1.10.0,<2.0.0\nhttpx[http2]>=0.23.0\npython-dotenv>=0.20.0\nuvicorn>=0.18.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Zerodha Kite Connect API Credentials and Configuration\n# Obtain these from https://developers.kite.trade/\n\n# Your Kite Connect application API key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# The access token obtained after a successful user login flow (this is typically short-lived)\n# You will need a mechanism to generate/refresh this token regularly.\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# Base URL for the Kite Connect API (usually doesn't need changing)\nKITE_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# Zerodha Kite Connect MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect API (v3). It allows language models or other applications to manage trading orders (place, modify, cancel) and retrieve order information through a standardized MCP interface.\n\n## Features\n\n*   **Place Orders:** Supports various order types (regular, amo, co, iceberg, auction).\n*   **Modify Orders:** Allows modification of pending regular and CO orders.\n*   **Cancel Orders:** Cancel pending orders.\n*   **Get Orders:** Retrieve the list of all orders for the current trading day.\n*   **Get Order History:** Fetch the status change history for a specific order.\n*   Built with **FastMCP** for easy integration.\n*   Asynchronous API client using **httpx**.\n*   Input validation using **Pydantic**.\n*   Basic error handling and logging.\n\n## Prerequisites\n\n*   Python 3.8+\n*   Zerodha Kite Connect API Key and Secret.\n*   A valid Zerodha Kite Connect Access Token (obtained via the Kite Connect login flow - see [Kite Connect Documentation](https://kite.trade/docs/connect/v3/user/)). **Note:** Access tokens are short-lived and need to be refreshed periodically. This server assumes a valid token is provided via environment variables.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create and activate a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    Copy the example environment file:\n    ```bash\n    cp .env.example .env\n    ```\n    Edit the `.env` file and add your Kite Connect API Key and a valid Access Token:\n    ```dotenv\n    # Zerodha Kite Connect API Credentials and Configuration\n    KITE_API_KEY=\"YOUR_ACTUAL_API_KEY\"\n    KITE_ACCESS_TOKEN=\"YOUR_VALID_ACCESS_TOKEN\"\n    KITE_BASE_URL=\"https://api.kite.trade\"\n    ```\n\n## Running the Server\n\nUse `uvicorn` to run the MCP server:\n\n```bash\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n*   `--reload`: Automatically restarts the server when code changes (useful for development).\n\nThe MCP server will be available at `http://localhost:8000` (or the specified host/port).\n\n## Available Tools\n\nThe following tools are exposed via the MCP server:\n\n*   `place_order(params: PlaceOrderParams)`: Place an order.\n*   `modify_order(params: ModifyOrderParams)`: Modify a pending order.\n*   `cancel_order(params: CancelOrderParams)`: Cancel a pending order.\n*   `get_orders()`: Retrieve all orders for the day.\n*   `get_order_history(params: GetOrderHistoryParams)`: Retrieve the history for a specific order.\n\nRefer to `models.py` for the detailed structure of the input parameter models (`PlaceOrderParams`, `ModifyOrderParams`, etc.).\n\n## Error Handling\n\nThe server attempts to catch errors from the Kite Connect API (like invalid parameters, authentication issues, insufficient funds, exchange rejections) and network issues. Errors are generally returned as a JSON dictionary with an `\"error\"` key, often including details like `\"status_code\"` and `\"error_type\"` from the API.\n\n```json\n{\n  \"error\": \"Invalid order parameters.\",\n  \"status_code\": 400,\n  \"error_type\": \"InputException\"\n}\n```\n\n## Rate Limiting\n\nThe Kite Connect API has rate limits (e.g., 3 requests per second for order-related endpoints). The client includes basic retry logic with backoff for `429 Too Many Requests` errors and transient network issues. However, sustained high request rates will still result in errors after retries are exhausted.\n\n## Important Notes\n\n*   **Access Token Management:** This server requires a *pre-generated* access token. In a production environment, you would need a robust mechanism to handle the Kite Connect login flow and periodically refresh the access token.\n*   **Security:** Ensure your API Key and Access Token are kept secure and are not exposed publicly.\n*   **Disclaimer:** Trading involves risks. Use this software responsibly and test thoroughly in a simulated environment if possible before using with real funds.\n"
    }
  ]
}
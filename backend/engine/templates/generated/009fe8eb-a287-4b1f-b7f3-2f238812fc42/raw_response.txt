{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom client import KiteConnectClient, KiteConnectClientError\nfrom models import GenerateSessionParams, PlaceOrderParams, ModifyOrderParams\n\n# Load environment variables\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP\nmcp = FastMCP(\n    service_name=\"KiteConnect\",\n    description=\"MCP server for interacting with the Zerodha Kite Connect API V3, providing tools for order management, portfolio retrieval, market data access, and more.\"\n)\n\n# Initialize Kite Connect Client\nAPI_KEY = os.getenv(\"KITE_API_KEY\")\nAPI_SECRET = os.getenv(\"KITE_API_SECRET\")\n\nif not API_KEY:\n    logger.warning(\"KITE_API_KEY environment variable not set.\")\nif not API_SECRET:\n    logger.warning(\"KITE_API_SECRET environment variable not set.\")\n\nkite_client = KiteConnectClient(api_key=API_KEY)\n\n@mcp.tool()\ndef generate_session(params: GenerateSessionParams) -> Dict[str, Any]:\n    \"\"\"\n    Generate a user session and obtain an access token using a request token obtained after the login flow.\n\n    Args:\n        params: Parameters containing the request_token.\n\n    Returns:\n        Dictionary containing user session details including 'access_token', 'public_token', 'user_id', etc.\n        The 'access_token' is crucial for subsequent API calls.\n    \"\"\"\n    if not API_SECRET:\n        logger.error(\"KITE_API_SECRET is not configured.\")\n        return {\"error\": \"Server configuration error: KITE_API_SECRET is missing.\"}\n\n    try:\n        logger.info(f\"Attempting to generate session for request_token starting with: {params.request_token[:5]}...\")\n        session_data = kite_client.generate_session(params.request_token, API_SECRET)\n        logger.info(f\"Successfully generated session for user_id: {session_data.get('user_id')}\")\n        # Note: The access_token should be stored securely by the caller (e.g., the agent)\n        # and passed to subsequent authenticated tool calls.\n        return session_data\n    except KiteConnectClientError as e:\n        logger.error(f\"Error generating Kite session: {e}\")\n        return {\"error\": str(e)}\n    except Exception as e:\n        logger.exception(\"An unexpected error occurred during session generation.\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\ndef place_order(access_token: str, params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Place an order of a specific variety (regular, amo, co, iceberg, auction).\n    Requires a valid access_token obtained from generate_session.\n\n    Args:\n        access_token: The access token for the authenticated session.\n        params: Parameters for placing the order.\n\n    Returns:\n        Dictionary containing the 'order_id' of the placed order or an error message.\n    \"\"\"\n    try:\n        logger.info(f\"Attempting to place order: {params.dict(exclude_unset=True)}\")\n        order_id = kite_client.place_order(access_token=access_token, params=params)\n        logger.info(f\"Successfully placed order with ID: {order_id}\")\n        return {\"order_id\": order_id}\n    except KiteConnectClientError as e:\n        logger.error(f\"Error placing order: {e}\")\n        return {\"error\": str(e)}\n    except Exception as e:\n        logger.exception(\"An unexpected error occurred during order placement.\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n@mcp.tool()\ndef modify_order(access_token: str, params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"\n    Modify a pending regular or cover order.\n    Requires a valid access_token obtained from generate_session.\n\n    Args:\n        access_token: The access token for the authenticated session.\n        params: Parameters for modifying the order.\n\n    Returns:\n        Dictionary containing the 'order_id' of the modified order or an error message.\n    \"\"\"\n    try:\n        logger.info(f\"Attempting to modify order {params.order_id} with params: {params.dict(exclude={'order_id', 'variety'}, exclude_unset=True)}\")\n        order_id = kite_client.modify_order(access_token=access_token, params=params)\n        logger.info(f\"Successfully modified order {params.order_id}. Result ID: {order_id}\")\n        return {\"order_id\": order_id}\n    except KiteConnectClientError as e:\n        logger.error(f\"Error modifying order {params.order_id}: {e}\")\n        return {\"error\": str(e)}\n    except Exception as e:\n        logger.exception(f\"An unexpected error occurred during order modification for order {params.order_id}.\")\n        return {\"error\": f\"An unexpected error occurred: {str(e)}\"}\n\n\nif __name__ == \"__main__\":\n    # Example of how to run, typically managed by a process manager like uvicorn\n    # uvicorn main:mcp.app --host 0.0.0.0 --port 8000\n    logger.info(\"Starting KiteConnect MCP Server.\")\n    # The mcp.run() method is for simpler, often single-file examples.\n    # For production, use uvicorn directly with mcp.app\n    # Example: uvicorn main:mcp.app --reload\n    pass # Add uvicorn run command here if needed for simple testing\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field\nfrom typing import Optional, Literal\n\n# --- Parameter Models ---\n\nclass GenerateSessionParams(BaseModel):\n    request_token: str = Field(..., description=\"One-time token obtained after the login flow.\")\n\nclass PlaceOrderParams(BaseModel):\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety.\")\n    exchange: Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'] = Field(..., description=\"Name of the exchange.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    transaction_type: Literal['BUY', 'SELL'] = Field(..., description=\"Transaction type.\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: Literal['CNC', 'NRML', 'MIS', 'MTF'] = Field(..., description=\"Product type.\")\n    order_type: Literal['MARKET', 'LIMIT', 'SL', 'SL-M'] = Field(..., description=\"Order type.\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders. Required if order_type is LIMIT.\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders. Required if order_type is SL or SL-M.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity).\")\n    validity: Optional[Literal['DAY', 'IOC', 'TTL']] = Field('DAY', description=\"Order validity. Default is DAY.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity. Required if validity is TTL.\")\n    iceberg_legs: Optional[int] = Field(None, ge=2, le=10, description=\"Number of legs for iceberg order (2-10). Required if variety is iceberg.\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Quantity for each iceberg leg. Required if variety is iceberg.\")\n    auction_number: Optional[str] = Field(None, description=\"Auction number for auction orders. Required if variety is auction.\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"Optional tag for the order (max 20 chars).\")\n\n    # Basic validation - more complex cross-field validation might be needed\n    # depending on KiteConnect API rules (e.g., price required for LIMIT)\n\nclass ModifyOrderParams(BaseModel):\n    variety: Literal['regular', 'co'] = Field(..., description=\"Order variety (regular, co).\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    parent_order_id: Optional[str] = Field(None, description=\"The parent order ID (required for modifying second leg of CO).\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity.\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, CO orders).\")\n    order_type: Optional[Literal['MARKET', 'LIMIT', 'SL', 'SL-M']] = Field(None, description=\"New order type (only applicable for certain modifications, e.g., SL to LIMIT). Check API docs.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity.\")\n    validity: Optional[Literal['DAY', 'IOC', 'TTL']] = Field(None, description=\"New validity (only applicable for regular orders, e.g., DAY to TTL). Check API docs.\")\n\n# --- Return Models (Optional but good practice) ---\n# While the tools currently return Dict[str, Any], defining specific return models improves clarity.\n\nclass SessionData(BaseModel):\n    user_id: str\n    user_name: str\n    user_shortname: str\n    avatar_url: Optional[str]\n    user_type: str\n    email: str\n    broker: str\n    exchanges: list[str]\n    products: list[str]\n    order_types: list[str]\n    api_key: str\n    access_token: str\n    public_token: str\n    login_time: str # Consider using datetime\n\nclass OrderResponse(BaseModel):\n    order_id: str\n"
    },
    {
      "name": "client.py",
      "content": "import logging\nfrom kiteconnect import KiteConnect\nfrom kiteconnect import exceptions as kite_exceptions\nfrom models import PlaceOrderParams, ModifyOrderParams\nfrom typing import Dict, Any\n\nlogger = logging.getLogger(__name__)\n\nclass KiteConnectClientError(Exception):\n    \"\"\"Custom exception for KiteConnectClient errors.\"\"\"\n    pass\n\nclass KiteConnectClient:\n    \"\"\"Client to interact with the Zerodha Kite Connect API.\"\"\"\n\n    def __init__(self, api_key: str, timeout: int = 30):\n        \"\"\"\n        Initializes the KiteConnectClient.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            timeout: Request timeout in seconds.\n        \"\"\"\n        if not api_key:\n            raise ValueError(\"API key is required to initialize KiteConnectClient.\")\n        self.api_key = api_key\n        # Initialize KiteConnect instance without access token initially\n        self.kite = KiteConnect(api_key=self.api_key)\n        self.timeout = timeout\n        # Note: access_token is set dynamically via set_access_token or during method calls\n\n    def _handle_kite_exception(self, e: Exception, context: str):\n        \"\"\"Handles common Kite Connect exceptions and raises KiteConnectClientError.\"\"\"\n        error_message = f\"Kite API Error ({context}): {type(e).__name__} - {str(e)}\"\n        logger.error(error_message)\n        if isinstance(e, kite_exceptions.TokenException):\n            raise KiteConnectClientError(f\"Authentication error: {str(e)}. Please regenerate the session.\") from e\n        elif isinstance(e, kite_exceptions.PermissionException):\n            raise KiteConnectClientError(f\"Permission denied: {str(e)}.\") from e\n        elif isinstance(e, kite_exceptions.InputException):\n            raise KiteConnectClientError(f\"Invalid input: {str(e)}.\") from e\n        elif isinstance(e, kite_exceptions.OrderException):\n            raise KiteConnectClientError(f\"Order placement/modification error: {str(e)}.\") from e\n        elif isinstance(e, kite_exceptions.NetworkException):\n            raise KiteConnectClientError(f\"Network error communicating with Kite API: {str(e)}.\") from e\n        elif isinstance(e, kite_exceptions.GeneralException):\n            raise KiteConnectClientError(f\"General Kite API error: {str(e)}.\") from e\n        else:\n            # Catch any other unexpected Kite exceptions\n            raise KiteConnectClientError(error_message) from e\n\n    def generate_session(self, request_token: str, api_secret: str) -> Dict[str, Any]:\n        \"\"\"\n        Generates a user session using the request token and API secret.\n\n        Args:\n            request_token: The one-time request token.\n            api_secret: Your Kite Connect API secret.\n\n        Returns:\n            Dictionary containing session details (access_token, public_token, etc.).\n\n        Raises:\n            KiteConnectClientError: If session generation fails.\n        \"\"\"\n        if not api_secret:\n            raise ValueError(\"API secret is required to generate a session.\")\n        try:\n            logger.debug(\"Generating Kite session...\")\n            session_data = self.kite.generate_session(request_token, api_secret=api_secret)\n            logger.info(f\"Kite session generated successfully for user: {session_data.get('user_id')}\")\n            # It's recommended NOT to store the access token within the client instance\n            # long-term in a multi-user or stateless environment like MCP.\n            # Pass it explicitly to methods requiring authentication.\n            return session_data\n        except Exception as e:\n            self._handle_kite_exception(e, \"generate_session\")\n\n    def place_order(self, access_token: str, params: PlaceOrderParams) -> str:\n        \"\"\"\n        Places an order.\n\n        Args:\n            access_token: The valid access token for the session.\n            params: An instance of PlaceOrderParams containing order details.\n\n        Returns:\n            The order ID of the placed order.\n\n        Raises:\n            KiteConnectClientError: If placing the order fails.\n        \"\"\"\n        self.kite.set_access_token(access_token)\n        try:\n            # Prepare parameters for the kiteconnect library call\n            order_params = {\n                \"exchange\": params.exchange,\n                \"tradingsymbol\": params.tradingsymbol,\n                \"transaction_type\": params.transaction_type,\n                \"quantity\": params.quantity,\n                \"product\": params.product,\n                \"order_type\": params.order_type,\n                \"price\": params.price,\n                \"trigger_price\": params.trigger_price,\n                \"disclosed_quantity\": params.disclosed_quantity,\n                \"validity\": params.validity,\n                \"validity_ttl\": params.validity_ttl,\n                \"iceberg_legs\": params.iceberg_legs,\n                \"iceberg_quantity\": params.iceberg_quantity,\n                \"auction_number\": params.auction_number,\n                \"tag\": params.tag\n            }\n            # Remove None values as kiteconnect expects absent keys, not None values\n            order_params = {k: v for k, v in order_params.items() if v is not None}\n\n            logger.debug(f\"Placing order with variety '{params.variety}' and params: {order_params}\")\n            order_id = self.kite.place_order(variety=params.variety, **order_params)\n            logger.info(f\"Order placed successfully. Order ID: {order_id}\")\n            return order_id\n        except Exception as e:\n            self._handle_kite_exception(e, f\"place_order ({params.tradingsymbol})\")\n        finally:\n            # Clear the access token after use if managing state per-request\n            self.kite.set_access_token(None)\n\n    def modify_order(self, access_token: str, params: ModifyOrderParams) -> str:\n        \"\"\"\n        Modifies a pending order.\n\n        Args:\n            access_token: The valid access token for the session.\n            params: An instance of ModifyOrderParams containing modification details.\n\n        Returns:\n            The order ID of the modified order.\n\n        Raises:\n            KiteConnectClientError: If modifying the order fails.\n        \"\"\"\n        self.kite.set_access_token(access_token)\n        try:\n            # Prepare parameters for the kiteconnect library call\n            modify_params = {\n                \"parent_order_id\": params.parent_order_id,\n                \"quantity\": params.quantity,\n                \"price\": params.price,\n                \"trigger_price\": params.trigger_price,\n                \"order_type\": params.order_type,\n                \"disclosed_quantity\": params.disclosed_quantity,\n                \"validity\": params.validity\n            }\n            # Remove None values\n            modify_params = {k: v for k, v in modify_params.items() if v is not None}\n\n            logger.debug(f\"Modifying order '{params.order_id}' with variety '{params.variety}' and params: {modify_params}\")\n            order_id = self.kite.modify_order(\n                variety=params.variety,\n                order_id=params.order_id,\n                **modify_params\n            )\n            logger.info(f\"Order '{params.order_id}' modified successfully. Result Order ID: {order_id}\")\n            return order_id\n        except Exception as e:\n            self._handle_kite_exception(e, f\"modify_order ({params.order_id})\")\n        finally:\n            # Clear the access token after use\n            self.kite.set_access_token(None)\n\n    # Add other Kite Connect API methods as needed (e.g., get_holdings, get_positions, get_quote, etc.)\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=1.8,<2.0\npython-dotenv>=0.19.0\nkiteconnect>=3.9.0,<4.0.0\nhttpx>=0.20.0\nuvicorn>=0.15.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Zerodha Kite Connect API Credentials\n# Obtain these from https://developers.kite.trade/\n\n# Your Kite Connect application API Key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# Your Kite Connect application API Secret\nKITE_API_SECRET=\"YOUR_API_SECRET\"\n\n# Optional: You might store a long-lived access token for testing, but the primary\n# flow involves generating one using generate_session tool with a request_token.\n# KITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n"
    },
    {
      "name": "README.md",
      "content": "# KiteConnect MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect API (v3). It allows agents or applications to perform trading-related actions like generating sessions, placing orders, and modifying orders through a standardized MCP interface.\n\n## Features\n\n*   **Session Management**: Generate user sessions using a `request_token`.\n*   **Order Placement**: Place various types of orders (regular, AMO, CO, Iceberg, Auction).\n*   **Order Modification**: Modify pending regular and cover orders.\n*   **Typed Interface**: Uses Pydantic models for clear and validated inputs.\n*   **Error Handling**: Provides informative error messages from the Kite Connect API.\n\n## Setup\n\n1.  **Clone the repository (or create the files):**\n    ```bash\n    # If cloned\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect API Key and API Secret:\n        ```dotenv\n        KITE_API_KEY=\"YOUR_API_KEY\"\n        KITE_API_SECRET=\"YOUR_API_SECRET\"\n        ```\n        *(You get these credentials after creating an app on the [Kite Developer Console](https://developers.kite.trade/)).*\n\n## Running the Server\n\nUse Uvicorn to run the FastMCP application:\n\n```bash\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n*   `--reload`: Automatically restarts the server when code changes (useful for development).\n\nThe MCP server will be available at `http://localhost:8000`.\n\n## Authentication Flow\n\n1.  **Obtain `request_token`**: The user must first log in via the Kite Connect API login flow provided by Zerodha. After successful login and consent, Kite Connect redirects the user back to your registered redirect URL with a `request_token` appended as a query parameter.\n2.  **Generate Session**: Use the `generate_session` tool provided by this MCP server, passing the obtained `request_token`.\n    ```json\n    {\n      \"tool_name\": \"generate_session\",\n      \"arguments\": {\n        \"params\": {\n          \"request_token\": \"THE_OBTAINED_REQUEST_TOKEN\"\n        }\n      }\n    }\n    ```\n3.  **Receive `access_token`**: The tool will return a JSON response containing session details, including the crucial `access_token`.\n    ```json\n    {\n        \"user_id\": \"AB1234\",\n        \"user_name\": \"Example Name\",\n        // ... other fields\n        \"access_token\": \"THE_GENERATED_ACCESS_TOKEN\",\n        \"public_token\": \"...\"\n        // ...\n    }\n    ```\n4.  **Use `access_token`**: Store this `access_token` securely. Pass it as the first argument (`access_token`) to all subsequent authenticated tool calls (`place_order`, `modify_order`). The access token is typically valid for one day.\n\n## Available Tools\n\n### 1. `generate_session`\n\n*   **Description**: Generate a user session and obtain an access token using a request token.\n*   **Input**: `GenerateSessionParams` model (`request_token`: string)\n*   **Returns**: Dictionary containing session details, including `access_token`.\n\n### 2. `place_order`\n\n*   **Description**: Place an order of a specific variety.\n*   **Input**: `access_token`: string, `params`: `PlaceOrderParams` model (see `models.py` for fields like `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `quantity`, `product`, `order_type`, etc.)\n*   **Returns**: Dictionary containing the `order_id` or an `error` message.\n*   **Example Argument Structure**:\n    ```json\n    {\n        \"access_token\": \"THE_STORED_ACCESS_TOKEN\",\n        \"params\": {\n            \"variety\": \"regular\",\n            \"exchange\": \"NSE\",\n            \"tradingsymbol\": \"INFY\",\n            \"transaction_type\": \"BUY\",\n            \"quantity\": 1,\n            \"product\": \"CNC\",\n            \"order_type\": \"LIMIT\",\n            \"price\": 1500.00\n        }\n    }\n    ```\n\n### 3. `modify_order`\n\n*   **Description**: Modify a pending regular or cover order.\n*   **Input**: `access_token`: string, `params`: `ModifyOrderParams` model (see `models.py` for fields like `variety`, `order_id`, `quantity`, `price`, etc.)\n*   **Returns**: Dictionary containing the `order_id` of the modified order or an `error` message.\n*   **Example Argument Structure**:\n    ```json\n    {\n        \"access_token\": \"THE_STORED_ACCESS_TOKEN\",\n        \"params\": {\n            \"variety\": \"regular\",\n            \"order_id\": \"230101000000001\",\n            \"quantity\": 2, \n            \"price\": 1505.50\n        }\n    }\n    ```\n\n## Error Handling\n\nThe tools will return a JSON object with an `\"error\"` key if an operation fails. The value will contain a descriptive message, often originating from the Kite Connect API itself (e.g., insufficient funds, invalid parameters, authentication errors).\n\n## Development\n\n*   **Adding More Tools**: To add more Kite Connect API functions (e.g., `get_holdings`, `get_positions`), define corresponding methods in `client.py`, create Pydantic models in `models.py` if needed, and register new tools in `main.py` using `@mcp.tool()`.\n*   **Testing**: Requires a valid Kite Connect API key/secret and the ability to generate `request_token`s through the login flow.\n"
    }
  ]
}
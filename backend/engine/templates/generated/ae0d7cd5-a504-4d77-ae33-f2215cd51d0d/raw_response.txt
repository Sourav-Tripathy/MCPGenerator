{
  "files": [
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field\nfrom typing import Optional, Literal, Dict\n\n# Define constants for reusable literals\nOrderVariety = Literal['regular', 'amo', 'co', 'iceberg', 'auction']\nExchange = Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']\nTransactionType = Literal['BUY', 'SELL']\nOrderType = Literal['MARKET', 'LIMIT', 'SL', 'SL-M']\nProductType = Literal['CNC', 'NRML', 'MIS', 'MTF']\nValidityType = Literal['DAY', 'IOC', 'TTL']\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\"\"\"\n    variety: OrderVariety = Field(..., description=\"The variety of the order.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., 'INFY', 'NIFTY23JUL17500CE').\")\n    exchange: Exchange = Field(..., description=\"Name of the exchange.\")\n    transaction_type: TransactionType = Field(..., description=\"Transaction type.\")\n    order_type: OrderType = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., description=\"Quantity to transact.\")\n    product: ProductType = Field(..., description=\"Product type.\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders.\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity: ValidityType = Field(..., description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10). Required if variety is 'iceberg'.\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs). Required if variety is 'iceberg'.\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction. Required if variety is 'auction'.\")\n    tag: Optional[str] = Field(None, description=\"An optional tag (alphanumeric, max 20 chars) to apply to the order.\")\n\n    class Config:\n        use_enum_values = True # Ensure literals are passed as strings\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Parameters for modifying an order.\"\"\"\n    variety: OrderVariety = Field(..., description=\"The variety of the order being modified.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for modifying second leg of CO orders.\")\n    order_type: Optional[OrderType] = Field(None, description=\"New order type (regular variety).\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (regular variety).\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT, CO orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, CO orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (regular variety).\")\n    validity: Optional[ValidityType] = Field(None, description=\"New validity (regular variety).\")\n\n    class Config:\n        use_enum_values = True # Ensure literals are passed as strings\n\nclass OrderResponse(BaseModel):\n    \"\"\"Standard response containing the order ID.\"\"\"\n    order_id: str = Field(..., description=\"The unique identifier for the order.\")\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response.\"\"\"\n    error: str = Field(..., description=\"Description of the error that occurred.\")\n    details: Optional[Dict] = Field(None, description=\"Optional details about the error.\")\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nimport os\nfrom typing import Dict, Any, Optional, Union\nfrom models import PlaceOrderParams, ModifyOrderParams, OrderResponse\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n# Simple in-memory rate limiter\nclass RateLimiter:\n    def __init__(self, rate: int, period: float):\n        self.rate = rate\n        self.period = period\n        self.tokens = rate\n        self.last_refill_time = asyncio.get_event_loop().time()\n        self.lock = asyncio.Lock()\n\n    async def acquire(self):\n        async with self.lock:\n            now = asyncio.get_event_loop().time()\n            time_passed = now - self.last_refill_time\n            refill_amount = time_passed * (self.rate / self.period)\n\n            self.tokens = min(self.rate, self.tokens + refill_amount)\n            self.last_refill_time = now\n\n            if self.tokens >= 1:\n                self.tokens -= 1\n                return True\n            else:\n                # Calculate wait time\n                wait_time = (1 - self.tokens) * (self.period / self.rate)\n                logger.warning(f\"Rate limit exceeded. Waiting for {wait_time:.2f} seconds.\")\n                await asyncio.sleep(wait_time)\n                # Re-check after waiting (another task might have consumed the token)\n                # For simplicity in this example, we assume the wait was sufficient\n                # and consume the token conceptually generated during the wait.\n                self.tokens = 0 # Reset tokens after waiting to avoid bursting\n                self.last_refill_time = asyncio.get_event_loop().time() # Update time after wait\n                return True\n\nclass KiteConnectError(Exception):\n    \"\"\"Custom exception for Kite Connect API errors.\"\"\"\n    def __init__(self, status_code: int, message: str, details: Optional[Dict] = None):\n        self.status_code = status_code\n        self.message = message\n        self.details = details\n        super().__init__(f\"Kite API Error {status_code}: {message}\")\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect v3 API.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\"):\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\"\n            # Content-Type is set by httpx based on data/json parameter\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=30.0 # Set a reasonable timeout\n        )\n        # Kite Connect rate limit: 10 requests per second\n        self.rate_limiter = RateLimiter(rate=10, period=1.0)\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous request to the Kite Connect API.\"\"\"\n        await self.rate_limiter.acquire()\n        url = f\"{self.base_url}{endpoint}\"\n        logger.info(f\"Sending {method} request to {url} with data: {data}\")\n        try:\n            response = await self.client.request(method, endpoint, data=data)\n            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx responses\n            \n            json_response = response.json()\n            logger.info(f\"Received successful response ({response.status_code}) from {url}\")\n            # Kite API specific success check (often contains a 'data' field)\n            if json_response.get(\"status\") == \"error\":\n                 logger.error(f\"Kite API returned error status: {json_response.get('message')}\")\n                 raise KiteConnectError(status_code=response.status_code, message=json_response.get('message', 'Unknown API error'), details=json_response)\n            \n            return json_response.get(\"data\", {}) # Orders API usually returns data directly inside 'data'\n\n        except httpx.HTTPStatusError as e:\n            status_code = e.response.status_code\n            try:\n                error_details = e.response.json()\n                message = error_details.get(\"message\", \"No error message provided.\")\n                logger.error(f\"HTTP error {status_code} from {url}: {message}\", exc_info=True)\n                raise KiteConnectError(status_code=status_code, message=message, details=error_details) from e\n            except Exception:\n                # If parsing response fails, use default text\n                message = str(e)\n                logger.error(f\"HTTP error {status_code} from {url}: {message}\", exc_info=True)\n                raise KiteConnectError(status_code=status_code, message=message) from e\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out for {url}: {str(e)}\", exc_info=True)\n            raise KiteConnectError(status_code=408, message=f\"Request timed out: {str(e)}\") from e\n        except httpx.RequestError as e:\n            logger.error(f\"Network or request error for {url}: {str(e)}\", exc_info=True)\n            raise KiteConnectError(status_code=503, message=f\"Network error: {str(e)}\") from e\n        except KiteConnectError: # Re-raise specific Kite errors\n            raise\n        except Exception as e:\n            logger.error(f\"An unexpected error occurred during request to {url}: {str(e)}\", exc_info=True)\n            raise KiteConnectError(status_code=500, message=f\"An unexpected error occurred: {str(e)}\") from e\n\n    async def place_order(self, params: PlaceOrderParams) -> OrderResponse:\n        \"\"\"Place an order.\"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Prepare form data, excluding 'variety' and None values\n        data = {k: v for k, v in params.dict(exclude={'variety'}).items() if v is not None}\n        \n        # Ensure numerical values are sent correctly for form data\n        for key in ['quantity', 'price', 'trigger_price', 'disclosed_quantity', 'validity_ttl', 'iceberg_legs', 'iceberg_quantity']:\n            if key in data:\n                data[key] = str(data[key])\n\n        response_data = await self._request(\"POST\", endpoint, data=data)\n        if 'order_id' not in response_data:\n             logger.error(f\"'order_id' not found in response data: {response_data}\")\n             raise KiteConnectError(status_code=500, message=\"'order_id' not found in response\", details=response_data)\n        return OrderResponse(order_id=response_data['order_id'])\n\n    async def modify_order(self, params: ModifyOrderParams) -> OrderResponse:\n        \"\"\"Modify an existing order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Prepare form data, excluding 'variety', 'order_id', and None values\n        data = {k: v for k, v in params.dict(exclude={'variety', 'order_id'}).items() if v is not None}\n        \n        # Ensure numerical values are sent correctly for form data\n        for key in ['quantity', 'price', 'trigger_price', 'disclosed_quantity']:\n             if key in data:\n                data[key] = str(data[key])\n\n        response_data = await self._request(\"PUT\", endpoint, data=data)\n        if 'order_id' not in response_data:\n             logger.error(f\"'order_id' not found in response data: {response_data}\")\n             raise KiteConnectError(status_code=500, message=\"'order_id' not found in response\", details=response_data)\n        return OrderResponse(order_id=response_data['order_id'])\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, Union\nfrom pydantic import ValidationError\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom models import PlaceOrderParams, ModifyOrderParams, OrderResponse, ErrorResponse\nfrom client import KiteConnectClient, KiteConnectError\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectOrders\",\n    description=\"Provides tools to manage trading orders (place, modify, cancel, retrieve) using the Kite Connect v3 API.\"\n)\n\n# Initialize Kite Connect Client\nKITE_API_KEY = os.getenv(\"KITE_API_KEY\")\nKITE_ACCESS_TOKEN = os.getenv(\"KITE_ACCESS_TOKEN\")\nKITE_API_BASE_URL = os.getenv(\"KITE_API_BASE_URL\", \"https://api.kite.trade\")\n\nif not KITE_API_KEY or not KITE_ACCESS_TOKEN:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n    # Optionally raise an error or exit if credentials are required at startup\n    # raise ValueError(\"Kite Connect credentials not found in environment variables.\")\n    kite_client = None # Allow server to start but tools will fail\nelse:\n    try:\n        kite_client = KiteConnectClient(\n            api_key=KITE_API_KEY,\n            access_token=KITE_ACCESS_TOKEN,\n            base_url=KITE_API_BASE_URL\n        )\n    except ValueError as e:\n        logger.error(f\"Error initializing KiteConnectClient: {e}\")\n        kite_client = None\n\n@mcp.startup\nasync def startup_event():\n    logger.info(\"KiteConnectOrders MCP Server starting up.\")\n    # You could potentially add a check here to ensure the client is initialized\n    if kite_client is None:\n        logger.warning(\"KiteConnectClient is not initialized. API calls will fail.\")\n\n@mcp.shutdown\nasync def shutdown_event():\n    if kite_client:\n        await kite_client.close()\n    logger.info(\"KiteConnectOrders MCP Server shutting down.\")\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Union[OrderResponse, ErrorResponse]:\n    \"\"\"Place an order of a specific variety (regular, amo, co, iceberg, auction).\"\"\"\n    if kite_client is None:\n        logger.error(\"place_order tool called but Kite client is not initialized.\")\n        return ErrorResponse(error=\"Client not initialized due to missing credentials.\")\n    \n    try:\n        logger.info(f\"Received place_order request with params: {params.dict()}\")\n        result = await kite_client.place_order(params)\n        logger.info(f\"Successfully placed order: {result.order_id}\")\n        return result\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error during place_order: {e.message}\", exc_info=True)\n        return ErrorResponse(error=f\"Kite API Error ({e.status_code}): {e.message}\", details=e.details)\n    except ValidationError as e:\n        logger.error(f\"Validation error in place_order parameters: {e}\", exc_info=True)\n        return ErrorResponse(error=\"Input validation failed\", details=e.errors())\n    except Exception as e:\n        logger.error(f\"Unexpected error during place_order: {str(e)}\", exc_info=True)\n        return ErrorResponse(error=f\"An unexpected error occurred: {str(e)}\")\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Union[OrderResponse, ErrorResponse]:\n    \"\"\"Modify an open or pending order of a given variety.\"\"\"\n    if kite_client is None:\n        logger.error(\"modify_order tool called but Kite client is not initialized.\")\n        return ErrorResponse(error=\"Client not initialized due to missing credentials.\")\n        \n    try:\n        logger.info(f\"Received modify_order request with params: {params.dict()}\")\n        result = await kite_client.modify_order(params)\n        logger.info(f\"Successfully modified order: {result.order_id}\")\n        return result\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error during modify_order: {e.message}\", exc_info=True)\n        return ErrorResponse(error=f\"Kite API Error ({e.status_code}): {e.message}\", details=e.details)\n    except ValidationError as e:\n        logger.error(f\"Validation error in modify_order parameters: {e}\", exc_info=True)\n        return ErrorResponse(error=\"Input validation failed\", details=e.errors())\n    except Exception as e:\n        logger.error(f\"Unexpected error during modify_order: {str(e)}\", exc_info=True)\n        return ErrorResponse(error=f\"An unexpected error occurred: {str(e)}\")\n\n# Example of how to run the server directly (though usually done via uvicorn command)\nif __name__ == \"__main__\":\n    import uvicorn\n    logger.info(\"Starting server using uvicorn...\")\n    # Note: Running directly might have issues with hot-reloading compared to CLI\n    uvicorn.run(mcp, host=\"0.0.0.0\", port=8000)\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=2.0.0,<3.0.0\nhttpx>=0.25.0,<0.28.0\npython-dotenv>=1.0.0,<2.0.0\nuvicorn>=0.23.0,<0.28.0\n# asyncio is part of standard library\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer account (https://developers.kite.trade/)\n\n# Your Kite application's API key\nKITE_API_KEY=\n\n# The access token obtained after a successful login flow (valid for one day)\n# You need a mechanism to generate/refresh this token daily.\nKITE_ACCESS_TOKEN=\n\n# The base URL for the Kite Connect API (usually doesn't need changing)\nKITE_API_BASE_URL=https://api.kite.trade\n"
    },
    {
      "name": "README.md",
      "content": "# KiteConnect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server that acts as a wrapper around the Zerodha Kite Connect v3 API, specifically focusing on order management functionalities.\n\nIt allows language models or other MCP clients to interact with Kite Connect to place and modify trading orders programmatically.\n\n## Features\n\n*   **Place Orders:** Place various types of orders (regular, AMO, CO, Iceberg, Auction) across different exchanges.\n*   **Modify Orders:** Modify attributes of existing pending orders (e.g., price, quantity, trigger price).\n*   **Asynchronous:** Built with `asyncio` and `httpx` for non-blocking I/O.\n*   **Typed:** Uses Pydantic for request and response validation.\n*   **Error Handling:** Provides structured error responses for API and validation issues.\n*   **Configurable:** API keys and tokens are managed via environment variables.\n*   **Rate Limiting:** Includes a basic rate limiter to comply with Kite API limits (10 requests/second).\n\n## Implemented Tools\n\n1.  **`place_order`**: \n    *   Description: Place an order of a specific variety (regular, amo, co, iceberg, auction).\n    *   Input: `PlaceOrderParams` model (see `models.py` for details).\n    *   Output: `OrderResponse` containing the `order_id` or `ErrorResponse`.\n\n2.  **`modify_order`**: \n    *   Description: Modify an open or pending order of a given variety.\n    *   Input: `ModifyOrderParams` model (see `models.py` for details).\n    *   Output: `OrderResponse` containing the `order_id` or `ErrorResponse`.\n\n## Setup\n\n1.  **Clone the Repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a Virtual Environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install Dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect API credentials:\n        *   `KITE_API_KEY`: Your application's API key from the Kite Developer console.\n        *   `KITE_ACCESS_TOKEN`: A valid access token. **Important:** Access tokens are typically valid for only one trading day. You need a separate process or script to generate a new access token daily using the Kite Connect login flow and update the `.env` file or environment variable accordingly before running the server.\n        *   `KITE_API_BASE_URL`: Defaults to `https://api.kite.trade`. Usually does not need to be changed.\n\n## Running the Server\n\nYou can run the MCP server using an ASGI server like Uvicorn:\n\n```bash\nuvicorn main:mcp --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--host 0.0.0.0`: Makes the server accessible on your network.\n*   `--port 8000`: Specifies the port to run on.\n*   `--reload`: Enables auto-reloading when code changes (useful for development).\n\nThe server will start, and MCP clients can connect to it at `http://<your-server-ip>:8000`.\n\n## Usage\n\nOnce the server is running, MCP clients can discover and call the available tools (`place_order`, `modify_order`) by sending requests according to the Model Context Protocol specification.\nThe input parameters for each tool must conform to the Pydantic models defined in `models.py`.\n\n## Error Handling\n\nThe server returns structured `ErrorResponse` objects in case of failures:\n*   **Validation Errors:** If the input parameters provided by the client do not match the required schema.\n*   **Kite API Errors:** If the Kite Connect API returns an error (e.g., insufficient funds, invalid order parameters, invalid session).\nThe error message and status code from the API are included.\n*   **Network/Timeout Errors:** If the server cannot reach the Kite Connect API.\n*   **Initialization Errors:** If the server failed to start correctly (e.g., missing API keys).\n*   **Unexpected Errors:** For any other server-side issues.\n\n## Rate Limiting\n\nThe Kite Connect API has rate limits (typically 10 requests per second per user+API key). The client includes a simple asynchronous rate limiter to help prevent exceeding these limits. If the limit is hit, requests will be delayed automatically.\n\n## Disclaimer\n\nTrading involves substantial risk. This software is provided \"as is\" without warranty of any kind. Ensure you understand the risks and the behavior of the Kite Connect API before using this tool for live trading. The authors are not responsible for any financial losses incurred.\n"
    }
  ]
}
{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, Optional\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams, OrderResponse, ErrorResponse\nfrom client import KiteConnectClient, KiteConnectError\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectMCP\",\n    description=\"Provides tools to interact with the Kite Connect v3 API for managing trading orders and retrieving trade information. This MCP facilitates placing, modifying, canceling, and retrieving orders and trades.\"\n)\n\n# Initialize Kite Connect Client\n# Ensure KITE_API_KEY and KITE_ACCESS_TOKEN are set in your environment or .env file\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n    # Consider raising an exception or exiting if credentials are required at startup\n    # raise ValueError(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set\")\n    kite_client = None # Client will not be functional\nelse:\n    try:\n        kite_client = KiteConnectClient(api_key=api_key, access_token=access_token, base_url=base_url)\n    except Exception as e:\n        logger.error(f\"Failed to initialize KiteConnectClient: {e}\")\n        kite_client = None\n\n@mcp.tool()\ndef place_order(\n    variety: str,\n    tradingsymbol: str,\n    exchange: str,\n    transaction_type: str,\n    order_type: str,\n    quantity: int,\n    product: str,\n    price: Optional[float] = None,\n    trigger_price: Optional[float] = None,\n    disclosed_quantity: Optional[int] = None,\n    validity: Optional[str] = \"DAY\",\n    validity_ttl: Optional[int] = None,\n    iceberg_legs: Optional[int] = None,\n    iceberg_quantity: Optional[int] = None,\n    auction_number: Optional[str] = None,\n    tag: Optional[str] = None\n) -> Dict[str, Any]:\n    \"\"\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\"\"\"\n    if not kite_client:\n        logger.error(\"KiteConnectClient is not initialized. Cannot place order.\")\n        return ErrorResponse(error=\"Client not initialized. Check API Key/Access Token.\").dict()\n\n    try:\n        params = PlaceOrderParams(\n            variety=variety,\n            tradingsymbol=tradingsymbol,\n            exchange=exchange,\n            transaction_type=transaction_type,\n            order_type=order_type,\n            quantity=quantity,\n            product=product,\n            price=price,\n            trigger_price=trigger_price,\n            disclosed_quantity=disclosed_quantity,\n            validity=validity,\n            validity_ttl=validity_ttl,\n            iceberg_legs=iceberg_legs,\n            iceberg_quantity=iceberg_quantity,\n            auction_number=auction_number,\n            tag=tag\n        )\n        logger.info(f\"Attempting to place order: {params.dict(exclude_none=True)}\")\n        result = await kite_client.place_order(params)\n        logger.info(f\"Order placed successfully: {result}\")\n        # Ensure the response matches the expected OrderResponse structure\n        if isinstance(result, dict) and 'data' in result and 'order_id' in result['data']:\n             return OrderResponse(order_id=result['data']['order_id']).dict()\n        else:\n             logger.error(f\"Unexpected response format from place_order: {result}\")\n             return ErrorResponse(error=\"Unexpected response format from API\", details=str(result)).dict()\n\n    except KiteConnectError as e:\n        logger.error(f\"Kite API Error placing order: {e}\")\n        return ErrorResponse(error=e.message, status_code=e.status_code, details=e.details).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error placing order: {e}\")\n        return ErrorResponse(error=\"An unexpected error occurred\", details=str(e)).dict()\n\n@mcp.tool()\ndef modify_order(\n    variety: str,\n    order_id: str,\n    order_type: Optional[str] = None,\n    quantity: Optional[int] = None,\n    price: Optional[float] = None,\n    trigger_price: Optional[float] = None,\n    disclosed_quantity: Optional[int] = None,\n    validity: Optional[str] = None\n) -> Dict[str, Any]:\n    \"\"\"Modify attributes of a pending regular or cover order.\"\"\"\n    if not kite_client:\n        logger.error(\"KiteConnectClient is not initialized. Cannot modify order.\")\n        return ErrorResponse(error=\"Client not initialized. Check API Key/Access Token.\").dict()\n\n    try:\n        params = ModifyOrderParams(\n            variety=variety,\n            order_id=order_id,\n            order_type=order_type,\n            quantity=quantity,\n            price=price,\n            trigger_price=trigger_price,\n            disclosed_quantity=disclosed_quantity,\n            validity=validity\n        )\n        logger.info(f\"Attempting to modify order {order_id}: {params.dict(exclude={'order_id', 'variety'}, exclude_none=True)}\")\n        result = await kite_client.modify_order(params)\n        logger.info(f\"Order {order_id} modified successfully: {result}\")\n        # Ensure the response matches the expected OrderResponse structure\n        if isinstance(result, dict) and 'data' in result and 'order_id' in result['data']:\n             return OrderResponse(order_id=result['data']['order_id']).dict()\n        else:\n             logger.error(f\"Unexpected response format from modify_order: {result}\")\n             return ErrorResponse(error=\"Unexpected response format from API\", details=str(result)).dict()\n\n    except KiteConnectError as e:\n        logger.error(f\"Kite API Error modifying order {order_id}: {e}\")\n        return ErrorResponse(error=e.message, status_code=e.status_code, details=e.details).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error modifying order {order_id}: {e}\")\n        return ErrorResponse(error=\"An unexpected error occurred\", details=str(e)).dict()\n\n@mcp.tool()\ndef cancel_order(\n    variety: str,\n    order_id: str,\n    parent_order_id: Optional[str] = None\n) -> Dict[str, Any]:\n    \"\"\"Cancel a pending order.\"\"\"\n    if not kite_client:\n        logger.error(\"KiteConnectClient is not initialized. Cannot cancel order.\")\n        return ErrorResponse(error=\"Client not initialized. Check API Key/Access Token.\").dict()\n\n    try:\n        params = CancelOrderParams(\n            variety=variety,\n            order_id=order_id,\n            parent_order_id=parent_order_id\n        )\n        logger.info(f\"Attempting to cancel order {order_id} (variety: {variety}, parent: {parent_order_id})\")\n        result = await kite_client.cancel_order(params)\n        logger.info(f\"Order {order_id} cancelled successfully: {result}\")\n        # Ensure the response matches the expected OrderResponse structure\n        if isinstance(result, dict) and 'data' in result and 'order_id' in result['data']:\n             return OrderResponse(order_id=result['data']['order_id']).dict()\n        else:\n             logger.error(f\"Unexpected response format from cancel_order: {result}\")\n             return ErrorResponse(error=\"Unexpected response format from API\", details=str(result)).dict()\n\n    except KiteConnectError as e:\n        logger.error(f\"Kite API Error cancelling order {order_id}: {e}\")\n        return ErrorResponse(error=e.message, status_code=e.status_code, details=e.details).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error cancelling order {order_id}: {e}\")\n        return ErrorResponse(error=\"An unexpected error occurred\", details=str(e)).dict()\n\n\nif __name__ == \"__main__\":\n    # Example usage (for testing, replace with actual server run command)\n    # You would typically run this with: uvicorn main:mcp.app --reload\n    import uvicorn\n    logger.info(\"Starting KiteConnectMCP server...\")\n    if not kite_client:\n         logger.warning(\"Kite Client is not initialized due to missing credentials. API calls will fail.\")\n    uvicorn.run(\"main:mcp.app\", host=\"0.0.0.0\", port=8000, reload=True)\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field\nfrom typing import Optional, Dict, Any, Literal\n\n# --- Input Models ---\n\nclass PlaceOrderParams(BaseModel):\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument\")\n    exchange: Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'] = Field(..., description=\"Name of the exchange\")\n    transaction_type: Literal['BUY', 'SELL'] = Field(..., description=\"Transaction type\")\n    order_type: Literal['MARKET', 'LIMIT', 'SL', 'SL-M'] = Field(..., description=\"Order type\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact\")\n    product: Literal['CNC', 'NRML', 'MIS', 'MTF'] = Field(..., description=\"Product type\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (required for LIMIT orders)\")\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (required for SL, SL-M orders)\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades)\")\n    validity: Optional[Literal['DAY', 'IOC', 'TTL']] = Field(\"DAY\", description=\"Order validity. Default is DAY.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders\")\n    iceberg_legs: Optional[int] = Field(None, ge=2, le=10, description=\"Total number of legs for iceberg order type (2-10)\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs)\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction (for auction orders)\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"An optional tag to apply to an order (alphanumeric, max 20 chars)\")\n\n    class Config:\n        extra = 'forbid' # Prevent unexpected fields\n\nclass ModifyOrderParams(BaseModel):\n    variety: Literal['regular', 'co'] = Field(..., description=\"Order variety\")\n    order_id: str = Field(..., description=\"The ID of the order to modify\")\n    order_type: Optional[Literal['MARKET', 'LIMIT', 'SL', 'SL-M']] = Field(None, description=\"New order type (only for regular orders)\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity (only for regular orders)\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders)\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, CO orders)\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (only for regular equity orders)\")\n    validity: Optional[Literal['DAY', 'IOC']] = Field(None, description=\"New validity (only for regular orders, e.g., DAY)\") # TTL not allowed for modification\n\n    class Config:\n        extra = 'forbid'\n\nclass CancelOrderParams(BaseModel):\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for cancelling second-leg CO orders\")\n\n    class Config:\n        extra = 'forbid'\n\n# --- Output/Response Models ---\n\nclass OrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID\")\n\nclass ErrorResponse(BaseModel):\n    error: str = Field(..., description=\"General error message\")\n    status_code: Optional[int] = Field(None, description=\"HTTP status code, if applicable\")\n    details: Optional[Any] = Field(None, description=\"Additional error details from the API or system\")\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nfrom typing import Dict, Any, Optional\n\nfrom models import PlaceOrderParams, ModifyOrderParams, CancelOrderParams\n\nlogger = logging.getLogger(__name__)\n\nKITE_API_VERSION = \"3\"\n\nclass KiteConnectError(Exception):\n    \"\"\"Custom exception class for Kite Connect API errors.\"\"\"\n    def __init__(self, message: str, status_code: Optional[int] = None, details: Optional[Any] = None):\n        super().__init__(message)\n        self.message = message\n        self.status_code = status_code\n        self.details = details\n\n    def __str__(self):\n        return f\"KiteConnectError(status_code={self.status_code}, message='{self.message}', details={self.details})\"\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect v3 API.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        \"\"\"\n        Initializes the Kite Connect API client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after successful login.\n            base_url: The base URL for the Kite Connect API.\n            timeout: Default request timeout in seconds.\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.timeout = timeout\n\n        self.headers = {\n            \"X-Kite-Version\": KITE_API_VERSION,\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form encoding\n        }\n\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=self.timeout\n        )\n        logger.info(f\"KiteConnectClient initialized for base URL: {self.base_url}\")\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite Connect API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Sending {method} request to {url} with data: {data}\")\n\n        try:\n            response = await self.client.request(method, endpoint, data=data)\n            response.raise_for_status()  # Raises HTTPStatusError for 4xx/5xx responses\n            json_response = response.json()\n            logger.debug(f\"Received successful response ({response.status_code}) from {url}: {json_response}\")\n\n            # Check for Kite specific error structure within a 2xx response (though usually errors are 4xx/5xx)\n            if json_response.get(\"status\") == \"error\":\n                 error_type = json_response.get(\"error_type\", \"UnknownError\")\n                 message = json_response.get(\"message\", \"Unknown API error\")\n                 logger.error(f\"Kite API returned error in success response: {error_type} - {message}\")\n                 raise KiteConnectError(message=message, status_code=response.status_code, details=json_response)\n\n            return json_response\n\n        except httpx.HTTPStatusError as e:\n            status_code = e.response.status_code\n            try:\n                # Attempt to parse error details from Kite's JSON response\n                error_data = e.response.json()\n                message = error_data.get(\"message\", f\"HTTP Error {status_code}\")\n                error_type = error_data.get(\"error_type\", \"HTTPError\")\n                details = error_data\n                logger.error(f\"HTTP Error {status_code} from {url}: {error_type} - {message}. Details: {details}\")\n                raise KiteConnectError(message=message, status_code=status_code, details=details) from e\n            except Exception:\n                # Fallback if response is not JSON or parsing fails\n                message = f\"HTTP Error {status_code}: {e.response.text[:200]}\" # Log snippet of response\n                logger.error(f\"HTTP Error {status_code} from {url}. Response: {e.response.text[:200]}\")\n                raise KiteConnectError(message=message, status_code=status_code) from e\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out for {method} {url}: {e}\")\n            raise KiteConnectError(message=\"Request timed out\", details=str(e)) from e\n\n        except httpx.RequestError as e:\n            logger.error(f\"Network or request error for {method} {url}: {e}\")\n            raise KiteConnectError(message=\"Network or request error\", details=str(e)) from e\n\n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during request to {url}: {e}\")\n            raise KiteConnectError(message=\"An unexpected client error occurred\", details=str(e)) from e\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, Any]:\n        \"\"\"Places an order.\"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Convert model to dict, excluding None values, suitable for form encoding\n        data = {k: v for k, v in params.dict().items() if v is not None and k != 'variety'}\n        return await self._request(\"POST\", endpoint, data=data)\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, Any]:\n        \"\"\"Modifies a pending order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        data = {k: v for k, v in params.dict().items() if v is not None and k not in ['variety', 'order_id']}\n        return await self._request(\"PUT\", endpoint, data=data)\n\n    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, Any]:\n        \"\"\"Cancels a pending order.\"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # parent_order_id is sent as a query param in some older docs, but usually body param\n        # Assuming body param based on typical REST patterns and lack of specific query param mention\n        data = {k: v for k, v in params.dict().items() if v is not None and k not in ['variety', 'order_id']}\n        return await self._request(\"DELETE\", endpoint, data=data)\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=1.10,<3.0\nhttpx>=0.25.0\npython-dotenv>=1.0.0\nuvicorn>=0.23.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials\n# Obtain these from your Zerodha Kite Developer account (https://developers.kite.trade/)\nKITE_API_KEY=\"YOUR_API_KEY\"\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\" # This is short-lived and needs to be generated regularly\n\n# Optional: Override the default Kite API base URL\n# KITE_BASE_URL=\"https://api.kite.trade\"\n"
    },
    {
      "name": "README.md",
      "content": "# KiteConnectMCP Server\n\nThis project implements a Model Context Protocol (MCP) server using FastMCP to interact with the Zerodha Kite Connect v3 API. It provides tools for managing trading orders.\n\n## Description\n\nProvides tools to interact with the Kite Connect v3 API for managing trading orders and retrieving trade information. This MCP facilitates placing, modifying, canceling, and retrieving orders and trades.\n\n## Features\n\n*   Place new trading orders (regular, AMO, CO, Iceberg, Auction).\n*   Modify existing pending orders.\n*   Cancel pending orders.\n*   Built with FastMCP for easy integration with AI agents.\n*   Asynchronous API client using `httpx`.\n*   Pydantic models for type safety and validation.\n*   Environment variable based configuration.\n*   Basic error handling for API and network issues.\n\n## Available Tools\n\n1.  **`place_order`**: Place an order of a particular variety.\n    *   Requires details like `variety`, `tradingsymbol`, `exchange`, `transaction_type`, `order_type`, `quantity`, `product`, and optional parameters like `price`, `trigger_price`, etc.\n2.  **`modify_order`**: Modify attributes of a pending regular or cover order.\n    *   Requires `variety`, `order_id`, and optional new attributes like `quantity`, `price`, `trigger_price`, etc.\n3.  **`cancel_order`**: Cancel a pending order.\n    *   Requires `variety`, `order_id`, and optionally `parent_order_id` for CO second leg cancellation.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect API credentials:\n        *   `KITE_API_KEY`: Your application's API key.\n        *   `KITE_ACCESS_TOKEN`: A valid access token obtained after user authentication via Kite Connect. **Note:** Access tokens are short-lived and need to be regenerated periodically.\n        *   `KITE_BASE_URL` (Optional): Defaults to `https://api.kite.trade` if not set.\n\n    *   **Obtaining Credentials:** You need to register an app on the [Kite Developer Console](https://developers.kite.trade/) to get an `API Key`. The `access_token` is generated dynamically after a user successfully logs in through the Kite Connect login flow. Implementing the full login flow is outside the scope of this MCP server; you need to obtain a valid `access_token` through other means (e.g., using Kite's official libraries or a separate authentication script) and provide it in the `.env` file.\n\n## Running the Server\n\nUse Uvicorn to run the FastMCP application:\n\n```bash\nuvicorn main:mcp.app --host 0.0.0.0 --port 8000 --reload\n```\n\n*   `--reload`: Enables auto-reloading when code changes (useful for development).\n*   The server will be available at `http://localhost:8000`.\n*   The MCP specification will be available at `http://localhost:8000/openapi.json`.\n*   Interactive API documentation (Swagger UI) at `http://localhost:8000/docs`.\n\n## Error Handling\n\nThe server attempts to catch common errors:\n*   **Configuration Errors:** Missing API key or access token.\n*   **API Errors:** Errors returned by the Kite Connect API (e.g., invalid parameters, insufficient funds, authentication failure, rate limits) are wrapped in a `KiteConnectError` and returned as an `ErrorResponse` JSON.\n*   **Network Errors:** Timeouts or connection issues during API calls.\n*   **Validation Errors:** Incorrect input parameters passed to the tools (handled by Pydantic).\n\nError responses follow the `ErrorResponse` model structure defined in `models.py`.\n\n## Rate Limits\n\nThe Kite Connect API has rate limits (e.g., 3 requests per second for order placement/modification/cancellation). This client does *not* implement client-side rate limiting. Be mindful of these limits when calling the tools frequently to avoid `429 Too Many Requests` errors from the API.\n\n## Disclaimer\n\nTrading involves substantial risk. This software is provided \"as is\" without warranty of any kind. Use it at your own risk and ensure thorough testing before deploying in a live trading environment.\n"
    }
  ]
}
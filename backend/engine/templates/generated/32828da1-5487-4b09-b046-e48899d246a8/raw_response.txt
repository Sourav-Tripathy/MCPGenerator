{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, Optional, List\nimport logging\nimport os\nfrom dotenv import load_dotenv\nimport httpx\n\n# Import models and client\nfrom models import (\n    PlaceOrderInput, PlaceOrderResponse,\n    ModifyOrderInput, ModifyOrderResponse,\n    CancelOrderInput, CancelOrderResponse,\n    GetOrdersInput, OrderDetails\n)\nfrom client import KiteConnectClient, KiteApiException\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectOrders\",\n    description=\"MCP server for interacting with the Kite Connect Orders API (v3). Allows placing, modifying, cancelling, and retrieving orders and trades.\"\n)\n\n# Initialize Kite Connect Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables.\")\n    # Optionally raise an error or exit if credentials are required at startup\n    # raise ValueError(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set\")\n    kite_client = None # Indicate client is not ready\nelse:\n    try:\n        kite_client = KiteConnectClient(api_key=api_key, access_token=access_token, base_url=base_url)\n        logger.info(\"KiteConnectClient initialized successfully.\")\n    except Exception as e:\n        logger.error(f\"Failed to initialize KiteConnectClient: {e}\")\n        kite_client = None\n\n# --- MCP Tools --- \n\n@mcp.tool(description=\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\")\nasync def place_order(params: PlaceOrderInput) -> Dict[str, Any]:\n    \"\"\"Places a new order on Kite Connect.\"\"\"\n    if not kite_client:\n        return {\"error\": \"Kite Connect client not initialized. Check API Key/Access Token.\"}\n    \n    logger.info(f\"Received place_order request: {params.dict(exclude_none=True)}\")\n    try:\n        response_data = await kite_client.place_order(params)\n        # Assuming the response structure is {'data': {'order_id': '...'}}\n        order_id = response_data.get(\"data\", {}).get(\"order_id\")\n        if order_id:\n            result = PlaceOrderResponse(order_id=order_id)\n            logger.info(f\"Order placed successfully: {result.dict()}\")\n            return result.dict()\n        else:\n            logger.error(f\"Place order response did not contain order_id: {response_data}\")\n            return {\"error\": \"Failed to place order, unexpected response format.\", \"details\": response_data}\n    except KiteApiException as e:\n        logger.error(f\"Kite API error during place_order: {e}\")\n        return {\"error\": \"Kite API Error\", \"details\": str(e)}\n    except httpx.HTTPStatusError as e:\n        logger.error(f\"HTTP error during place_order: {e.response.status_code} - {e.response.text}\")\n        return {\"error\": f\"HTTP Error: {e.response.status_code}\", \"details\": e.response.text}\n    except httpx.RequestError as e:\n        logger.error(f\"Network error during place_order: {e}\")\n        return {\"error\": \"Network Error\", \"details\": str(e)}\n    except Exception as e:\n        logger.exception(f\"Unexpected error during place_order: {e}\")\n        return {\"error\": \"An unexpected error occurred\", \"details\": str(e)}\n\n@mcp.tool(description=\"Modify an open or pending order. Send only the parameters that need to be modified.\")\nasync def modify_order(params: ModifyOrderInput) -> Dict[str, Any]:\n    \"\"\"Modifies an existing order on Kite Connect.\"\"\"\n    if not kite_client:\n        return {\"error\": \"Kite Connect client not initialized. Check API Key/Access Token.\"}\n\n    logger.info(f\"Received modify_order request for order_id {params.order_id}: {params.dict(exclude={'order_id', 'variety'}, exclude_none=True)}\")\n    try:\n        response_data = await kite_client.modify_order(params)\n        # Assuming the response structure is {'data': {'order_id': '...'}}\n        order_id = response_data.get(\"data\", {}).get(\"order_id\")\n        if order_id:\n            result = ModifyOrderResponse(order_id=order_id)\n            logger.info(f\"Order modified successfully: {result.dict()}\")\n            return result.dict()\n        else:\n            logger.error(f\"Modify order response did not contain order_id: {response_data}\")\n            return {\"error\": \"Failed to modify order, unexpected response format.\", \"details\": response_data}\n    except KiteApiException as e:\n        logger.error(f\"Kite API error during modify_order: {e}\")\n        return {\"error\": \"Kite API Error\", \"details\": str(e)}\n    except httpx.HTTPStatusError as e:\n        logger.error(f\"HTTP error during modify_order: {e.response.status_code} - {e.response.text}\")\n        return {\"error\": f\"HTTP Error: {e.response.status_code}\", \"details\": e.response.text}\n    except httpx.RequestError as e:\n        logger.error(f\"Network error during modify_order: {e}\")\n        return {\"error\": \"Network Error\", \"details\": str(e)}\n    except Exception as e:\n        logger.exception(f\"Unexpected error during modify_order: {e}\")\n        return {\"error\": \"An unexpected error occurred\", \"details\": str(e)}\n\n@mcp.tool(description=\"Cancel an open or pending order.\")\nasync def cancel_order(params: CancelOrderInput) -> Dict[str, Any]:\n    \"\"\"Cancels an existing order on Kite Connect.\"\"\"\n    if not kite_client:\n        return {\"error\": \"Kite Connect client not initialized. Check API Key/Access Token.\"}\n\n    logger.info(f\"Received cancel_order request for order_id {params.order_id}: {params.dict(exclude={'order_id', 'variety'}, exclude_none=True)}\")\n    try:\n        response_data = await kite_client.cancel_order(params)\n        # Assuming the response structure is {'data': {'order_id': '...'}}\n        order_id = response_data.get(\"data\", {}).get(\"order_id\")\n        if order_id:\n            result = CancelOrderResponse(order_id=order_id)\n            logger.info(f\"Order cancelled successfully: {result.dict()}\")\n            return result.dict()\n        else:\n            logger.error(f\"Cancel order response did not contain order_id: {response_data}\")\n            return {\"error\": \"Failed to cancel order, unexpected response format.\", \"details\": response_data}\n    except KiteApiException as e:\n        logger.error(f\"Kite API error during cancel_order: {e}\")\n        return {\"error\": \"Kite API Error\", \"details\": str(e)}\n    except httpx.HTTPStatusError as e:\n        logger.error(f\"HTTP error during cancel_order: {e.response.status_code} - {e.response.text}\")\n        return {\"error\": f\"HTTP Error: {e.response.status_code}\", \"details\": e.response.text}\n    except httpx.RequestError as e:\n        logger.error(f\"Network error during cancel_order: {e}\")\n        return {\"error\": \"Network Error\", \"details\": str(e)}\n    except Exception as e:\n        logger.exception(f\"Unexpected error during cancel_order: {e}\")\n        return {\"error\": \"An unexpected error occurred\", \"details\": str(e)}\n\n@mcp.tool(description=\"Retrieve the list of all orders (open, pending, executed) for the current trading day.\")\nasync def get_orders(params: GetOrdersInput = GetOrdersInput()) -> Dict[str, Any]:\n    \"\"\"Retrieves the list of orders for the day from Kite Connect.\"\"\"\n    if not kite_client:\n        return {\"error\": \"Kite Connect client not initialized. Check API Key/Access Token.\"}\n    \n    logger.info(\"Received get_orders request.\")\n    try:\n        response_data = await kite_client.get_orders()\n        # Assuming the response structure is {'data': [...]}\n        orders_list = response_data.get(\"data\")\n        if isinstance(orders_list, list):\n            # Validate and parse each order using Pydantic model\n            validated_orders = [OrderDetails(**order).dict() for order in orders_list]\n            logger.info(f\"Retrieved {len(validated_orders)} orders successfully.\")\n            # MCP expects a dict response, wrap the list\n            return {\"orders\": validated_orders}\n        else:\n            logger.error(f\"Get orders response did not contain a list in 'data': {response_data}\")\n            return {\"error\": \"Failed to get orders, unexpected response format.\", \"details\": response_data}\n    except KiteApiException as e:\n        logger.error(f\"Kite API error during get_orders: {e}\")\n        return {\"error\": \"Kite API Error\", \"details\": str(e)}\n    except httpx.HTTPStatusError as e:\n        logger.error(f\"HTTP error during get_orders: {e.response.status_code} - {e.response.text}\")\n        return {\"error\": f\"HTTP Error: {e.response.status_code}\", \"details\": e.response.text}\n    except httpx.RequestError as e:\n        logger.error(f\"Network error during get_orders: {e}\")\n        return {\"error\": \"Network Error\", \"details\": str(e)}\n    except Exception as e:\n        logger.exception(f\"Unexpected error during get_orders: {e}\")\n        return {\"error\": \"An unexpected error occurred\", \"details\": str(e)}\n\n\nif __name__ == \"__main__\":\n    if not kite_client:\n        print(\"ERROR: Kite Connect client failed to initialize. Check logs and environment variables.\")\n        print(\"MCP server cannot start without a functional client.\")\n    else:\n        print(\"Starting KiteConnectOrders MCP Server...\")\n        mcp.run()\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field\nfrom typing import Optional, List, Dict, Any\nfrom enum import Enum\n\n# --- Enums based on Kite Connect API documentation --- \n\nclass OrderVariety(str, Enum):\n    REGULAR = \"regular\"\n    AMO = \"amo\"\n    CO = \"co\"\n    ICEBERG = \"iceberg\"\n    AUCTION = \"auction\"\n\nclass ExchangeType(str, Enum):\n    NSE = \"NSE\"\n    BSE = \"BSE\"\n    NFO = \"NFO\"\n    MCX = \"MCX\"\n    BFO = \"BFO\"\n    CDS = \"CDS\"\n    BCD = \"BCD\"\n\nclass TransactionType(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n\nclass OrderType(str, Enum):\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n    SL = \"SL\"\n    SLM = \"SL-M\"\n\nclass ProductType(str, Enum):\n    CNC = \"CNC\"  # Cash & Carry for equity\n    NRML = \"NRML\" # Normal for F&O, Currency, Commodity\n    MIS = \"MIS\"  # Margin Intraday Squareoff\n    BO = \"BO\"    # Bracket Order (deprecated/restricted)\n    CO = \"CO\"    # Cover Order\n\nclass ValidityType(str, Enum):\n    DAY = \"DAY\"\n    IOC = \"IOC\"  # Immediate or Cancel\n    TTL = \"TTL\"  # Time to Live (in minutes)\n\n# --- Input Models --- \n\nclass PlaceOrderInput(BaseModel):\n    variety: OrderVariety = Field(..., description=\"The variety of the order (e.g., 'regular', 'co').\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument (e.g., 'INFY', 'SBIN').\")\n    exchange: ExchangeType = Field(..., description=\"Name of the exchange (e.g., 'NSE', 'MCX').\")\n    transaction_type: TransactionType = Field(..., description=\"'BUY' or 'SELL'.\")\n    order_type: OrderType = Field(..., description=\"Order type (e.g., 'MARKET', 'LIMIT').\")\n    quantity: int = Field(..., gt=0, description=\"Quantity to transact.\")\n    product: ProductType = Field(..., description=\"Product type (e.g., 'CNC', 'MIS').\")\n    validity: ValidityType = Field(default=ValidityType.DAY, description=\"Order validity ('DAY', 'IOC', 'TTL').\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders.\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M, CO orders.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10).\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order (quantity/iceberg_legs).\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction.\")\n    tag: Optional[str] = Field(None, max_length=20, description=\"An optional tag (alphanumeric, max 20 chars).\")\n\nclass ModifyOrderInput(BaseModel):\n    variety: OrderVariety = Field(..., description=\"The variety of the order being modified.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for modifying second leg of CO.\")\n    order_type: Optional[OrderType] = Field(None, description=\"New order type.\")\n    quantity: Optional[int] = Field(None, gt=0, description=\"New quantity.\")\n    price: Optional[float] = Field(None, description=\"New price.\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity.\")\n    validity: Optional[ValidityType] = Field(None, description=\"New validity.\")\n\nclass CancelOrderInput(BaseModel):\n    variety: OrderVariety = Field(..., description=\"The variety of the order being cancelled.\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for cancelling second leg of CO.\")\n\nclass GetOrdersInput(BaseModel):\n    # No input parameters needed for get_orders based on the plan\n    pass \n\n# --- Output Models --- \n\nclass PlaceOrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID assigned by the exchange.\")\n\nclass ModifyOrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID of the modified order.\")\n\nclass CancelOrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID of the cancelled order.\")\n\n# Define a model for individual order details returned by get_orders\n# This is a simplified representation based on common fields in Kite API\nclass OrderDetails(BaseModel):\n    order_id: str\n    parent_order_id: Optional[str] = None\n    exchange_order_id: Optional[str] = None\n    status: str\n    status_message: Optional[str] = None\n    tradingsymbol: str\n    exchange: ExchangeType\n    transaction_type: TransactionType\n    order_type: OrderType\n    product: ProductType\n    validity: ValidityType\n    price: float\n    quantity: int\n    trigger_price: float\n    average_price: float\n    filled_quantity: int\n    pending_quantity: int\n    cancelled_quantity: int\n    disclosed_quantity: int\n    order_timestamp: str # Assuming timestamp is returned as string\n    exchange_timestamp: Optional[str] = None\n    variety: OrderVariety\n    tag: Optional[str] = None\n    # Add other fields as needed based on actual API response\n    # meta: Optional[Dict[str, Any]] = None\n    # auction_number: Optional[str] = None\n\n# Model for representing errors from the Kite API\nclass KiteApiError(BaseModel):\n    status: str = \"error\"\n    error_type: str\n    message: str\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nfrom typing import Dict, Any, Optional, List\n\nfrom models import PlaceOrderInput, ModifyOrderInput, CancelOrderInput\n\nlogger = logging.getLogger(__name__)\n\n# Custom exception for Kite API specific errors\nclass KiteApiException(Exception):\n    def __init__(self, message: str, error_type: Optional[str] = None, status_code: Optional[int] = None):\n        self.message = message\n        self.error_type = error_type\n        self.status_code = status_code\n        super().__init__(f\"Kite API Error ({error_type or 'Unknown'}): {message}\")\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect Orders API (v3).\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        \"\"\"\n        Initializes the Kite Connect client.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after successful login.\n            base_url: The base URL for the Kite API (defaults to production).\n            timeout: Default timeout for HTTP requests in seconds.\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n        \n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.timeout = timeout\n        \n        headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite API often uses form encoding\n        }\n        \n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=headers,\n            timeout=self.timeout\n        )\n        logger.info(f\"KiteConnectClient initialized for base URL: {self.base_url}\")\n\n    async def _request(self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Sending {method} request to {url}\")\n        logger.debug(f\"Params: {params}\")\n        logger.debug(f\"Data: {data}\")\n        \n        try:\n            response = await self.client.request(method, endpoint, params=params, data=data)\n            \n            # Check for HTTP errors\n            response.raise_for_status()\n            \n            # Parse JSON response\n            json_response = response.json()\n            logger.debug(f\"Received successful response ({response.status_code}) from {url}: {json_response}\")\n            \n            # Check for Kite API specific errors within the JSON response\n            if json_response.get(\"status\") == \"error\":\n                error_type = json_response.get(\"error_type\", \"UnknownError\")\n                message = json_response.get(\"message\", \"No error message provided.\")\n                logger.error(f\"Kite API error response from {url}: {error_type} - {message}\")\n                raise KiteApiException(message=message, error_type=error_type, status_code=response.status_code)\n                \n            return json_response\n\n        except httpx.HTTPStatusError as e:\n            # Attempt to parse error details from response body if available\n            error_details = \"No details available.\"\n            error_type = \"HTTPError\"\n            try:\n                error_data = e.response.json()\n                error_details = error_data.get(\"message\", e.response.text)\n                error_type = error_data.get(\"error_type\", error_type)\n            except Exception:\n                error_details = e.response.text # Fallback to raw text\n            \n            logger.error(f\"HTTP error {e.response.status_code} from {url}: {error_details}\")\n            # Raise KiteApiException for consistency in handling API-related issues\n            raise KiteApiException(message=error_details, error_type=error_type, status_code=e.response.status_code) from e\n\n        except httpx.RequestError as e:\n            logger.error(f\"Network or request error contacting {url}: {e}\")\n            raise KiteApiException(message=f\"Network error: {e}\", error_type=\"NetworkError\") from e\n            \n        except Exception as e:\n            logger.exception(f\"An unexpected error occurred during request to {url}: {e}\")\n            raise KiteApiException(message=f\"Unexpected error: {e}\", error_type=\"ClientError\") from e\n\n    async def place_order(self, order_data: PlaceOrderInput) -> Dict[str, Any]:\n        \"\"\"Places an order.\"\"\"\n        endpoint = f\"/orders/{order_data.variety.value}\"\n        # Convert Pydantic model to dict, excluding None values and the path parameter 'variety'\n        payload = order_data.dict(exclude={'variety'}, exclude_none=True)\n        logger.info(f\"Placing order: {payload}\")\n        return await self._request(\"POST\", endpoint, data=payload)\n\n    async def modify_order(self, order_data: ModifyOrderInput) -> Dict[str, Any]:\n        \"\"\"Modifies an existing order.\"\"\"\n        endpoint = f\"/orders/{order_data.variety.value}/{order_data.order_id}\"\n        # Convert Pydantic model to dict, excluding None values and path parameters\n        payload = order_data.dict(exclude={'variety', 'order_id'}, exclude_none=True)\n        logger.info(f\"Modifying order {order_data.order_id}: {payload}\")\n        return await self._request(\"PUT\", endpoint, data=payload)\n\n    async def cancel_order(self, order_data: CancelOrderInput) -> Dict[str, Any]:\n        \"\"\"Cancels an existing order.\"\"\"\n        endpoint = f\"/orders/{order_data.variety.value}/{order_data.order_id}\"\n        # Parent order ID might be needed in payload for CO legs\n        payload = {}\n        if order_data.parent_order_id:\n             payload['parent_order_id'] = order_data.parent_order_id\n        logger.info(f\"Cancelling order {order_data.order_id} with payload: {payload}\")\n        # Note: DELETE requests might not typically have a body, but check Kite docs if parent_order_id needs to be sent differently.\n        # Assuming it's sent as form data if needed.\n        return await self._request(\"DELETE\", endpoint, data=payload if payload else None)\n\n    async def get_orders(self) -> Dict[str, Any]:\n        \"\"\"Retrieves the list of orders for the day.\"\"\"\n        endpoint = \"/orders\"\n        logger.info(\"Retrieving orders list.\")\n        # This endpoint uses GET, no data payload needed\n        return await self._request(\"GET\", endpoint)\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"KiteConnectClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0\npydantic>=1.9.0,<2.0.0\nhttpx>=0.23.0\npython-dotenv>=0.20.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer account: https://developers.kite.trade/\n\n# Your Kite application's API key\nKITE_API_KEY=\n\n# The access token obtained after a successful user login flow (this is typically short-lived)\n# You might need a separate process/script to generate this token regularly.\nKITE_ACCESS_TOKEN=\n\n# Base URL for the Kite Connect API (optional, defaults to production)\n# KITE_BASE_URL=https://api.kite.trade\n"
    },
    {
      "name": "README.md",
      "content": "# KiteConnect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server built with FastMCP to interact with the Zerodha Kite Connect Orders API (v3). It allows language models or other clients to manage trading orders (place, modify, cancel, retrieve) through a standardized interface.\n\n## Features\n\n*   Place new orders (Regular, AMO, CO, Iceberg, Auction).\n*   Modify existing pending orders.\n*   Cancel pending orders.\n*   Retrieve the list of all orders for the current trading day.\n*   Built with FastMCP for easy integration.\n*   Asynchronous API client using `httpx`.\n*   Typed inputs and outputs using Pydantic models.\n*   Environment variable-based configuration.\n*   Basic error handling for API and network issues.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n## Configuration\n\nThis server requires Kite Connect API credentials. You need to obtain an `API Key` and generate an `Access Token`.\n\n1.  **Create a `.env` file:**\n    Copy the example file:\n    ```bash\n    cp .env.example .env\n    ```\n\n2.  **Edit the `.env` file:**\n    Fill in your Kite Connect credentials:\n    ```dotenv\n    # Kite Connect API Credentials and Configuration\n    KITE_API_KEY=YOUR_API_KEY\n    KITE_ACCESS_TOKEN=YOUR_GENERATED_ACCESS_TOKEN\n    # KITE_BASE_URL=https://api.kite.trade # Optional: Uncomment to override default URL\n    ```\n\n    *   `KITE_API_KEY`: Your application's API key from the Kite Developer console.\n    *   `KITE_ACCESS_TOKEN`: A valid access token obtained through the Kite Connect login flow. **Note:** Access tokens are short-lived and need to be regenerated periodically (typically daily). This server assumes a valid token is provided. You might need a separate mechanism to refresh this token.\n\n## Running the Server\n\nOnce configured, start the MCP server:\n\n```bash\npython main.py\n```\n\nThe server will start, usually on `http://127.0.0.1:8000` (or the default FastMCP port), and log its status.\n\n## Available Tools\n\nThe following tools are exposed by this MCP server:\n\n1.  **`place_order`**\n    *   **Description:** Place an order of a particular variety (regular, amo, co, iceberg, auction).\n    *   **Input:** `PlaceOrderInput` model (includes variety, tradingsymbol, exchange, transaction_type, order_type, quantity, product, validity, and optional fields like price, trigger_price, etc.). See `models.py` for details.\n    *   **Output:** `PlaceOrderResponse` model containing the `order_id` on success, or an error dictionary.\n\n2.  **`modify_order`**\n    *   **Description:** Modify an open or pending order. Send only the parameters that need to be modified.\n    *   **Input:** `ModifyOrderInput` model (includes variety, order_id, and optional fields like parent_order_id, order_type, quantity, price, trigger_price, etc.). See `models.py` for details.\n    *   **Output:** `ModifyOrderResponse` model containing the `order_id` on success, or an error dictionary.\n\n3.  **`cancel_order`**\n    *   **Description:** Cancel an open or pending order.\n    *   **Input:** `CancelOrderInput` model (includes variety, order_id, and optional parent_order_id). See `models.py` for details.\n    *   **Output:** `CancelOrderResponse` model containing the `order_id` on success, or an error dictionary.\n\n4.  **`get_orders`**\n    *   **Description:** Retrieve the list of all orders (open, pending, executed) for the current trading day.\n    *   **Input:** `GetOrdersInput` model (currently takes no parameters).\n    *   **Output:** A dictionary containing a list of `OrderDetails` under the key `\"orders\"`, or an error dictionary.\n\n## Error Handling\n\nThe server attempts to catch common errors:\n\n*   **Kite API Errors:** Errors returned by the Kite API (e.g., insufficient funds, invalid parameters) are caught and returned with an `error` type and details.\n*   **HTTP Errors:** Standard HTTP errors (4xx, 5xx) during API calls are caught.\n*   **Network Errors:** Errors related to network connectivity or timeouts are caught.\n*   **Configuration Errors:** Logs an error if API credentials are missing.\n\nError responses are typically returned as a JSON dictionary with an `\"error\"` key and often a `\"details\"` key.\n"
    }
  ]
}
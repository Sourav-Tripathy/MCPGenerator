{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Optional, Literal\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nfrom client import KiteConnectClient, KiteConnectError\nfrom models import (\n    PlaceOrderParams,\n    ModifyOrderParams,\n    CancelOrderParams,\n    OrderResponse,\n    ErrorResponse\n)\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"KiteConnectOrders\",\n    description=\"MCP service for managing trading orders (placing, modifying, cancelling) using the Kite Connect V3 API.\"\n)\n\n# Initialize Kite Connect Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables or .env file.\")\n    # Optionally raise an error or exit if credentials are required at startup\n    # raise ValueError(\"API Key and Access Token are required.\")\n    kite_client = None # Keep running but tools will fail\nelse:\n    try:\n        kite_client = KiteConnectClient(api_key=api_key, access_token=access_token, base_url=base_url)\n        logger.info(\"KiteConnectClient initialized successfully.\")\n    except Exception as e:\n        logger.exception(f\"Failed to initialize KiteConnectClient: {e}\")\n        kite_client = None\n\n# --- MCP Tools ---\n\n@mcp.tool()\nasync def place_order(\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'],\n    tradingsymbol: str,\n    exchange: Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'],\n    transaction_type: Literal['BUY', 'SELL'],\n    order_type: Literal['MARKET', 'LIMIT', 'SL', 'SL-M'],\n    quantity: int,\n    product: Literal['CNC', 'NRML', 'MIS', 'MTF'],\n    validity: Literal['DAY', 'IOC', 'TTL'],\n    price: Optional[float] = None,\n    trigger_price: Optional[float] = None,\n    disclosed_quantity: Optional[int] = None,\n    validity_ttl: Optional[int] = None,\n    iceberg_legs: Optional[int] = None,\n    iceberg_quantity: Optional[int] = None,\n    auction_number: Optional[str] = None,\n    tag: Optional[str] = None\n) -> Dict:\n    \"\"\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\"\"\"\n    if not kite_client:\n        logger.error(\"place_order: KiteConnectClient is not initialized.\")\n        return ErrorResponse(error=\"Client not initialized. Check API Key/Token.\").dict()\n\n    try:\n        params = PlaceOrderParams(\n            variety=variety,\n            tradingsymbol=tradingsymbol,\n            exchange=exchange,\n            transaction_type=transaction_type,\n            order_type=order_type,\n            quantity=quantity,\n            product=product,\n            validity=validity,\n            price=price,\n            trigger_price=trigger_price,\n            disclosed_quantity=disclosed_quantity,\n            validity_ttl=validity_ttl,\n            iceberg_legs=iceberg_legs,\n            iceberg_quantity=iceberg_quantity,\n            auction_number=auction_number,\n            tag=tag\n        )\n        logger.info(f\"Placing order with params: {params.dict(exclude_none=True)}\")\n        response_data = await kite_client.place_order(params)\n        logger.info(f\"Order placed successfully: {response_data}\")\n        # Assuming response_data is {'data': {'order_id': '...'}}\n        order_id = response_data.get('data', {}).get('order_id')\n        if order_id:\n             return OrderResponse(order_id=order_id).dict()\n        else:\n             logger.error(f\"Order placement succeeded but order_id not found in response: {response_data}\")\n             return ErrorResponse(error=\"Order placed but failed to retrieve order_id\", details=response_data).dict()\n\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error during place_order: {e}\")\n        return ErrorResponse(error=e.__class__.__name__, message=str(e), details=e.details).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error during place_order: {e}\")\n        return ErrorResponse(error=\"InternalServerError\", message=str(e)).dict()\n\n@mcp.tool()\nasync def modify_order(\n    variety: Literal['regular', 'co', 'amo', 'iceberg', 'auction'],\n    order_id: str,\n    order_type: Optional[Literal['MARKET', 'LIMIT', 'SL', 'SL-M']] = None,\n    quantity: Optional[int] = None,\n    price: Optional[float] = None,\n    trigger_price: Optional[float] = None,\n    disclosed_quantity: Optional[int] = None,\n    validity: Optional[Literal['DAY', 'IOC', 'TTL']] = None\n) -> Dict:\n    \"\"\"Modify an open or pending order. Parameters depend on the order variety.\"\"\"\n    if not kite_client:\n        logger.error(\"modify_order: KiteConnectClient is not initialized.\")\n        return ErrorResponse(error=\"Client not initialized. Check API Key/Token.\").dict()\n\n    try:\n        params = ModifyOrderParams(\n            variety=variety,\n            order_id=order_id,\n            order_type=order_type,\n            quantity=quantity,\n            price=price,\n            trigger_price=trigger_price,\n            disclosed_quantity=disclosed_quantity,\n            validity=validity\n        )\n        logger.info(f\"Modifying order {order_id} with params: {params.dict(exclude={'variety', 'order_id'}, exclude_none=True)}\")\n        response_data = await kite_client.modify_order(params)\n        logger.info(f\"Order modified successfully: {response_data}\")\n        # Assuming response_data is {'data': {'order_id': '...'}}\n        modified_order_id = response_data.get('data', {}).get('order_id')\n        if modified_order_id:\n            return OrderResponse(order_id=modified_order_id).dict()\n        else:\n            logger.error(f\"Order modification succeeded but order_id not found in response: {response_data}\")\n            return ErrorResponse(error=\"Order modified but failed to retrieve order_id\", details=response_data).dict()\n\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error during modify_order: {e}\")\n        return ErrorResponse(error=e.__class__.__name__, message=str(e), details=e.details).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error during modify_order: {e}\")\n        return ErrorResponse(error=\"InternalServerError\", message=str(e)).dict()\n\n@mcp.tool()\nasync def cancel_order(\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'],\n    order_id: str\n) -> Dict:\n    \"\"\"Cancel an open or pending order.\"\"\"\n    if not kite_client:\n        logger.error(\"cancel_order: KiteConnectClient is not initialized.\")\n        return ErrorResponse(error=\"Client not initialized. Check API Key/Token.\").dict()\n\n    try:\n        params = CancelOrderParams(variety=variety, order_id=order_id)\n        logger.info(f\"Cancelling order {order_id} of variety {variety}\")\n        response_data = await kite_client.cancel_order(params)\n        logger.info(f\"Order cancelled successfully: {response_data}\")\n        # Assuming response_data is {'data': {'order_id': '...'}}\n        cancelled_order_id = response_data.get('data', {}).get('order_id')\n        if cancelled_order_id:\n            return OrderResponse(order_id=cancelled_order_id).dict()\n        else:\n            logger.error(f\"Order cancellation succeeded but order_id not found in response: {response_data}\")\n            return ErrorResponse(error=\"Order cancelled but failed to retrieve order_id\", details=response_data).dict()\n\n    except KiteConnectError as e:\n        logger.error(f\"Kite API error during cancel_order: {e}\")\n        return ErrorResponse(error=e.__class__.__name__, message=str(e), details=e.details).dict()\n    except Exception as e:\n        logger.exception(f\"Unexpected error during cancel_order: {e}\")\n        return ErrorResponse(error=\"InternalServerError\", message=str(e)).dict()\n\nif __name__ == \"__main__\":\n    if not kite_client:\n        logger.warning(\"Kite Connect client failed to initialize. MCP server starting, but tools will likely fail.\")\n    logger.info(\"Starting KiteConnectOrders MCP server...\")\n    mcp.run()\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field, validator\nfrom typing import Optional, Literal, Dict, Any\n\n# --- Input Parameter Models ---\n\nclass PlaceOrderParams(BaseModel):\n    \"\"\"Parameters for placing an order.\"\"\"\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety type.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX'] = Field(..., description=\"Name of the exchange.\")\n    transaction_type: Literal['BUY', 'SELL'] = Field(..., description=\"Transaction type.\")\n    order_type: Literal['MARKET', 'LIMIT', 'SL', 'SL-M'] = Field(..., description=\"Order type.\")\n    quantity: int = Field(..., description=\"Quantity to transact.\", gt=0)\n    product: Literal['CNC', 'NRML', 'MIS', 'MTF'] = Field(..., description=\"Product type.\")\n    price: Optional[float] = Field(None, description=\"The price for LIMIT orders.\")\n    trigger_price: Optional[float] = Field(None, description=\"The trigger price for SL, SL-M orders.\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity: Literal['DAY', 'IOC', 'TTL'] = Field(..., description=\"Order validity.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10).\", ge=2, le=10)\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order.\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction.\")\n    tag: Optional[str] = Field(None, description=\"Optional tag for the order (alphanumeric, max 20 chars).\", max_length=20)\n\n    @validator('price')\n    def check_price_for_limit_order(cls, v, values):\n        if values.get('order_type') == 'LIMIT' and v is None:\n            raise ValueError('Price is required for LIMIT orders')\n        if values.get('order_type') != 'LIMIT' and v is not None:\n             # Kite API might ignore it, but good practice to validate\n             pass # Or raise ValueError('Price is only applicable for LIMIT orders')\n        return v\n\n    @validator('trigger_price')\n    def check_trigger_price_for_sl_orders(cls, v, values):\n        if values.get('order_type') in ['SL', 'SL-M'] and v is None:\n            raise ValueError('Trigger price is required for SL/SL-M orders')\n        if values.get('order_type') not in ['SL', 'SL-M'] and v is not None:\n            # Or raise ValueError('Trigger price is only applicable for SL/SL-M orders')\n            pass\n        return v\n\n    @validator('validity_ttl')\n    def check_validity_ttl_for_ttl_validity(cls, v, values):\n        if values.get('validity') == 'TTL' and v is None:\n            raise ValueError('validity_ttl is required for TTL validity')\n        if values.get('validity') != 'TTL' and v is not None:\n            raise ValueError('validity_ttl is only applicable for TTL validity')\n        return v\n\n    @validator('iceberg_legs', 'iceberg_quantity')\n    def check_iceberg_params(cls, v, values, field):\n        if values.get('variety') == 'iceberg':\n            if field.name == 'iceberg_legs' and v is None:\n                raise ValueError('iceberg_legs is required for iceberg orders')\n            if field.name == 'iceberg_quantity' and v is None:\n                raise ValueError('iceberg_quantity is required for iceberg orders')\n        elif v is not None:\n            raise ValueError(f'{field.name} is only applicable for iceberg orders')\n        return v\n\n    @validator('auction_number')\n    def check_auction_number(cls, v, values):\n        if values.get('variety') == 'auction' and v is None:\n            raise ValueError('auction_number is required for auction orders')\n        if values.get('variety') != 'auction' and v is not None:\n            raise ValueError('auction_number is only applicable for auction orders')\n        return v\n\nclass ModifyOrderParams(BaseModel):\n    \"\"\"Parameters for modifying an order.\"\"\"\n    variety: Literal['regular', 'co', 'amo', 'iceberg', 'auction'] = Field(..., description=\"Order variety type being modified.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify.\")\n    order_type: Optional[Literal['MARKET', 'LIMIT', 'SL', 'SL-M']] = Field(None, description=\"New order type (regular variety).\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (regular variety).\", gt=0)\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders, regular/CO).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, LIMIT CO orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (regular variety).\")\n    validity: Optional[Literal['DAY', 'IOC', 'TTL']] = Field(None, description=\"New validity (regular variety).\")\n\n    # Add validators similar to PlaceOrderParams if needed for modification logic\n    # e.g., ensuring price is provided if changing order_type to LIMIT\n\nclass CancelOrderParams(BaseModel):\n    \"\"\"Parameters for cancelling an order.\"\"\"\n    variety: Literal['regular', 'amo', 'co', 'iceberg', 'auction'] = Field(..., description=\"Order variety type being cancelled.\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel.\")\n\n# --- Response Models ---\n\nclass OrderResponse(BaseModel):\n    \"\"\"Standard response containing the order ID.\"\"\"\n    order_id: str = Field(..., description=\"The unique ID of the order.\")\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response model.\"\"\"\n    error: str = Field(..., description=\"The type of error that occurred.\")\n    message: Optional[str] = Field(None, description=\"A human-readable message explaining the error.\")\n    details: Optional[Any] = Field(None, description=\"Additional details about the error, potentially from the API.\")\n\n# --- Custom Exceptions ---\n\nclass KiteConnectError(Exception):\n    \"\"\"Base exception for all Kite Connect API errors.\"\"\"\n    def __init__(self, message=\"An API error occurred\", status_code=None, details=None):\n        self.message = message\n        self.status_code = status_code\n        self.details = details # Store raw error response if available\n        super().__init__(self.message)\n\nclass AuthenticationError(KiteConnectError):\n    \"\"\"Raised for authentication failures (403 Forbidden).\"\"\"\n    def __init__(self, message=\"Authentication failed. Check API key and access token.\", details=None):\n        super().__init__(message, status_code=403, details=details)\n\nclass InvalidInputError(KiteConnectError):\n    \"\"\"Raised for invalid input parameters (400 Bad Request).\"\"\"\n    def __init__(self, message=\"Invalid input provided.\", details=None):\n        super().__init__(message, status_code=400, details=details)\n\nclass InsufficientFundsError(KiteConnectError):\n    \"\"\"Raised when there are insufficient funds (specific error message or code needed).\"\"\"\n    # Kite specific errors might be in the response body, not just status code\n    def __init__(self, message=\"Insufficient funds for the order.\", details=None):\n        super().__init__(message, details=details)\n\nclass NetworkError(KiteConnectError):\n    \"\"\"Raised for network-related issues (e.g., connection errors, timeouts).\"\"\"\n    def __init__(self, message=\"Network error communicating with Kite API.\", details=None):\n        super().__init__(message, details=details)\n\nclass RateLimitError(KiteConnectError):\n    \"\"\"Raised when API rate limits are exceeded (429 Too Many Requests).\"\"\"\n    def __init__(self, message=\"API rate limit exceeded.\", details=None):\n        super().__init__(message, status_code=429, details=details)\n\nclass ExchangeError(KiteConnectError):\n    \"\"\"Raised for exchange-specific errors (e.g., market closed, instrument not available).\"\"\"\n    # Often indicated by specific error messages in the response body (500 or 503 potentially)\n    def __init__(self, message=\"An exchange-related error occurred.\", details=None):\n        super().__init__(message, details=details)\n\nclass OrderPlacementError(KiteConnectError):\n    \"\"\"Generic error during order placement (potentially 500 Internal Server Error or specific message).\"\"\"\n    def __init__(self, message=\"Failed to place the order.\", details=None):\n        super().__init__(message, details=details)\n\nclass OrderModificationError(KiteConnectError):\n    \"\"\"Generic error during order modification.\"\"\"\n    def __init__(self, message=\"Failed to modify the order.\", details=None):\n        super().__init__(message, details=details)\n\nclass OrderCancellationError(KiteConnectError):\n    \"\"\"Generic error during order cancellation.\"\"\"\n    def __init__(self, message=\"Failed to cancel the order.\", details=None):\n        super().__init__(message, details=details)\n\nclass OrderNotFoundError(KiteConnectError):\n    \"\"\"Raised when trying to modify/cancel an order that doesn't exist (often 404 or specific message).\"\"\"\n    def __init__(self, message=\"Order not found.\", details=None):\n        # Kite might return 400 or other codes for this, check documentation\n        super().__init__(message, status_code=404, details=details)\n\nclass GeneralError(KiteConnectError):\n    \"\"\"Raised for unexpected server errors (500, 502, 503, 504).\"\"\"\n    def __init__(self, message=\"An unexpected server error occurred.\", status_code=500, details=None):\n        super().__init__(message, status_code=status_code, details=details)\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nfrom typing import Dict, Any, Optional\n\nfrom models import (\n    PlaceOrderParams,\n    ModifyOrderParams,\n    CancelOrderParams,\n    KiteConnectError,\n    AuthenticationError,\n    InvalidInputError,\n    InsufficientFundsError,\n    NetworkError,\n    RateLimitError,\n    ExchangeError,\n    OrderPlacementError,\n    OrderModificationError,\n    OrderCancellationError,\n    OrderNotFoundError,\n    GeneralError\n)\n\nlogger = logging.getLogger(__name__)\n\nclass KiteConnectClient:\n    \"\"\"Asynchronous client for interacting with the Kite Connect V3 Orders API.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        \"\"\"\n        Initializes the KiteConnectClient.\n\n        Args:\n            api_key: Your Kite Connect API key.\n            access_token: The access token obtained after login.\n            base_url: The base URL for the Kite Connect API.\n            timeout: Default timeout for HTTP requests in seconds.\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API key and access token are required.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.timeout = timeout\n        self.headers = {\n            \"X-Kite-Version\": \"3\",\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite API uses form encoding\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=self.timeout\n        )\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTP client.\"\"\"\n        await self.client.aclose()\n\n    async def _request(self, method: str, endpoint: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"\n        Makes an asynchronous HTTP request to the Kite Connect API.\n\n        Args:\n            method: HTTP method (e.g., 'GET', 'POST', 'PUT', 'DELETE').\n            endpoint: API endpoint path (e.g., '/orders/regular').\n            data: Dictionary payload for POST/PUT requests (will be form-encoded).\n\n        Returns:\n            The JSON response from the API as a dictionary.\n\n        Raises:\n            Various KiteConnectError subclasses based on the response or network issues.\n        \"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Request: {method} {url} Data: {data}\")\n\n        try:\n            response = await self.client.request(method, endpoint, data=data)\n            logger.debug(f\"Response Status: {response.status_code} Body: {response.text}\")\n            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx\n            return response.json()\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out: {method} {url} - {e}\")\n            raise NetworkError(f\"Request timed out: {e}\", details=str(e))\n        except httpx.RequestError as e:\n            # Includes connection errors, etc.\n            logger.error(f\"Request error: {method} {url} - {e}\")\n            raise NetworkError(f\"HTTP request failed: {e}\", details=str(e))\n        except httpx.HTTPStatusError as e:\n            status_code = e.response.status_code\n            try:\n                error_details = e.response.json()\n                message = error_details.get(\"message\", \"No specific message\")\n                error_type = error_details.get(\"error_type\", \"UnknownErrorType\") # Kite specific error type\n            except Exception:\n                error_details = e.response.text\n                message = f\"HTTP {status_code} Error\"\n                error_type = \"UnknownErrorType\"\n\n            logger.error(f\"HTTP error: {method} {url} - Status: {status_code}, Response: {error_details}\")\n\n            # Map status codes and potentially error_type to specific exceptions\n            if status_code == 400:\n                # Could be InvalidInputError or potentially ExchangeError, OrderNotFoundError etc.\n                # Check error_type if possible\n                if \"InputException\" in error_type:\n                    raise InvalidInputError(message=message, details=error_details)\n                elif \"OrderException\" in error_type: # Example, adjust based on actual Kite errors\n                     raise OrderPlacementError(message=message, details=error_details)\n                else:\n                    raise InvalidInputError(message=message, details=error_details) # Default for 400\n            elif status_code == 403:\n                raise AuthenticationError(message=message, details=error_details)\n            elif status_code == 404:\n                 # Often used for Order Not Found during modify/cancel\n                 raise OrderNotFoundError(message=message, details=error_details)\n            elif status_code == 429:\n                raise RateLimitError(message=message, details=error_details)\n            elif status_code == 500:\n                # Could be GeneralError, ExchangeError, OrderPlacementError etc.\n                if \"ExchangeException\" in error_type: # Example\n                    raise ExchangeError(message=message, details=error_details)\n                else:\n                    raise GeneralError(message=message, status_code=status_code, details=error_details)\n            elif status_code in [502, 503, 504]:\n                raise GeneralError(message=message, status_code=status_code, details=error_details)\n            else:\n                # Catch-all for other unexpected HTTP errors\n                raise KiteConnectError(message=f\"Unhandled HTTP error: {status_code}\", status_code=status_code, details=error_details)\n        except Exception as e:\n            # Catch-all for non-HTTP exceptions (e.g., JSON decoding errors)\n            logger.exception(f\"Unexpected error during request: {method} {url} - {e}\")\n            raise KiteConnectError(f\"An unexpected error occurred: {e}\", details=str(e))\n\n    async def place_order(self, params: PlaceOrderParams) -> Dict[str, Any]:\n        \"\"\"\n        Places an order using the Kite Connect API.\n\n        Args:\n            params: A PlaceOrderParams object containing order details.\n\n        Returns:\n            The API response dictionary, typically containing {'status': 'success', 'data': {'order_id': '...'}}.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}\"\n        # Exclude 'variety' from the form data, as it's in the path\n        data = params.dict(exclude={'variety'}, exclude_none=True)\n        # Convert boolean/None/list values if necessary for form encoding\n        # httpx handles basic types well, but check Kite docs for specifics\n        try:\n            return await self._request(\"POST\", endpoint, data=data)\n        except KiteConnectError as e:\n            # Add context specific to the operation\n            if isinstance(e, InvalidInputError):\n                 logger.error(f\"Invalid input placing order: {e.message} - {e.details}\")\n            # Re-raise the specific error\n            raise e\n        except Exception as e:\n            logger.exception(\"Unexpected error in place_order wrapper\")\n            raise OrderPlacementError(f\"Unexpected error during order placement: {e}\", details=str(e))\n\n\n    async def modify_order(self, params: ModifyOrderParams) -> Dict[str, Any]:\n        \"\"\"\n        Modifies an existing order using the Kite Connect API.\n\n        Args:\n            params: A ModifyOrderParams object containing modification details.\n\n        Returns:\n            The API response dictionary, typically containing {'status': 'success', 'data': {'order_id': '...'}}.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # Exclude path parameters from the form data\n        data = params.dict(exclude={'variety', 'order_id'}, exclude_none=True)\n        try:\n            return await self._request(\"PUT\", endpoint, data=data)\n        except KiteConnectError as e:\n            if isinstance(e, OrderNotFoundError):\n                 logger.warning(f\"Attempted to modify non-existent order {params.order_id}: {e.message}\")\n            raise e\n        except Exception as e:\n            logger.exception(\"Unexpected error in modify_order wrapper\")\n            raise OrderModificationError(f\"Unexpected error during order modification: {e}\", details=str(e))\n\n\n    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, Any]:\n        \"\"\"\n        Cancels an existing order using the Kite Connect API.\n\n        Args:\n            params: A CancelOrderParams object containing the order details.\n\n        Returns:\n            The API response dictionary, typically containing {'status': 'success', 'data': {'order_id': '...'}}.\n        \"\"\"\n        endpoint = f\"/orders/{params.variety}/{params.order_id}\"\n        # No data payload for DELETE usually, but check API spec if needed\n        try:\n            return await self._request(\"DELETE\", endpoint)\n        except KiteConnectError as e:\n            if isinstance(e, OrderNotFoundError):\n                 logger.warning(f\"Attempted to cancel non-existent order {params.order_id}: {e.message}\")\n            raise e\n        except Exception as e:\n            logger.exception(\"Unexpected error in cancel_order wrapper\")\n            raise OrderCancellationError(f\"Unexpected error during order cancellation: {e}\", details=str(e))\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp~=0.1.0\nhttpx~=0.27.0\npydantic~=2.7.1\npython-dotenv~=1.0.1\ntyping-extensions~=4.11.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Developer account (https://developers.kite.trade/)\n\n# Your application's API key\nKITE_API_KEY=\n\n# The access token obtained after a successful Kite Connect login flow\n# This token is typically short-lived (valid for one day) and needs to be regenerated daily.\nKITE_ACCESS_TOKEN=\n\n# Base URL for the Kite Connect API (usually doesn't need changing)\nKITE_BASE_URL=https://api.kite.trade\n"
    },
    {
      "name": "README.md",
      "content": "# Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the order management functionalities of the Zerodha Kite Connect V3 API. It allows language models or other applications to place, modify, and cancel trading orders through a standardized MCP interface.\n\n## Features\n\n*   Provides MCP tools for:\n    *   Placing new orders (`place_order`)\n    *   Modifying existing pending orders (`modify_order`)\n    *   Cancelling existing pending orders (`cancel_order`)\n*   Built using `FastMCP`.\n*   Asynchronous API client using `httpx`.\n*   Input validation using `Pydantic`.\n*   Handles authentication using Kite Connect API Key and Access Token.\n*   Structured error handling and logging.\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-directory>\n    ```\n\n2.  **Create a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure Environment Variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect API credentials:\n        *   `KITE_API_KEY`: Your application's API key.\n        *   `KITE_ACCESS_TOKEN`: The access token obtained after a successful Kite Connect login flow. **Note:** This token is usually valid only for the day it's generated and needs to be updated daily.\n        *   `KITE_BASE_URL`: (Optional) Defaults to `https://api.kite.trade`.\n\n## Running the Server\n\nStart the MCP server using:\n\n```bash\npython main.py\n```\n\nThe server will start, usually on `http://127.0.0.1:8000` (or the default FastMCP port), and log its status.\n\n## Available Tools\n\nThe following tools are exposed by the MCP server:\n\n1.  **`place_order`**\n    *   **Description:** Place an order of a particular variety (regular, amo, co, iceberg, auction).\n    *   **Parameters:**\n        *   `variety` (Literal['regular', 'amo', 'co', 'iceberg', 'auction']): Order variety type. (Required)\n        *   `tradingsymbol` (str): Tradingsymbol of the instrument. (Required)\n        *   `exchange` (Literal['NSE', 'BSE', 'NFO', 'CDS', 'BCD', 'MCX']): Name of the exchange. (Required)\n        *   `transaction_type` (Literal['BUY', 'SELL']): Transaction type. (Required)\n        *   `order_type` (Literal['MARKET', 'LIMIT', 'SL', 'SL-M']): Order type. (Required)\n        *   `quantity` (int): Quantity to transact. (Required)\n        *   `product` (Literal['CNC', 'NRML', 'MIS', 'MTF']): Product type. (Required)\n        *   `validity` (Literal['DAY', 'IOC', 'TTL']): Order validity. (Required)\n        *   `price` (Optional[float]): The price for LIMIT orders.\n        *   `trigger_price` (Optional[float]): The trigger price for SL, SL-M orders.\n        *   `disclosed_quantity` (Optional[int]): Quantity to disclose publicly (for equity trades).\n        *   `validity_ttl` (Optional[int]): Order life span in minutes for TTL validity orders.\n        *   `iceberg_legs` (Optional[int]): Total number of legs for iceberg order type (2-10).\n        *   `iceberg_quantity` (Optional[int]): Split quantity for each iceberg leg order.\n        *   `auction_number` (Optional[str]): A unique identifier for a particular auction.\n        *   `tag` (Optional[str]): Optional tag for the order (alphanumeric, max 20 chars).\n    *   **Returns:** `Dict` containing `{\"order_id\": \"...\"}` on success, or an error dictionary.\n\n2.  **`modify_order`**\n    *   **Description:** Modify an open or pending order. Parameters depend on the order variety.\n    *   **Parameters:**\n        *   `variety` (Literal['regular', 'co', 'amo', 'iceberg', 'auction']): Order variety type being modified. (Required)\n        *   `order_id` (str): The ID of the order to modify. (Required)\n        *   `order_type` (Optional[Literal['MARKET', 'LIMIT', 'SL', 'SL-M']]): New order type (regular variety).\n        *   `quantity` (Optional[int]): New quantity (regular variety).\n        *   `price` (Optional[float]): New price (for LIMIT orders, regular/CO).\n        *   `trigger_price` (Optional[float]): New trigger price (for SL, SL-M, LIMIT CO orders).\n        *   `disclosed_quantity` (Optional[int]): New disclosed quantity (regular variety).\n        *   `validity` (Optional[Literal['DAY', 'IOC', 'TTL']]): New validity (regular variety).\n    *   **Returns:** `Dict` containing `{\"order_id\": \"...\"}` on success, or an error dictionary.\n\n3.  **`cancel_order`**\n    *   **Description:** Cancel an open or pending order.\n    *   **Parameters:**\n        *   `variety` (Literal['regular', 'amo', 'co', 'iceberg', 'auction']): Order variety type being cancelled. (Required)\n        *   `order_id` (str): The ID of the order to cancel. (Required)\n    *   **Returns:** `Dict` containing `{\"order_id\": \"...\"}` on success, or an error dictionary.\n\n## Error Handling\n\nThe API client maps common HTTP status codes and potential Kite Connect error messages to specific Python exceptions (defined in `models.py`, e.g., `AuthenticationError`, `InvalidInputError`, `RateLimitError`, `OrderNotFoundError`).\n\nThe MCP tools catch these exceptions and return a structured JSON error response:\n\n```json\n{\n  \"error\": \"ErrorType\",\n  \"message\": \"Human-readable error message\",\n  \"details\": \"Optional details from the API\"\n}\n```\n\nCheck the server logs for detailed error information.\n\n## Important Notes\n\n*   **Access Token:** The Kite Connect `access_token` is short-lived (usually valid for one day). You need a mechanism to generate and update this token in the `.env` file or environment variables daily before starting the server.\n*   **Rate Limits:** The Kite Connect API has rate limits (e.g., 10 requests/second for orders). The server will return a `RateLimitError` if these are exceeded, but it does not implement client-side rate limiting.\n*   **Disclaimer:** Trading involves risks. Use this software responsibly and test thoroughly in a simulated environment if possible before using it with real funds.\n"
    }
  ]
}
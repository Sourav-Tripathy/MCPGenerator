from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any, Union

# --- Input Models ---

class MessageContentPart(BaseModel):
    """Represents a part of the message content, which can be text or an image/document URL (Data URI)."""
    type: str = Field(..., description="Type of content part ('text' or 'image_url').")
    text: Optional[str] = Field(None, description="Text content, if type is 'text'.")
    image_url: Optional[Dict[str, str]] = Field(None, description="Image/Document URL object, if type is 'image_url'. Expects {'url': 'data:...'}")

class Message(BaseModel):
    """Represents a single message in the conversation."""
    role: str = Field(..., description="The role of the message author ('user' or 'assistant').")
    content: Union[str, List[MessageContentPart]] = Field(..., description="The content of the message. Can be a simple string or a list of content parts for multimodal input.")

class DeepSearchChatParams(BaseModel):
    """Input parameters for the Jina DeepSearch chat completion tool."""
    messages: List[Message] = Field(..., description="A list of messages comprising the conversation history. Can include text and data URIs for images (webp, png, jpeg) or documents (txt, pdf) up to 10MB.")
    model: str = Field("jina-deepsearch-v1", description="ID of the model to use.")
    stream: bool = Field(True, description="If true, delivers events as server-sent events. The MCP tool handles streaming internally, but setting this to false is discouraged and may cause timeouts.")
    reasoning_effort: Optional[str] = Field("medium", description="Constrains effort on reasoning. Supported values: 'low', 'medium', 'high'. Lower effort may yield faster responses with fewer reasoning tokens.")
    budget_tokens: Optional[int] = Field(None, description="Maximum number of tokens allowed for the DeepSearch process. Overrides 'reasoning_effort'. Larger budgets can improve quality for complex queries.")
    max_attempts: Optional[int] = Field(None, description="Maximum number of retries for solving the problem. Allows trying different reasoning approaches. Overrides 'reasoning_effort'.")
    no_direct_answer: Optional[bool] = Field(False, description="Forces further thinking/search steps even for seemingly trivial queries.")
    max_returned_urls: Optional[int] = Field(None, description="Maximum number of URLs to include in the final answer, sorted by relevance.")
    structured_output: Optional[Any] = Field(None, description="Enables structured output matching a supplied JSON schema.")
    good_domains: Optional[List[str]] = Field(None, description="List of domains to prioritize for content retrieval.")
    bad_domains: Optional[List[str]] = Field(None, description="List of domains to strictly exclude from content retrieval.")
    only_domains: Optional[List[str]] = Field(None, description="List of domains to exclusively include in content retrieval.")

    class Config:
        extra = 'allow' # Allow extra fields if needed

# --- Output Models ---

class UrlCitation(BaseModel):
    """Details of a URL citation used in the response."""
    title: Optional[str] = Field(None, description="Title of the cited web page.")
    exactQuote: Optional[str] = Field(None, description="The exact quote from the source.")
    url: str = Field(..., description="The URL of the source.")
    dateTime: Optional[str] = Field(None, description="Timestamp associated with the citation.")

class Annotation(BaseModel):
    """Annotation within the response content, e.g., a URL citation."""
    type: str = Field(..., description="Type of annotation (e.g., 'url_citation').")
    url_citation: Optional[UrlCitation] = Field(None, description="Details if the annotation is a URL citation.")

class ResponseMessage(BaseModel):
    """Represents the message content generated by the model."""
    role: str = Field("assistant", description="Typically 'assistant'.")
    content: Optional[str] = Field(None, description="The textual content of the response.")
    annotations: Optional[List[Annotation]] = Field(None, description="Annotations related to the content, like citations.")

class Usage(BaseModel):
    """Token usage statistics for the request."""
    prompt_tokens: Optional[int] = Field(None, description="Number of tokens in the prompt.")
    completion_tokens: Optional[int] = Field(None, description="Number of tokens in the generated completion.")
    total_tokens: Optional[int] = Field(None, description="Total number of tokens used in the request.")
    search_queries_count: Optional[int] = Field(None, description="Number of search queries performed.")
    visited_urls_count: Optional[int] = Field(None, description="Number of URLs visited.")
    read_urls_count: Optional[int] = Field(None, description="Number of URLs read.")
    reasoning_steps_count: Optional[int] = Field(None, description="Number of reasoning steps taken.")

class Choice(BaseModel):
    """A single choice generated by the model."""
    index: int = Field(..., description="The index of the choice.")
    message: ResponseMessage = Field(..., description="The message generated by the model.")
    finish_reason: Optional[str] = Field(None, description="Reason the model stopped generating tokens.")

class ChatCompletionResponse(BaseModel):
    """The final aggregated response from the DeepSearch process."""
    id: str = Field(..., description="A unique identifier for the chat completion.")
    object: str = Field("chat.completion", description="The object type, which is always 'chat.completion'.")
    created: int = Field(..., description="The Unix timestamp (in seconds) of when the chat completion was created.")
    model: str = Field(..., description="The model used for the chat completion.")
    choices: List[Choice] = Field(..., description="A list of chat completion choices. Currently, only one choice is supported.")
    usage: Optional[Usage] = Field(None, description="Usage statistics for the completion request.")
    visited_urls: Optional[List[str]] = Field(None, description="List of URLs visited during the search process.")
    read_urls: Optional[List[str]] = Field(None, description="List of URLs read during the search process.")

class ChatCompletionStreamChoiceDelta(BaseModel):
    role: Optional[str] = None
    content: Optional[str] = None
    annotations: Optional[List[Annotation]] = None

class ChatCompletionStreamChoice(BaseModel):
    index: int
    delta: ChatCompletionStreamChoiceDelta
    finish_reason: Optional[str] = None

class ChatCompletionChunk(BaseModel):
    """Represents a chunk received during streaming."""
    id: str
    object: str = "chat.completion.chunk"
    created: int
    model: str
    choices: List[ChatCompletionStreamChoice]
    usage: Optional[Usage] = None # Usage might appear in the last chunk
    visited_urls: Optional[List[str]] = None # May appear in intermediate or last chunk
    read_urls: Optional[List[str]] = None # May appear in intermediate or last chunk

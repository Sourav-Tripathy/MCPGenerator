{
  "files": [
    {
      "name": "main.py",
      "content": "from mcp.server.fastmcp import FastMCP\nfrom typing import Dict, Any, Optional, List\nimport logging\nimport os\nfrom dotenv import load_dotenv\nimport httpx\n\nfrom models import (\n    PlaceOrderParams, ModifyOrderParams, CancelOrderParams,\n    GetOrderHistoryParams, Order, OrderHistoryEntry,\n    PlaceOrderResponse, ModifyOrderResponse, CancelOrderResponse,\n    VarietyEnum\n)\nfrom client import AsyncKiteClient, KiteApiException\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Initialize MCP Server\nmcp = FastMCP(\n    service_name=\"ZerodhaKiteConnectOrders\",\n    description=\"Provides tools to interact with the Zerodha Kite Connect Orders API, allowing users to place, modify, cancel, and retrieve order and trade information.\"\n)\n\n# Initialize API Client\napi_key = os.getenv(\"KITE_API_KEY\")\naccess_token = os.getenv(\"KITE_ACCESS_TOKEN\")\nbase_url = os.getenv(\"KITE_BASE_URL\", \"https://api.kite.trade\")\n\nif not api_key or not access_token:\n    logger.error(\"KITE_API_KEY and KITE_ACCESS_TOKEN must be set in environment variables or .env file.\")\n    # Consider exiting or raising a configuration error depending on desired behavior\n    # raise ValueError(\"API Key and Access Token are required.\")\n    # For now, initialize client but it will fail on requests\n\nkite_client = AsyncKiteClient(api_key=api_key, access_token=access_token, base_url=base_url)\n\n@mcp.tool()\nasync def place_order(params: PlaceOrderParams) -> Dict[str, Any]:\n    \"\"\"Place an order of a particular variety (regular, amo, co, iceberg, auction).\"\"\"\n    logger.info(f\"Received place_order request: {params}\")\n    try:\n        # Extract variety for path parameter, remove it from payload\n        variety = params.variety\n        payload = params.dict(exclude={'variety'}, exclude_unset=True)\n        logger.debug(f\"Placing order with variety '{variety}' and payload: {payload}\")\n        result = await kite_client.place_order(variety=variety, data=payload)\n        logger.info(f\"Order placed successfully: {result}\")\n        return PlaceOrderResponse(**result).dict()\n    except KiteApiException as e:\n        logger.error(f\"Kite API Exception during place_order: {e}\")\n        return {\"error\": str(e), \"details\": e.details}\n    except httpx.HTTPError as e:\n        logger.error(f\"HTTP error during place_order: {e}\")\n        return {\"error\": f\"HTTP error: {e.response.status_code}\", \"details\": str(e.response.text)}\n    except Exception as e:\n        logger.exception(f\"Unexpected error during place_order: {e}\")\n        return {\"error\": \"An unexpected error occurred\", \"details\": str(e)}\n\n@mcp.tool()\nasync def modify_order(params: ModifyOrderParams) -> Dict[str, Any]:\n    \"\"\"Modify attributes of a pending regular or cover order.\"\"\"\n    logger.info(f\"Received modify_order request: {params}\")\n    try:\n        # Extract path parameters, remove them from payload\n        variety = params.variety\n        order_id = params.order_id\n        payload = params.dict(exclude={'variety', 'order_id'}, exclude_unset=True)\n        logger.debug(f\"Modifying order with variety '{variety}', order_id '{order_id}', payload: {payload}\")\n        result = await kite_client.modify_order(variety=variety, order_id=order_id, data=payload)\n        logger.info(f\"Order modified successfully: {result}\")\n        return ModifyOrderResponse(**result).dict()\n    except KiteApiException as e:\n        logger.error(f\"Kite API Exception during modify_order: {e}\")\n        return {\"error\": str(e), \"details\": e.details}\n    except httpx.HTTPStatusError as e:\n        logger.error(f\"HTTP error during modify_order: {e}\")\n        return {\"error\": f\"HTTP error: {e.response.status_code}\", \"details\": str(e.response.text)}\n    except Exception as e:\n        logger.exception(f\"Unexpected error during modify_order: {e}\")\n        return {\"error\": \"An unexpected error occurred\", \"details\": str(e)}\n\n@mcp.tool()\nasync def cancel_order(params: CancelOrderParams) -> Dict[str, Any]:\n    \"\"\"Cancel a pending regular or cover order.\"\"\"\n    logger.info(f\"Received cancel_order request: {params}\")\n    try:\n        # Extract path parameters, remove them from payload (though payload is usually empty for DELETE)\n        variety = params.variety\n        order_id = params.order_id\n        payload = params.dict(exclude={'variety', 'order_id'}, exclude_unset=True) # parent_order_id might be needed\n        logger.debug(f\"Cancelling order with variety '{variety}', order_id '{order_id}', payload: {payload}\")\n        result = await kite_client.cancel_order(variety=variety, order_id=order_id, data=payload)\n        logger.info(f\"Order cancelled successfully: {result}\")\n        return CancelOrderResponse(**result).dict()\n    except KiteApiException as e:\n        logger.error(f\"Kite API Exception during cancel_order: {e}\")\n        return {\"error\": str(e), \"details\": e.details}\n    except httpx.HTTPStatusError as e:\n        logger.error(f\"HTTP error during cancel_order: {e}\")\n        return {\"error\": f\"HTTP error: {e.response.status_code}\", \"details\": str(e.response.text)}\n    except Exception as e:\n        logger.exception(f\"Unexpected error during cancel_order: {e}\")\n        return {\"error\": \"An unexpected error occurred\", \"details\": str(e)}\n\n@mcp.tool()\nasync def get_orders() -> List[Dict[str, Any]]:\n    \"\"\"Retrieve the list of all orders (open, pending, and executed) for the current trading day.\"\"\"\n    logger.info(\"Received get_orders request\")\n    try:\n        orders_data = await kite_client.get_orders()\n        logger.info(f\"Retrieved {len(orders_data)} orders successfully.\")\n        # Validate and serialize each order\n        return [Order(**order).dict() for order in orders_data]\n    except KiteApiException as e:\n        logger.error(f\"Kite API Exception during get_orders: {e}\")\n        return [{\"error\": str(e), \"details\": e.details}] # Return error within a list as expected type is List\n    except httpx.HTTPStatusError as e:\n        logger.error(f\"HTTP error during get_orders: {e}\")\n        return [{\"error\": f\"HTTP error: {e.response.status_code}\", \"details\": str(e.response.text)}]\n    except Exception as e:\n        logger.exception(f\"Unexpected error during get_orders: {e}\")\n        return [{\"error\": \"An unexpected error occurred\", \"details\": str(e)}]\n\n@mcp.tool()\nasync def get_order_history(params: GetOrderHistoryParams) -> List[Dict[str, Any]]:\n    \"\"\"Retrieve the history of states for a given order.\"\"\"\n    logger.info(f\"Received get_order_history request for order_id: {params.order_id}\")\n    try:\n        history_data = await kite_client.get_order_history(order_id=params.order_id)\n        logger.info(f\"Retrieved history for order {params.order_id} successfully.\")\n        # Validate and serialize each history entry\n        return [OrderHistoryEntry(**entry).dict() for entry in history_data]\n    except KiteApiException as e:\n        logger.error(f\"Kite API Exception during get_order_history: {e}\")\n        return [{\"error\": str(e), \"details\": e.details}]\n    except httpx.HTTPStatusError as e:\n        logger.error(f\"HTTP error during get_order_history: {e}\")\n        return [{\"error\": f\"HTTP error: {e.response.status_code}\", \"details\": str(e.response.text)}]\n    except Exception as e:\n        logger.exception(f\"Unexpected error during get_order_history: {e}\")\n        return [{\"error\": \"An unexpected error occurred\", \"details\": str(e)}]\n\nif __name__ == \"__main__\":\n    if not api_key or not access_token:\n        print(\"ERROR: KITE_API_KEY and KITE_ACCESS_TOKEN environment variables are required.\")\n        print(\"Please create a .env file or set them in your environment.\")\n    else:\n        print(f\"Starting ZerodhaKiteConnectOrders MCP server...\")\n        print(f\"Using Kite API Base URL: {base_url}\")\n        mcp.run()\n"
    },
    {
      "name": "models.py",
      "content": "from pydantic import BaseModel, Field\nfrom typing import Optional, List, Dict, Any\nfrom enum import Enum\n\n# --- Enums based on Kite Connect API documentation ---\n\nclass VarietyEnum(str, Enum):\n    REGULAR = \"regular\"\n    AMO = \"amo\"\n    CO = \"co\"\n    ICEBERG = \"iceberg\"\n    AUCTION = \"auction\"\n\nclass ExchangeEnum(str, Enum):\n    NSE = \"NSE\"\n    BSE = \"BSE\"\n    NFO = \"NFO\"\n    CDS = \"CDS\"\n    BCD = \"BCD\"\n    MCX = \"MCX\"\n\nclass TransactionTypeEnum(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n\nclass OrderTypeEnum(str, Enum):\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n    SL = \"SL\"\n    SL_M = \"SL-M\"\n\nclass ProductEnum(str, Enum):\n    CNC = \"CNC\"\n    NRML = \"NRML\"\n    MIS = \"MIS\"\n    MTF = \"MTF\"\n\nclass ValidityEnum(str, Enum):\n    DAY = \"DAY\"\n    IOC = \"IOC\"\n    TTL = \"TTL\"\n\n# --- Input Parameter Models ---\n\nclass PlaceOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety (regular, amo, co, iceberg, auction). To be included in the URL path.\")\n    tradingsymbol: str = Field(..., description=\"Tradingsymbol of the instrument.\")\n    exchange: ExchangeEnum = Field(..., description=\"Name of the exchange (NSE, BSE, NFO, CDS, BCD, MCX).\")\n    transaction_type: TransactionTypeEnum = Field(..., description=\"BUY or SELL.\")\n    order_type: OrderTypeEnum = Field(..., description=\"Order type (MARKET, LIMIT, SL, SL-M).\")\n    quantity: int = Field(..., description=\"Quantity to transact.\")\n    product: ProductEnum = Field(..., description=\"Product type (CNC, NRML, MIS, MTF).\")\n    price: Optional[float] = Field(None, description=\"The price to execute the order at (required for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"The price at which an order should be triggered (required for SL, SL-M orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"Quantity to disclose publicly (for equity trades).\")\n    validity: Optional[ValidityEnum] = Field(ValidityEnum.DAY, description=\"Order validity (DAY, IOC, TTL). Defaults to DAY.\")\n    validity_ttl: Optional[int] = Field(None, description=\"Order life span in minutes for TTL validity orders.\")\n    iceberg_legs: Optional[int] = Field(None, description=\"Total number of legs for iceberg order type (2-10). Required for iceberg variety.\")\n    iceberg_quantity: Optional[int] = Field(None, description=\"Split quantity for each iceberg leg order. Required for iceberg variety.\")\n    auction_number: Optional[str] = Field(None, description=\"A unique identifier for a particular auction. Required for auction variety.\")\n    tag: Optional[str] = Field(None, description=\"An optional tag to apply to an order (alphanumeric, max 20 chars).\")\n\nclass ModifyOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety (regular, co). To be included in the URL path.\")\n    order_id: str = Field(..., description=\"The ID of the order to modify. To be included in the URL path.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for modifying second-leg CO orders.\")\n    order_type: Optional[OrderTypeEnum] = Field(None, description=\"New order type (only for regular orders).\")\n    quantity: Optional[int] = Field(None, description=\"New quantity (only for regular orders).\")\n    price: Optional[float] = Field(None, description=\"New price (for LIMIT orders).\")\n    trigger_price: Optional[float] = Field(None, description=\"New trigger price (for SL, SL-M, LIMIT CO orders).\")\n    disclosed_quantity: Optional[int] = Field(None, description=\"New disclosed quantity (only for regular equity orders).\")\n    validity: Optional[ValidityEnum] = Field(None, description=\"New validity (only for regular orders, DAY or IOC).\")\n\nclass CancelOrderParams(BaseModel):\n    variety: VarietyEnum = Field(..., description=\"Order variety (regular, co, amo, iceberg, auction). To be included in the URL path.\")\n    order_id: str = Field(..., description=\"The ID of the order to cancel. To be included in the URL path.\")\n    parent_order_id: Optional[str] = Field(None, description=\"Required for cancelling second-leg CO orders.\")\n\nclass GetOrdersParams(BaseModel):\n    # No parameters needed for this endpoint according to the plan\n    pass\n\nclass GetOrderHistoryParams(BaseModel):\n    order_id: str = Field(..., description=\"The ID of the order to retrieve history for. To be included in the URL path.\")\n\n# --- Response Models (Simplified based on common Kite Connect structures) ---\n\nclass PlaceOrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID.\")\n\nclass ModifyOrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID.\")\n\nclass CancelOrderResponse(BaseModel):\n    order_id: str = Field(..., description=\"The unique order ID.\")\n\nclass Order(BaseModel):\n    order_id: Optional[str] = None\n    parent_order_id: Optional[str] = None\n    exchange_order_id: Optional[str] = None\n    status: Optional[str] = None\n    status_message: Optional[str] = None\n    order_timestamp: Optional[str] = None\n    exchange_timestamp: Optional[str] = None\n    variety: Optional[str] = None\n    exchange: Optional[str] = None\n    tradingsymbol: Optional[str] = None\n    instrument_token: Optional[int] = None\n    order_type: Optional[str] = None\n    transaction_type: Optional[str] = None\n    validity: Optional[str] = None\n    product: Optional[str] = None\n    quantity: Optional[int] = None\n    disclosed_quantity: Optional[int] = None\n    price: Optional[float] = None\n    trigger_price: Optional[float] = None\n    average_price: Optional[float] = None\n    filled_quantity: Optional[int] = None\n    pending_quantity: Optional[int] = None\n    cancelled_quantity: Optional[int] = None\n    tag: Optional[str] = None\n    meta: Optional[Dict[str, Any]] = None\n    # Add other fields as needed based on actual API response\n\nclass OrderHistoryEntry(BaseModel):\n    order_id: Optional[str] = None\n    status: Optional[str] = None\n    status_message: Optional[str] = None\n    order_timestamp: Optional[str] = None # Assuming timestamp is part of history\n    # Add other fields relevant to history (e.g., rejection reason, update timestamp)\n    # This structure might need refinement based on the actual API response for order history\n    # Often, the history endpoint returns a list of full Order objects representing states.\n    # Let's assume it returns objects similar to the Order model for now.\n    exchange_order_id: Optional[str] = None\n    exchange_timestamp: Optional[str] = None\n    variety: Optional[str] = None\n    exchange: Optional[str] = None\n    tradingsymbol: Optional[str] = None\n    instrument_token: Optional[int] = None\n    order_type: Optional[str] = None\n    transaction_type: Optional[str] = None\n    validity: Optional[str] = None\n    product: Optional[str] = None\n    quantity: Optional[int] = None\n    disclosed_quantity: Optional[int] = None\n    price: Optional[float] = None\n    trigger_price: Optional[float] = None\n    average_price: Optional[float] = None\n    filled_quantity: Optional[int] = None\n    pending_quantity: Optional[int] = None\n    cancelled_quantity: Optional[int] = None\n    tag: Optional[str] = None\n"
    },
    {
      "name": "client.py",
      "content": "import httpx\nimport logging\nfrom typing import Dict, Any, List, Optional\n\nfrom models import VarietyEnum\n\nlogger = logging.getLogger(__name__)\n\nclass KiteApiException(Exception):\n    \"\"\"Custom exception for Kite Connect API errors.\"\"\"\n    def __init__(self, message: str, status_code: Optional[int] = None, details: Optional[Any] = None):\n        super().__init__(message)\n        self.status_code = status_code\n        self.details = details\n\n    def __str__(self):\n        return f\"KiteApiException: {super().__str__()} (Status: {self.status_code}, Details: {self.details})\"\n\nclass AsyncKiteClient:\n    \"\"\"Asynchronous client for interacting with the Zerodha Kite Connect API.\"\"\"\n\n    def __init__(self, api_key: str, access_token: str, base_url: str = \"https://api.kite.trade\", timeout: float = 30.0):\n        \"\"\"\n        Initializes the asynchronous Kite Connect client.\n\n        Args:\n            api_key (str): The API key obtained from Kite Connect.\n            access_token (str): The access token obtained after successful login.\n            base_url (str): The base URL for the Kite Connect API.\n            timeout (float): Default request timeout in seconds.\n        \"\"\"\n        if not api_key or not access_token:\n            raise ValueError(\"API Key and Access Token cannot be empty.\")\n\n        self.api_key = api_key\n        self.access_token = access_token\n        self.base_url = base_url\n        self.timeout = timeout\n        self.headers = {\n            \"X-Kite-Version\": \"3\",  # Specify Kite Connect API version\n            \"Authorization\": f\"token {self.api_key}:{self.access_token}\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\" # Kite uses form encoding\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers=self.headers,\n            timeout=self.timeout\n        )\n        logger.info(f\"AsyncKiteClient initialized for base URL: {self.base_url}\")\n\n    async def _request(self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Makes an asynchronous HTTP request to the Kite Connect API.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        logger.debug(f\"Making {method} request to {url}\")\n        logger.debug(f\"Headers: {self.headers}\") # Be careful logging headers in production if sensitive\n        if params:\n            logger.debug(f\"URL Params: {params}\")\n        if data:\n            logger.debug(f\"Form Data: {data}\")\n\n        try:\n            response = await self.client.request(\n                method=method,\n                url=endpoint, # httpx client uses base_url + endpoint\n                params=params,\n                data=data # Send as form data\n            )\n            response.raise_for_status()  # Raises HTTPStatusError for 4xx/5xx responses\n            json_response = response.json()\n            logger.debug(f\"Received successful response ({response.status_code}): {json_response}\")\n\n            # Kite API specific success/error check (often includes a 'status' field)\n            if json_response.get(\"status\") == \"error\":\n                error_type = json_response.get(\"error_type\", \"UnknownError\")\n                message = json_response.get(\"message\", \"Unknown API error\")\n                logger.error(f\"Kite API error: Type={error_type}, Message={message}\")\n                raise KiteApiException(message=message, status_code=response.status_code, details=json_response)\n\n            # Return the 'data' part of the response if it exists\n            return json_response.get(\"data\", json_response)\n\n        except httpx.HTTPStatusError as e:\n            status_code = e.response.status_code\n            try:\n                error_details = e.response.json()\n                message = error_details.get(\"message\", \"HTTP error\")\n                error_type = error_details.get(\"error_type\", f\"HTTP {status_code}\")\n            except Exception:\n                error_details = e.response.text\n                message = f\"HTTP error {status_code}\"\n                error_type = f\"HTTP {status_code}\"\n\n            logger.error(f\"HTTP error occurred: {status_code} - {message}\", exc_info=True)\n            raise KiteApiException(message=message, status_code=status_code, details=error_details) from e\n\n        except httpx.RequestError as e:\n            logger.error(f\"Network or request error occurred: {e}\", exc_info=True)\n            raise KiteApiException(message=f\"Network error: {e}\", details=str(e)) from e\n        except Exception as e:\n            logger.error(f\"An unexpected error occurred during API request: {e}\", exc_info=True)\n            raise KiteApiException(message=\"An unexpected error occurred\", details=str(e)) from e\n\n    async def place_order(self, variety: VarietyEnum, data: Dict[str, Any]) -> Dict[str, str]:\n        \"\"\"Place an order.\"\"\"\n        endpoint = f\"/orders/{variety.value}\"\n        return await self._request(method=\"POST\", endpoint=endpoint, data=data)\n\n    async def modify_order(self, variety: VarietyEnum, order_id: str, data: Dict[str, Any]) -> Dict[str, str]:\n        \"\"\"Modify a pending order.\"\"\"\n        endpoint = f\"/orders/{variety.value}/{order_id}\"\n        return await self._request(method=\"PUT\", endpoint=endpoint, data=data)\n\n    async def cancel_order(self, variety: VarietyEnum, order_id: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, str]:\n        \"\"\"Cancel a pending order.\"\"\"\n        endpoint = f\"/orders/{variety.value}/{order_id}\"\n        # Include parent_order_id in data if provided for CO legs\n        return await self._request(method=\"DELETE\", endpoint=endpoint, data=data or {})\n\n    async def get_orders(self) -> List[Dict[str, Any]]:\n        \"\"\"Retrieve the list of orders for the day.\"\"\"\n        endpoint = \"/orders\"\n        # The response is directly a list of orders under the 'data' key\n        result = await self._request(method=\"GET\", endpoint=endpoint)\n        if isinstance(result, list):\n            return result\n        else:\n             logger.error(f\"Unexpected response format for get_orders: {result}\")\n             raise KiteApiException(\"Unexpected response format from get_orders\", details=result)\n\n\n    async def get_order_history(self, order_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Retrieve the history for a given order ID.\"\"\"\n        endpoint = f\"/orders/{order_id}/trades\" # Note: Kite API uses /trades for history/fills\n        # Check Kite documentation - sometimes history is under /orders/{order_id} directly\n        # Assuming /trades endpoint returns fill details which act as history.\n        # If a dedicated history endpoint exists, adjust the endpoint.\n        # Let's assume the plan meant order details/trades, using the /trades endpoint.\n        # If it strictly means status changes, the /orders endpoint might be re-queried or websockets used.\n        # For now, implementing based on /trades endpoint which gives fill history.\n        # If the actual API endpoint is just /orders/{order_id}, change below.\n\n        # Correction based on common understanding: GET /orders/{order_id} might return history/details.\n        # Let's use that interpretation as /trades is specifically for trade fills.\n        endpoint = f\"/orders/{order_id}\"\n        result = await self._request(method=\"GET\", endpoint=endpoint)\n        if isinstance(result, list):\n             # The response for a single order history is typically a list of states/updates\n            return result\n        elif isinstance(result, dict):\n             # Sometimes it might return a single dict if only one state exists? Adapt as needed.\n             # Or perhaps the endpoint returns a dict containing a list under a key.\n             # Assuming the API returns a list directly as per the plan's return type List[OrderHistoryEntry]\n             logger.warning(f\"Received dict instead of list for order history {order_id}, wrapping in list.\")\n             return [result]\n        else:\n            logger.error(f\"Unexpected response format for get_order_history: {result}\")\n            raise KiteApiException(\"Unexpected response format from get_order_history\", details=result)\n\n    async def close(self):\n        \"\"\"Closes the underlying HTTPX client.\"\"\"\n        await self.client.aclose()\n        logger.info(\"AsyncKiteClient closed.\")\n"
    },
    {
      "name": "requirements.txt",
      "content": "fastmcp>=0.1.0,<0.2.0\nhttpx[http2]>=0.25.0,<0.28.0\npydantic>=1.10.0,<2.8.0\npython-dotenv>=1.0.0,<2.0.0\nasyncio>=3.4.0,<3.5.0\n"
    },
    {
      "name": ".env.example",
      "content": "# Zerodha Kite Connect API Credentials and Configuration\n# Obtain these from your Kite Connect developer console: https://developers.kite.trade/\n\n# Your Kite Connect API Key\nKITE_API_KEY=\"YOUR_API_KEY\"\n\n# Your daily generated Access Token (obtained after user login flow)\n# This token is short-lived (typically valid for one trading day)\nKITE_ACCESS_TOKEN=\"YOUR_ACCESS_TOKEN\"\n\n# Base URL for the Kite Connect API (usually doesn't need changing)\nKITE_BASE_URL=\"https://api.kite.trade\"\n\n# Optional: Set log level (e.g., DEBUG, INFO, WARNING, ERROR)\n# LOG_LEVEL=\"INFO\"\n"
    },
    {
      "name": "README.md",
      "content": "# Zerodha Kite Connect Orders MCP Server\n\nThis project provides a Model Context Protocol (MCP) server for interacting with the Zerodha Kite Connect Orders API. It allows AI agents or other applications to manage trading orders (place, modify, cancel) and retrieve order information using a standardized tool interface.\n\nThis server is built using [FastMCP](https://github.com/your-repo/fastmcp). <!-- Replace with actual FastMCP link if available -->\n\n## Features\n\n*   Place various types of orders (Regular, AMO, CO, Iceberg, Auction).\n*   Modify pending orders.\n*   Cancel pending orders.\n*   Retrieve the daily order book.\n*   Retrieve the history/details of a specific order.\n*   Asynchronous API client using `httpx`.\n*   Typed inputs and outputs using Pydantic.\n*   Configuration via environment variables.\n*   Basic error handling for API and network issues.\n\n## Prerequisites\n\n*   Python 3.8+\n*   Pip (Python package installer)\n*   A Zerodha Kite Connect API Key and Secret.\n*   A mechanism to generate a daily `access_token` (This server *requires* a valid `access_token` but does not handle the login flow to generate it. You need to obtain this token separately each day).\n\n## Setup\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository_url>\n    cd <repository_directory>\n    ```\n\n2.  **Create and activate a virtual environment:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n    ```\n\n3.  **Install dependencies:**\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **Configure environment variables:**\n    *   Copy the example environment file:\n        ```bash\n        cp .env.example .env\n        ```\n    *   Edit the `.env` file and add your Kite Connect API Key and a valid Access Token:\n        ```dotenv\n        KITE_API_KEY=\"YOUR_ACTUAL_API_KEY\"\n        KITE_ACCESS_TOKEN=\"YOUR_VALID_DAILY_ACCESS_TOKEN\"\n        KITE_BASE_URL=\"https://api.kite.trade\" # Optional: Keep default unless needed\n        ```\n    *   **Important:** The `KITE_ACCESS_TOKEN` expires daily. You must update this value with a fresh token obtained through the Kite Connect login flow for the server to function correctly.\n\n## Running the Server\n\nOnce configured, you can run the MCP server:\n\n```bash\npython main.py\n```\n\nThe server will start, typically on `http://127.0.0.1:8000` (or as configured by FastMCP defaults).\n\n## Available Tools\n\nThe following tools are exposed by this MCP server:\n\n1.  **`place_order`**: Place a new order.\n    *   Input: `PlaceOrderParams` model (includes variety, tradingsymbol, exchange, transaction_type, order_type, quantity, product, etc.)\n    *   Returns: `PlaceOrderResponse` model (contains `order_id`)\n\n2.  **`modify_order`**: Modify an existing pending order.\n    *   Input: `ModifyOrderParams` model (includes variety, order_id, and fields to modify like quantity, price, trigger_price)\n    *   Returns: `ModifyOrderResponse` model (contains `order_id`)\n\n3.  **`cancel_order`**: Cancel an existing pending order.\n    *   Input: `CancelOrderParams` model (includes variety, order_id, optional parent_order_id)\n    *   Returns: `CancelOrderResponse` model (contains `order_id`)\n\n4.  **`get_orders`**: Retrieve all orders for the current trading day.\n    *   Input: None\n    *   Returns: `List[Order]` model (list of order details)\n\n5.  **`get_order_history`**: Retrieve the history/details for a specific order.\n    *   Input: `GetOrderHistoryParams` model (includes `order_id`)\n    *   Returns: `List[OrderHistoryEntry]` model (list of order states/updates)\n\nRefer to `models.py` for detailed definitions of the input and output Pydantic models.\n\n## Error Handling\n\nThe server attempts to catch common errors:\n\n*   **API Errors:** Errors returned by the Kite Connect API (e.g., insufficient funds, invalid parameters, token errors) are caught and returned as JSON with an `error` message and `details`.\n*   **HTTP Errors:** Network issues or non-2xx responses from the API server are caught.\n*   **Validation Errors:** Invalid input parameters according to the Pydantic models will be rejected by FastMCP.\n*   **Configuration Errors:** Missing API key or access token will prevent the server from making successful calls (logged on startup).\n\n## Authentication\n\nAuthentication with the Kite Connect API is handled via the `api_key` and `access_token` provided in the environment variables. Ensure the `access_token` is valid and refreshed daily.\n\n## Rate Limits\n\nBe mindful of Kite Connect API rate limits (e.g., 3 requests/second for order placement/modification/cancellation, 10 requests/second for data retrieval). This MCP server does not implement client-side rate limiting; exceeding the limits will result in errors from the Kite API.\n\n## Disclaimer\n\nTrading involves substantial risk. This software is provided \"as is\" without warranty of any kind. Use it at your own risk. Ensure you understand the Kite Connect API documentation and the implications of automated trading before use.\n"
    }
  ]
}